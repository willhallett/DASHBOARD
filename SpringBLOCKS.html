<!-- CANARY: local edit -->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Semester Dashboard — Modes + .md Export</title>
  <link rel="icon" href="favicon.svg" type="image/svg+xml" />
  <style>
    :root {
      --bg: #fbfaf7;
      --bg-grad-1: #fffdfa;
      --bg-grad-2: #f1ebdf;
      --panel: #ffffff;
      --panel2: #f6f4ef;
      --text: #1f1b16;
      --muted: #6f675d;
      --line: #e7e1d7;
      --accent: #efeae0;
      --chip: #f3eee5;
      --danger: #d92b4b;
      --ok: #1faa7a;
      --warn: #d9a12b;
      --radius: 16px;
      --shadow: 0 18px 40px rgba(32, 24, 14, 0.08);
      --shadowSoft: 0 8px 16px rgba(32, 24, 14, 0.05);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --serif: "Palatino Linotype", Palatino, "Book Antiqua", Georgia, "Times New Roman", serif;
      --sans: "Avenir Next", "Gill Sans", "Trebuchet MS", "Segoe UI", Arial, sans-serif;
      --ink: #2b2620;
    }
    body[data-theme="bright"] {
      --bg: #ffffff;
      --bg-grad-1: #ffffff;
      --bg-grad-2: #f4f4f4;
      --panel: #ffffff;
      --panel2: #f7f7f7;
      --text: #111111;
      --muted: #666666;
      --line: #e6e6e6;
      --accent: #f2f2f2;
      --chip: #f3f3f3;
      --ink: #2d2a26;
      --shadow: 0 16px 34px rgba(32, 32, 32, 0.08);
      --shadowSoft: 0 8px 16px rgba(32, 32, 32, 0.05);
    }
    body[data-theme="dark"] {
      --bg: #141210;
      --bg-grad-1: #191613;
      --bg-grad-2: #0f0d0b;
      --panel: #1c1a17;
      --panel2: #23201c;
      --text: #e8e4dc;
      --muted: #b0a79a;
      --line: #2c2924;
      --accent: #26231f;
      --chip: #2a2722;
      --ink: #f0ece4;
      --shadow: 0 18px 40px rgba(0, 0, 0, 0.35);
      --shadowSoft: 0 8px 16px rgba(0, 0, 0, 0.25);
    }
    body[data-theme="dark"] header {
      background: rgba(20, 18, 16, 0.72);
      border-bottom-color: rgba(255, 255, 255, 0.06);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: var(--sans);
      background:
        radial-gradient(1200px 900px at 15% 0%, var(--bg-grad-1) 0%, var(--bg) 55%),
        linear-gradient(180deg, var(--bg-grad-1) 0%, var(--bg-grad-2) 100%);
      color: var(--text);
      transition: background .18s ease, color .18s ease;
    }
    :focus-visible { outline: 2px solid var(--ink); outline-offset: 2px; border-radius: 10px; }

    header {
      position: sticky;
      top: 0;
      z-index: 10;
      background: rgba(255, 255, 255, 0.72);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--line);
    }
    .wrap { max-width: 1180px; margin: 0 auto; padding: 18px 18px 48px; }
    .topbar {
      display: grid;
      grid-template-columns: 1.6fr 1fr;
      gap: 18px;
      align-items: center;
    }
    h1 { margin: 0 0 4px; font-size: 18px; letter-spacing: .3px; font-family: var(--sans); }
    .subtitle { color: var(--muted); font-size: 12px; line-height: 1.4; }
    .controls {
      display: flex; gap: 10px; justify-content: flex-end; flex-wrap: wrap;
    }
    .controls details {
      border: 1px solid var(--line);
      background: var(--panel2);
      border-radius: 12px;
      padding: 6px 10px;
    }
    .controls details[open] {
      box-shadow: var(--shadowSoft);
    }
    .controls summary {
      cursor: pointer;
      font-weight: 700;
      font-size: 12px;
      list-style: none;
    }
    .controls summary::-webkit-details-marker { display: none; }
    .controls .utility-actions {
      display: grid;
      gap: 8px;
      margin-top: 8px;
    }
    button, .btn {
      border: 1px solid var(--line);
      background: var(--panel2);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      cursor: pointer;
      box-shadow: none;
      font-weight: 600;
      font-size: 13px;
      transition: background .18s ease, border-color .18s ease, color .18s ease, box-shadow .18s ease;
    }
    button:hover { border-color: var(--ink); background: var(--accent); }
    button:active { transform: translateY(1px); }
    .btn-secondary { background: var(--accent); box-shadow: none; }
    .btn-danger { border-color: rgba(255,92,122,.35); }
    .btn-danger:hover { border-color: rgba(255,92,122,.65); }
    .theme-switch { display: flex; gap: 6px; align-items: center; }
    .theme-switch select {
      border: 1px solid var(--line);
      background: var(--panel2);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 12px;
      font-weight: 600;
    }

    main { padding-top: 18px; }
    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 980px) {
      .topbar { grid-template-columns: 1fr; }
      .controls { justify-content: flex-start; }
      .grid { grid-template-columns: 1fr; }
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 18px;
      box-shadow: var(--shadowSoft);
      position: relative;
      transition: background .18s ease, border-color .18s ease, box-shadow .18s ease, transform .18s ease, opacity .18s ease;
    }
    .card-toggle {
      position: absolute;
      top: 12px;
      right: 12px;
      border: 1px solid var(--line);
      background: var(--panel2);
      color: var(--text);
      padding: 6px 10px;
      border-radius: 10px;
      font-size: 11px;
      font-weight: 700;
      cursor: pointer;
    }
    .card-toggle:hover { background: var(--accent); border-color: var(--ink); }
    body.card-focus { overflow: hidden; }
    body.card-focus::before {
      content: "";
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.08);
      z-index: 50;
    }
    .card.expanded {
      position: fixed;
      inset: 78px 22px 22px;
      z-index: 70;
      box-shadow: var(--shadow);
      overflow: auto;
      transform: translateZ(0);
    }
    .card.dimmed {
      opacity: 0.2;
      filter: blur(0.6px) saturate(0.9);
      pointer-events: none;
    }
    .card h2 {
      margin: 0 0 10px;
      font-size: 15px;
      letter-spacing: .6px;
      font-family: var(--sans);
    }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .row > * { flex: 1; }
    .row .tight { flex: 0 0 auto; }
    label { font-size: 12px; color: var(--muted); display: block; margin: 8px 0 6px; }
    input[type="text"], input[type="number"], textarea, select {
      width: 100%;
      border: 1px solid var(--line);
      background: var(--panel2);
      color: var(--text);
      padding: 10px 10px;
      border-radius: 12px;
      outline: none;
      font-size: 13px;
      transition: background .18s ease, border-color .18s ease, color .18s ease;
    }
    textarea { min-height: 92px; resize: vertical; }
    .mini { font-size: 12px; color: var(--muted); margin-top: 8px; }

    .chips { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 6px; }
    .chip {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      background: var(--chip);
      border: 1px solid var(--line);
      padding: 8px 10px;
      border-radius: 999px;
      font-size: 12px;
      color: var(--text);
      user-select: none;
      transition: background .18s ease, border-color .18s ease, color .18s ease;
    }
    .chip input { transform: translateY(1px); }
    .chip .chip-btn {
      border: 1px solid var(--line);
      background: var(--panel);
      color: var(--text);
      border-radius: 8px;
      padding: 2px 6px;
      font-size: 11px;
      cursor: pointer;
    }
    .pill {
      font-family: var(--mono);
      padding: 5px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--panel2);
      color: var(--muted);
      font-size: 11px;
      white-space: nowrap;
    }
    .pill.ink { color: var(--ink); border-color: rgba(58,61,94,.25); }

    .section-title {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      align-items: baseline;
      margin-bottom: 8px;
      padding-bottom: 6px;
      border-bottom: 1px dashed rgba(45,42,38,.15);
    }
    .section-title .hint { color: var(--muted); font-size: 12px; }

    .task {
      display: grid;
      grid-template-columns: 24px 1fr 110px 110px 34px;
      gap: 10px;
      align-items: center;
      padding: 9px 10px;
      border: 1px solid var(--line);
      background: var(--panel2);
      border-radius: 14px;
      margin-bottom: 8px;
      transition: background .18s ease, border-color .18s ease, color .18s ease;
    }
    .task input[type="checkbox"] { width: 18px; height: 18px; }
    .task input[type="text"] { padding: 9px 9px; }
    .task select { padding: 9px 9px; }
    .task .del {
      width: 34px; height: 34px; border-radius: 12px;
      background: rgba(255,92,122,.08);
      border: 1px solid rgba(255,92,122,.25);
      color: var(--text); cursor: pointer;
      box-shadow: none;
      font-weight: 900;
    }
    .task .del:hover { border-color: rgba(255,92,122,.55); }
    .task.done { opacity: .7; }
    .task.done .title { text-decoration: line-through; color: var(--muted); }

    .cols {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
    }
    @media (max-width: 980px) { .cols { grid-template-columns: 1fr; } }
    .stack-col {
      display: grid;
      grid-template-rows: 1fr 1fr;
      gap: 14px;
    }

    .mdbox {
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.45;
      white-space: pre-wrap;
      border: 1px dashed var(--ink);
      background: var(--panel2);
      padding: 12px;
      border-radius: 14px;
      min-height: 160px;
      max-height: 360px;
      overflow: auto;
    }

    .statusline { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
    .dot.ok { background: var(--ok); }
    .dot.warn { background: var(--warn); }
    .dot.bad { background: var(--danger); }

    .footer-note { color: var(--muted); font-size: 12px; margin-top: 10px; }
    a { color: var(--ink); }

    body.print-preview {
      background: #ffffff;
      color: #1f2234;
    }
    body.print-preview header {
      position: static;
      backdrop-filter: none;
      background: #ffffff;
    }
    body.print-preview .controls,
    body.print-preview button,
    body.print-preview .inlineForm,
    body.print-preview .del {
      display: none !important;
    }
    body.print-preview button.print-exit {
      display: inline-flex !important;
    }
    body.print-preview input,
    body.print-preview textarea,
    body.print-preview select {
      border: none;
      background: transparent;
      padding: 0;
      color: #1f2234;
      box-shadow: none;
    }
    body.print-preview .card {
      box-shadow: none;
    }

    .print-exit {
      position: fixed;
      top: 14px;
      right: 18px;
      z-index: 60;
      display: none;
    }
    body.print-preview .print-exit { display: inline-flex; }

    @media print {
      header,
      .controls,
      button,
      .inlineForm,
      .del {
        display: none !important;
      }
      .print-exit {
        display: none !important;
      }
      body {
        background: #ffffff;
        color: #1f2234;
      }
      .card {
        box-shadow: none;
      }
    }

    /* Toast */
    .toast {
      position: fixed;
      right: 16px;
      bottom: 16px;
      z-index: 50;
      background: var(--panel);
      border: 1px solid var(--line);
      box-shadow: none;
      padding: 10px 12px;
      border-radius: 14px;
      font-size: 12px;
      color: var(--text);
      opacity: 0;
      transform: translateY(6px);
      pointer-events: none;
      transition: opacity .18s ease, transform .18s ease;
    }
    .toast.show { opacity: 1; transform: translateY(0px); }

    /* Inline form */
    .inlineForm {
      border: 1px solid var(--line);
      background: var(--panel2);
      border-radius: 14px;
      padding: 10px;
      margin-top: 10px;
      display: none;
    }
    .inlineForm.show { display: block; }
    .inlineForm .cols { margin-top: 6px; }

    /* Forest */
    .span2 { grid-column: 1 / -1; } /* full-width card within the grid row */

    .forestWrap {
      border: 1px solid var(--line);
      background: var(--panel2);
      border-radius: 14px;
      padding: 10px;
      margin-top: 10px;
      overflow: hidden;
    }
    canvas#forestCanvas {
      width: 100%;
      height: 900px; /* taller to show mycelium network beneath labels */
      display: block;
      border-radius: 12px;
      background: var(--panel);
    }
    .forestLegend {
      margin-top: 10px;
      border: 1px solid var(--line);
      background: var(--panel2);
      border-radius: 14px;
      padding: 10px;
      font-size: 12px;
      color: var(--muted);
      display: none;
    }
    .forestLegend.show { display: block; }
    .forestLegend b { color: var(--ink); }
    .forestLegend code { font-family: var(--mono); font-size: 11px; color: var(--ink); }

    /* Concept graph */
    #conceptGraphCanvas {
      width: 100%;
      height: 320px;
      display: block;
      border-radius: 12px;
      background: var(--panel);
      border: 1px solid var(--line);
    }
    @media (max-width: 980px) {
      .card.expanded { inset: 72px 12px 12px; }
    }
    .graphHint { font-size: 12px; color: var(--muted); margin-top: 8px; }

    .apiKeyInput {
      min-width: 220px;
    }
  </style>
</head>

<body>
<button class="btn-secondary print-exit" id="btnExitPrintPreview">Exit print preview</button>
<header>
  <div class="wrap topbar">
    <div>
      <h1>WILL HALLETT EES/GCAS SPRING 2026</h1>
      <div class="subtitle">
        Default posture: <span class="pill">9–5 = material-building</span> • evenings/weekends = deliverables.
        Everything auto-saves locally.
      </div>
    </div>
    <div class="controls">
      <label class="chip tight theme-switch">
        <span>Theme</span>
        <select id="themeSelect" aria-label="Theme mode">
          <option value="soft">Soft</option>
          <option value="bright">Bright</option>
          <option value="dark">Dark</option>
        </select>
      </label>
      <button class="btn-secondary" id="btnResetDay">Reset “Day”</button>
      <button class="btn-secondary" id="btnPrintPreview">Print preview</button>
      <details>
        <summary>Utilities</summary>
        <div class="utility-actions">
          <button class="btn-secondary" id="btnResetWeek">Weekly reset</button>
          <button class="btn-secondary" id="btnBackup">Export JSON backup</button>
          <button class="btn-secondary" id="btnImport">Import JSON backup</button>
          <button class="btn-secondary" id="btnSaveVault">Save to Vault</button>
          <button class="btn-danger" id="btnHardReset">Hard reset (wipe local)</button>
        </div>
      </details>
    </div>
  </div>
</header>

<main class="wrap">
  <!-- Week Summary FULL WIDTH -->
  <div class="grid" style="margin-top:14px;">
    <section class="card span2">
      <div class="section-title">
        <h2>Week Summary</h2>
        <div class="hint">Stability readout + forest (no extra data entry)</div>
      </div>

      <div id="weekSummary" class="mini"></div>

      <div class="forestWrap" aria-label="Weekly forest visualization">
        <div class="row" style="margin-bottom:10px;">
          <button class="btn-secondary" id="btnToggleLegend" title="Toggle legend">Legend</button>
          <button class="btn-secondary" id="btnExportPNG" title="Download forest as JPG">Export JPG</button>
          <button class="btn-secondary" id="btnExportSVG" title="Download forest as SVG">Export SVG</button>
          <button class="btn-secondary" id="btnSimForest" title="Toggle max-week simulation">Simulate Max</button>
          <button class="btn-secondary" id="btnClearGhost" title="Clear last-week ghost overlay">Clear ghost</button>
          <label class="chip tight" style="padding:6px 10px;">
            <input type="checkbox" id="toggleFullGhost" />
            Full ghost
          </label>
          <label class="chip tight" style="padding:6px 10px;">
            <input type="checkbox" id="toggleHiResPng" />
            Hi-res JPG
          </label>
        </div>

        <canvas id="forestCanvas"></canvas>

        <div id="forestLegend" class="forestLegend"></div>
      </div>

      <div class="footer-note">
        This is computed from tasks + course statuses + your writing. It grows during the week (max-growth memory for writing/task completion), and overlays last week as a faint trace. Stress and daily-mode checkboxes remain dynamic.
      </div>
    </section>
  </div>

  <div class="grid">
    <!-- Left column: core structure -->
    <section class="card">
      <div class="section-title">
        <h2>Core Rhythm</h2>
        <div class="hint">Set the rules of engagement</div>
      </div>

      <label>Semester intent (1–2 sentences)</label>
      <input type="text" id="intent" placeholder="e.g., Build real understanding; avoid backlog; weekend slay sessions bounded." />

      <div class="cols" style="margin-top:10px;">
        <div>
          <label>Weekday core window</label>
          <input type="text" id="coreWindow" placeholder="e.g., 9:00–17:00" />
          <div class="mini">Used in the markdown export header.</div>
        </div>
        <div>
          <label>Weekend posture</label>
          <input type="text" id="weekendPosture" placeholder="e.g., deliverables + exam review + downtime" />
          <div class="mini">Keep bounded so it doesn’t become spillover.</div>
        </div>
        <div>
          <label>Weekly rebalance day</label>
          <select id="rebalanceDay">
            <option>Friday</option><option>Saturday</option><option>Sunday</option><option>Monday</option>
          </select>
          <div class="mini">20 minutes to re-allocate blocks.</div>
        </div>
      </div>

      <label style="margin-top:12px;">Modes checklist (daily + weekly anchors)</label>
      <div class="row inlineForm show" id="modeEditor" style="margin-bottom:8px;">
        <input type="text" id="newModeLabel" placeholder="Add mode label" />
        <select id="newModeScope">
          <option value="daily">daily</option>
          <option value="weekly" selected>weekly</option>
        </select>
        <button class="btn-secondary tight" id="btnAddMode">Add</button>
      </div>
      <div class="chips" id="modeChips"></div>

      <div class="footer-note">
        Tip: keep one protected “absorption block” each weekday (no new inputs; only consolidation).
      </div>
    </section>

    <!-- Right column: today planner -->
    <section class="card">
      <div class="section-title">
        <h2>Today — Focus & Blocks</h2>
        <div class="hint">Plan lightly; execute steadily</div>
      </div>

      <div class="cols">
        <div>
          <label>Keystone course today</label>
          <select id="keystoneToday"></select>
          <div class="mini">If this is stable, the day is stable.</div>
        </div>
        <div>
          <label>Absorption block (60–90 min)</label>
          <input type="text" id="absorption" placeholder="e.g., AOIC: re-derive key mechanisms + quiz-style Qs" />
        </div>
        <div>
          <label>Workout (quick note)</label>
          <input type="text" id="workout" placeholder="e.g., 35 min run + mobility" />
        </div>
      </div>

      <label style="margin-top:12px;">Quick capture (what matters / what’s fuzzy)</label>
      <textarea id="todayNotes" placeholder="2–6 bullet points: what landed, what’s confusing, what to ask ChatGPT / prof."></textarea>

      <div class="row" style="margin-top:10px;">
        <button id="btnAddTodayTask">+ Add Today Task</button>
        <button class="btn-secondary" id="btnClearTodayDone">Clear completed</button>
      </div>

      <div id="todayTasks" style="margin-top:10px;"></div>
    </section>
  </div>

  <div class="grid" style="margin-top:14px;">
    <!-- Courses -->
    <section class="card">
      <div class="section-title">
        <h2>Courses — Modes + Notes</h2>
        <div class="hint">Keep each course bounded</div>
      </div>

      <div class="row">
        <div>
          <label>Courses (editable)</label>
          <input type="text" id="courseList" placeholder="AOIC; Neurobiology; Biological Modeling; Calc II; Probability/Prereqs; GCAS Writing" />
          <div class="mini">Separate with semicolons.</div>
        </div>
        <div class="tight">
          <label>&nbsp;</label>
          <button class="btn-secondary" id="btnApplyCourses">Apply</button>
        </div>
      </div>

      <div id="courseCards" style="margin-top:12px;"></div>
    </section>

    <div class="stack-col">
      <!-- Writing sessions -->
      <section class="card focus-card">
        <div class="section-title">
          <h2>GCAS Writing</h2>
          <div class="hint">Light, consistent, non-sprawling</div>
        </div>

        <div class="cols" style="margin-top:10px;">
          <div>
            <label>GCAS schedule</label>
            <input type="text" id="writingSchedule" placeholder="e.g., Tue/Thu afternoons" />
          </div>
          <div>
            <label>Current writing thread</label>
            <input type="text" id="writingThread" placeholder="e.g., Neural Set; Saussure/Lacan; modeling epistemology" />
          </div>
          <div>
            <label>GCAS targets</label>
            <input type="text" id="writingTargets" placeholder="e.g., 300 words target; Badiou set theory; Freud neurobiology" />
          </div>
        </div>
        <label style="margin-top:12px;">GCAS notes</label>
        <textarea id="writingNotes" placeholder="Short synthesis, questions, or conceptual bridges to keep."></textarea>
        <div class="footer-note">Keep cadence and conceptual targets lightweight but explicit.</div>
      </section>

      <!-- Prose writing -->
      <section class="card focus-card">
        <div class="section-title">
          <h2>Prose Writing</h2>
          <div class="hint">Drafts, reflections, and narrative output</div>
        </div>

        <div class="cols" style="margin-top:10px;">
          <div>
            <label>Prose schedule</label>
            <input type="text" id="proseSchedule" placeholder="e.g., Wed/Fri afternoons" />
          </div>
          <div>
            <label>Current prose project</label>
            <input type="text" id="proseProject" placeholder="e.g., Semester reflection essay; narrative recap" />
          </div>
          <div>
            <label>Prose targets</label>
            <input type="text" id="proseTargets" placeholder="e.g., 300 words; draft scene; revision focus" />
          </div>
        </div>

        <label style="margin-top:12px;">Prose notes</label>
        <textarea id="proseNotes" placeholder="Short notes, tone cues, or narrative beats to keep." ></textarea>

        <div class="footer-note">Separate from GCAS; keep prose constraints visible.</div>
      </section>
    </div>
  </div>

  <div class="grid" style="margin-top:14px;">
    <!-- Weekend deliverables -->
    <section class="card">
      <div class="section-title">
        <h2>Weekend Deliverables</h2>
        <div class="hint">Slay sessions with edges</div>
      </div>

      <div class="row">
        <button id="btnAddWeekendTask">+ Add deliverable</button>
        <button class="btn-secondary" id="btnClearWeekendDone">Clear completed</button>
      </div>

      <div id="weekendTasks" style="margin-top:10px;"></div>

      <label style="margin-top:12px;">Downtime boundary (write it like a rule)</label>
      <input type="text" id="downtimeRule" placeholder="e.g., Sat night off; Sun morning slow; no work after 8pm." />
    </section>

    <!-- Markdown export -->
    <section class="card">
      <div class="section-title">
        <h2>.md Export (Obsidian)</h2>
        <div class="hint">Generate, copy, download</div>
      </div>

      <div class="row">
        <button id="btnGenerateMd">Generate Markdown</button>
        <input type="password" id="openaiKey" class="apiKeyInput" placeholder="OpenAI API key" />
        <button class="btn-secondary" id="btnCopyMd">Copy</button>
        <button class="btn-secondary" id="btnDownloadMd">Download .md</button>
        <button class="btn-secondary" id="btnClearMd">Clear Markdown</button>
        <button class="btn-secondary" id="btnArchiveBundle">Archive bundle</button>
      </div>

      <label style="margin-top:12px;">Markdown preview</label>
      <div id="mdPreview" class="mdbox"></div>

      <div class="statusline" style="margin-top:10px;">
        <span class="dot ok"></span><span class="mini">Saved locally</span>
        <span class="dot warn"></span><span class="mini">Reset week = clears writing + tasks</span>
        <span class="dot bad"></span><span class="mini">Hard reset wipes everything</span>
      </div>
    </section>
  </div>

  <div class="grid" style="margin-top:14px;">
    <!-- Concept graph -->
    <section class="card span2">
      <div class="section-title">
        <h2>Concept Graph (3D)</h2>
        <div class="hint">Major concepts and linkages across writing</div>
      </div>
      <canvas id="conceptGraphCanvas" aria-label="3D concept linkage graph"></canvas>
      <div class="row" style="margin-top:10px;">
        <button class="btn-secondary" id="btnRegenGraph">Regenerate graph</button>
        <label class="chip tight" style="padding:6px 10px;">
          <span style="margin-right:6px;">Spacing</span>
          <input type="range" id="graphSpacing" min="0.8" max="4.5" step="0.1" value="4.5" />
        </label>
      </div>
      <div class="graphHint">Drag to rotate; scroll to zoom. Nodes are inferred from all writing artifacts.</div>
    </section>
  </div>
</main>

<div id="toast" class="toast" role="status" aria-live="polite"></div>
<input type="file" id="importFile" accept="application/json" style="display:none" />

<script>
  // ---------- Version + migration ----------
  const STORAGE_KEY = "semester_dashboard_v1";
  const CURRENT_VERSION = 11; // add forest simulation toggle

  const DEFAULT = {
    version: CURRENT_VERSION,

    intent: "",
    coreWindow: "9:00–17:00",
    weekendPosture: "Deliverables + exam review + downtime",
    rebalanceDay: "Sunday",

    // Daily vs weekly semantics
    modeScope: {},

    modeChecks: {},

    courses: ["AOIC", "Neurobiology", "Biological Modeling", "Calc II", "Probability/Prereqs", "GCAS Writing"],
    courseNotes: {},

    keystoneToday: "AOIC",
    absorption: "",
    workout: "",
    todayNotes: "",
    todayTasks: [],
    weekendTasks: [],

    writingSchedule: "Tue/Thu afternoons",
    writingThread: "",
    writingTargets: "300 words target; Badiou set theory; Freud neurobiology",
    writingNotes: "",

    proseSchedule: "Wed/Fri afternoons",
    proseProject: "",
    proseTargets: "300 words; draft scene; revision focus",
    proseNotes: "",

    env: null,

    downtimeRule: "",
    mdCache: "",
    lastExport: null,
    printPreview: false,
    theme: "soft",
    llmKey: "",
    llmNoteAnalyses: {},
    llmConferenceResponse: "",

    // Forest
    forest: {
      legendOn: false,
      weekId: "",
      perCourseMax: {},   // max-memory for writing volume / syntax / cohesion / completed tasks
      hiResPng: false,
      showFullGhost: false,
      simulateMax: false,
      weekly: { weekId: "", courses: {} },
    }
  };

  function structuredDefault() {
    return (typeof structuredClone === "function")
      ? structuredClone(DEFAULT)
      : JSON.parse(JSON.stringify(DEFAULT));
  }

  function migrateState(s) {
    const v = s?.version || 1;
    if (v < 2) {
      s.modeScope = s.modeScope || structuredDefault().modeScope;
      s.version = 2;
    }
    if (v < 3) {
      s.forest = s.forest || structuredDefault().forest;
      s.version = 3;
    }
    if (v < 4) {
      // v4: remove maxStress storage if present; keep only the intended max-memory metrics
      if (s.forest?.perCourseMax) {
        for (const k of Object.keys(s.forest.perCourseMax)) {
          if ("maxStress" in s.forest.perCourseMax[k]) delete s.forest.perCourseMax[k].maxStress;
        }
      }
      s.version = 4;
    }
    if (v < 5) {
      s.proseProject = s.proseProject ?? "";
      s.proseNotes = s.proseNotes ?? "";
      s.version = 5;
    }
    if (v < 6) {
      s.lastExport = s.lastExport ?? null;
      s.printPreview = s.printPreview ?? false;
      s.forest = s.forest || structuredDefault().forest;
      s.forest.hiResPng = s.forest.hiResPng ?? false;
      s.version = 6;
    }
    if (v < 7) {
      s.writingSchedule = s.writingSchedule ?? structuredDefault().writingSchedule;
      s.writingTargets = s.writingTargets ?? structuredDefault().writingTargets;
      s.writingNotes = s.writingNotes ?? "";
      s.proseSchedule = s.proseSchedule ?? structuredDefault().proseSchedule;
      s.proseTargets = s.proseTargets ?? structuredDefault().proseTargets;
      s.env = s.env ?? null;
      s.version = 7;
    }
    if (v < 8) {
      s.forest = s.forest || structuredDefault().forest;
      s.forest.weekly = s.forest.weekly || structuredDefault().forest.weekly;
      s.version = 8;
    }
    if (v < 9) {
      s.llmKey = s.llmKey ?? "";
      s.llmNoteAnalyses = s.llmNoteAnalyses ?? {};
      s.llmConferenceResponse = s.llmConferenceResponse ?? "";
      s.forest = s.forest || structuredDefault().forest;
      s.forest.showFullGhost = s.forest.showFullGhost ?? false;
      s.version = 9;
    }
    if (v < 10) {
      s.theme = s.theme ?? "soft";
      s.version = 10;
    }
    if (v < 11) {
      s.forest = s.forest || structuredDefault().forest;
      s.forest.simulateMax = s.forest.simulateMax ?? false;
      s.version = 11;
    }
    return s;
  }

  function loadState() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return structuredDefault();
      const parsed = migrateState(JSON.parse(raw));
      const def = structuredDefault();
      return {
        ...def,
        ...parsed,
        version: CURRENT_VERSION,
        modeChecks: { ...def.modeChecks, ...(parsed.modeChecks||{}) },
        modeScope:  { ...def.modeScope,  ...(parsed.modeScope||{})  },
        forest:     { ...def.forest,     ...(parsed.forest||{})     },
      };
    } catch {
      return structuredDefault();
    }
  }

  let state = loadState();

  function saveState() {
    state.version = CURRENT_VERSION;
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  }

  function applyImportedState(raw) {
    const parsed = migrateState(raw || {});
    const def = structuredDefault();
    state = {
      ...def,
      ...parsed,
      version: CURRENT_VERSION,
      modeChecks: { ...def.modeChecks, ...(parsed.modeChecks || {}) },
      modeScope: { ...def.modeScope, ...(parsed.modeScope || {}) },
      forest: { ...def.forest, ...(parsed.forest || {}) }
    };
    saveState();
    hydrateInputs();
  }

  function uid() {
    return Math.random().toString(16).slice(2) + Date.now().toString(16);
  }

  // ---------- Toast ----------
  let toastTimer = null;
  function toast(msg) {
    const t = document.getElementById("toast");
    t.textContent = msg;
    t.classList.add("show");
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => t.classList.remove("show"), 1200);
  }

  // ---------- Elements ----------
  const el = (id) => document.getElementById(id);

  const intentEl = el("intent");
  const coreWindowEl = el("coreWindow");
  const weekendPostureEl = el("weekendPosture");
  const rebalanceDayEl = el("rebalanceDay");
  const themeSelectEl = el("themeSelect");
  const modeChipsEl = el("modeChips");
  const modeEditorEl = el("modeEditor");
  const newModeLabelEl = el("newModeLabel");
  const newModeScopeEl = el("newModeScope");

  const keystoneTodayEl = el("keystoneToday");
  const absorptionEl = el("absorption");
  const workoutEl = el("workout");
  const todayNotesEl = el("todayNotes");
  const todayTasksEl = el("todayTasks");

  const weekSummaryEl = el("weekSummary");

  const courseListEl = el("courseList");
  const courseCardsEl = el("courseCards");

  const writingScheduleEl = el("writingSchedule");
  const writingThreadEl = el("writingThread");
  const writingTargetsEl = el("writingTargets");
  const writingNotesEl = el("writingNotes");

  const proseScheduleEl = el("proseSchedule");
  const proseProjectEl = el("proseProject");
  const proseTargetsEl = el("proseTargets");
  const proseNotesEl = el("proseNotes");
  const conceptGraphCanvas = el("conceptGraphCanvas");
  const btnRegenGraph = el("btnRegenGraph");
  const graphSpacingEl = el("graphSpacing");

  const weekendTasksEl = el("weekendTasks");
  const downtimeRuleEl = el("downtimeRule");

  const mdPreviewEl = el("mdPreview");
  const openaiKeyEl = el("openaiKey");
  const btnImportEl = el("btnImport");
  const importFileEl = el("importFile");
  const btnSaveVaultEl = el("btnSaveVault");

  // Forest elements
  const forestCanvas = el("forestCanvas");
  const forestLegendEl = el("forestLegend");
  const toggleHiResPngEl = el("toggleHiResPng");
  const toggleFullGhostEl = el("toggleFullGhost");
  const btnSimForest = el("btnSimForest");

  // ---------- Utilities ----------
  function escapeHtml(s) {
    return (s || "").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
  }

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function getCSSVar(name){
    return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
  }

  function initCanvasHiDPI(canvas, width = null, height = null) {
    const rect = canvas.getBoundingClientRect();
    const cssW = width ?? rect.width;
    const cssH = height ?? rect.height;
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.max(1, Math.floor(cssW * dpr));
    canvas.height = Math.max(1, Math.floor(cssH * dpr));
    const ctx = canvas.getContext("2d");
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    return { ctx, w: cssW, h: cssH, dpr };
  }

  function hexToRgb(hex) {
    const h = String(hex || "").replace("#", "");
    if (h.length === 3) {
      return {
        r: parseInt(h[0] + h[0], 16),
        g: parseInt(h[1] + h[1], 16),
        b: parseInt(h[2] + h[2], 16)
      };
    }
    return {
      r: parseInt(h.slice(0, 2), 16),
      g: parseInt(h.slice(2, 4), 16),
      b: parseInt(h.slice(4, 6), 16)
    };
  }

  function mixHex(a, b, t) {
    const c1 = hexToRgb(a);
    const c2 = hexToRgb(b);
    const mix = (v1, v2) => Math.round(v1 + (v2 - v1) * t);
    const r = mix(c1.r, c2.r).toString(16).padStart(2, "0");
    const g = mix(c1.g, c2.g).toString(16).padStart(2, "0");
    const bch = mix(c1.b, c2.b).toString(16).padStart(2, "0");
    return `#${r}${g}${bch}`;
  }

  function debounce(fn, ms){
    let t = null;
    return (...args) => {
      clearTimeout(t);
      t = setTimeout(() => fn(...args), ms);
    };
  }

  function applyTheme(theme) {
    const next = ["bright", "soft", "dark"].includes(theme) ? theme : "soft";
    document.body.dataset.theme = next;
    if (state) {
      state.theme = next;
      saveState();
    }
    if (themeSelectEl) themeSelectEl.value = next;
  }

  // ISO week id: YYYY-Www
  function isoWeekId(date = new Date()) {
    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    const dayNum = d.getUTCDay() || 7; // Mon=1..Sun=7
    d.setUTCDate(d.getUTCDate() + 4 - dayNum);
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    const y = d.getUTCFullYear();
    const w = String(weekNo).padStart(2, "0");
    return `${y}-W${w}`;
  }

  function prevIsoWeekId(currentId){
    const [yPart, wPart] = currentId.split("-W");
    const y = Number(yPart);
    const w = Number(wPart);
    const jan4 = new Date(Date.UTC(y, 0, 4));
    const dayNum = jan4.getUTCDay() || 7;
    const mondayWeek1 = new Date(jan4);
    mondayWeek1.setUTCDate(jan4.getUTCDate() - (dayNum - 1));
    const mondayTarget = new Date(mondayWeek1);
    mondayTarget.setUTCDate(mondayWeek1.getUTCDate() + (w - 1) * 7);
    mondayTarget.setUTCDate(mondayTarget.getUTCDate() - 7);
    return isoWeekId(new Date(mondayTarget.getUTCFullYear(), mondayTarget.getUTCMonth(), mondayTarget.getUTCDate()));
  }

  function getETParts(date = new Date()) {
    const fmt = new Intl.DateTimeFormat("en-US", {
      timeZone: "America/New_York",
      weekday: "short",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      hour12: false
    });
    const parts = fmt.formatToParts(date);
    const out = {};
    parts.forEach((p) => { out[p.type] = p.value; });
    return {
      weekday: out.weekday || "",
      year: out.year || "1970",
      month: out.month || "01",
      day: out.day || "01",
      hour: Number(out.hour || 0)
    };
  }

  function etDateKey(date = new Date()) {
    const p = getETParts(date);
    return `${p.year}-${p.month}-${p.day}`;
  }

  function isMondayAfterNoonET(date = new Date()) {
    const p = getETParts(date);
    return p.weekday === "Mon" && p.hour >= 12;
  }

  // ---------- Render helpers ----------
  function renderModeChips() {
    modeChipsEl.innerHTML = "";
    const labels = Object.keys(state.modeChecks);

    labels.forEach((label) => {
      const chip = document.createElement("label");
      chip.className = "chip";

      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.checked = !!state.modeChecks[label];
      cb.addEventListener("change", () => {
        state.modeChecks[label] = cb.checked;
        saveState();
        renderWeekSummary();
        debouncedForest(); // dynamic response to daily checkbox changes
      });

      const span = document.createElement("span");
      span.textContent = label;

      const scope = document.createElement("span");
      scope.className = "pill";
      scope.textContent = (state.modeScope?.[label] || "weekly").toUpperCase();

      const del = document.createElement("button");
      del.className = "del";
      del.textContent = "×";
      del.title = "Delete mode";
      del.addEventListener("click", (e) => {
        e.preventDefault();
        delete state.modeChecks[label];
        delete state.modeScope[label];
        saveState();
        renderModeChips();
        renderWeekSummary();
        debouncedForest();
      });

      chip.appendChild(cb);
      chip.appendChild(span);
      chip.appendChild(scope);
      chip.appendChild(del);
      modeChipsEl.appendChild(chip);
    });
  }

  function renderKeystoneDropdown() {
    keystoneTodayEl.innerHTML = "";
    state.courses.forEach((c) => {
      const opt = document.createElement("option");
      opt.value = c;
      opt.textContent = c;
      keystoneTodayEl.appendChild(opt);
    });
    keystoneTodayEl.value = state.keystoneToday || state.courses[0] || "";
  }

  function renderCourseCards() {
    courseCardsEl.innerHTML = "";
    state.courses.forEach((course) => {
      if (!state.courseNotes[course]) {
        state.courseNotes[course] = { status: "steady", focus: "", budget: "", notes: "" };
      }
      const data = state.courseNotes[course];

      const card = document.createElement("div");
      card.className = "card course-card";
      card.style.marginBottom = "10px";

      const title = document.createElement("div");
      title.className = "section-title";
      title.innerHTML = `<h2>${escapeHtml(course)}</h2><div class="hint">bounded notes + focus modes</div>`;
      card.appendChild(title);

      const row = document.createElement("div");
      row.className = "cols";

      const col1 = document.createElement("div");
      col1.innerHTML = `<label>Status</label>`;
      const status = document.createElement("select");
      ["steady","watch","hot","danger"].forEach(s => {
        const opt = document.createElement("option");
        opt.value = s;
        opt.textContent = s;
        status.appendChild(opt);
      });
      status.value = data.status || "steady";
      status.addEventListener("change", () => {
        state.courseNotes[course].status = status.value;
        saveState();
        renderWeekSummary();
        debouncedForest(); // dynamic response to stress changes
      });
      col1.appendChild(status);

      const col2 = document.createElement("div");
      col2.innerHTML = `<label>Focus (this week)</label>`;
      const focus = document.createElement("input");
      focus.type = "text";
      focus.placeholder = "e.g., AOIC quiz prep; Neuro: lecture map; Modeling: tools + first HW";
      focus.value = data.focus || "";
      focus.addEventListener("input", () => {
        state.courseNotes[course].focus = focus.value;
        saveState();
        debouncedGraph();
      });
      col2.appendChild(focus);

      const col3 = document.createElement("div");
      col3.innerHTML = `<label>Block budget</label>`;
      const budget = document.createElement("input");
      budget.type = "text";
      budget.placeholder = "e.g., 1 deep block + 2 light blocks";
      budget.value = data.budget || "";
      budget.addEventListener("input", () => {
        state.courseNotes[course].budget = budget.value;
        saveState();
        debouncedGraph();
      });
      col3.appendChild(budget);

      row.appendChild(col1); row.appendChild(col2); row.appendChild(col3);
      card.appendChild(row);

      const notesLabel = document.createElement("label");
      notesLabel.style.marginTop = "10px";
      notesLabel.textContent = "Notes (what landed / what’s fuzzy / next question)";
      card.appendChild(notesLabel);

      const weeklyBadge = document.createElement("div");
      weeklyBadge.className = "mini";
      weeklyBadge.style.marginTop = "6px";
      card.appendChild(weeklyBadge);

      const notes = document.createElement("textarea");
      notes.value = data.notes || "";
      notes.placeholder = "Keep it short. Capture confusion early.";
      notes.addEventListener("input", () => {
        state.courseNotes[course].notes = notes.value;
        updateWeeklySession(course, notes.value);
        saveState();
        const weekId = isoWeekId(new Date());
        const weekly = weeklyScoreForCourse(course, weekId);
        const todayKey = etDateKey();
        const dayScore = (state.forest.weekly?.courses?.[course]?.days?.[todayKey] || 0);
        weeklyBadge.textContent = `Weekly sessions: ${weekly.sessions}/6 • Today: ${(dayScore * 100).toFixed(0)}%`;
        debouncedForest(); // update forest as you write
        debouncedGraph();
      });
      card.appendChild(notes);

      const weekId = isoWeekId(new Date());
      const weekly = weeklyScoreForCourse(course, weekId);
      const todayKey = etDateKey();
      const dayScore = (state.forest.weekly?.courses?.[course]?.days?.[todayKey] || 0);
      weeklyBadge.textContent = `Weekly sessions: ${weekly.sessions}/6 • Today: ${(dayScore * 100).toFixed(0)}%`;

    courseCardsEl.appendChild(card);
  });
  saveState();
  renderWeekSummary();
  setupCardToggles();
}

  function taskRow(task, listName) {
    const row = document.createElement("div");
    row.className = "task" + (task.done ? " done" : "");

    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.checked = !!task.done;
    cb.addEventListener("change", () => {
      task.done = cb.checked;
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest(); // dynamic response to task completion changes
    });

    const title = document.createElement("input");
    title.type = "text";
    title.className = "title";
    title.value = task.title || "";
    title.placeholder = "Task (bounded, concrete)";
    title.addEventListener("input", () => {
      task.title = title.value;
      saveState();
      debouncedForest();
    });

    title.addEventListener("blur", () => {
      if (!String(task.title || "").trim()) toast("Task title is empty (export will mark as untitled).");
    });

    const course = document.createElement("select");
    state.courses.forEach((c) => {
      const opt = document.createElement("option");
      opt.value = c;
      opt.textContent = c;
      course.appendChild(opt);
    });
    course.value = task.course || state.courses[0];
    course.addEventListener("change", () => {
      task.course = course.value;
      saveState();
      renderWeekSummary();
      debouncedForest();
    });

    const mode = document.createElement("select");
    const modes = Object.keys(state.modeChecks);
    ["(mode)", ...modes].forEach((m) => {
      const opt = document.createElement("option");
      opt.value = m;
      opt.textContent = m;
      mode.appendChild(opt);
    });
    mode.value = task.mode || "(mode)";
    mode.addEventListener("change", () => {
      task.mode = mode.value;
      saveState();
      debouncedForest();
    });

    const del = document.createElement("button");
    del.className = "del";
    del.textContent = "×";
    del.title = "Delete";
    del.addEventListener("click", () => {
      state[listName] = state[listName].filter((t) => t.id !== task.id);
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
    });

    row.appendChild(cb);
    row.appendChild(title);
    row.appendChild(course);
    row.appendChild(mode);
    row.appendChild(del);
    return row;
  }

  function renderTasks() {
    todayTasksEl.innerHTML = "";
    state.todayTasks.forEach((t) => todayTasksEl.appendChild(taskRow(t, "todayTasks")));

    weekendTasksEl.innerHTML = "";
    state.weekendTasks.forEach((t) => weekendTasksEl.appendChild(taskRow(t, "weekendTasks")));
  }

  // ---------- Card focus ----------
  let expandedCard = null;

  function setCardFocus(card, active) {
    const cards = Array.from(document.querySelectorAll(".card"));
    const containerCard = card?.parentElement?.closest(".card");
    if (active) {
      expandedCard = card;
      document.body.classList.add("card-focus");
      cards.forEach((c) => {
        const keepClear = c === card || c === containerCard;
        c.classList.toggle("expanded", c === card);
        c.classList.toggle("dimmed", !keepClear);
      });
      const btn = card.querySelector(".card-toggle");
      if (btn) btn.textContent = "Collapse";
    } else {
      expandedCard = null;
      document.body.classList.remove("card-focus");
      cards.forEach((c) => c.classList.remove("expanded", "dimmed"));
      cards.forEach((c) => {
        const btn = c.querySelector(".card-toggle");
        if (btn) btn.textContent = "Focus";
      });
    }
  }

  function setupCardToggles() {
    const cards = document.querySelectorAll(".card");
    cards.forEach((card) => {
      if (card.querySelector(".card-toggle")) return;
      const btn = document.createElement("button");
      btn.className = "card-toggle";
      btn.type = "button";
      btn.textContent = "Focus";
      btn.addEventListener("click", (e) => {
        e.preventDefault();
        const isActive = card.classList.contains("expanded");
        setCardFocus(card, !isActive);
      });
      card.appendChild(btn);
    });
  }

  // ---------- Concept graph ----------
  let graphState = null;
  let graphSpacing = 4.5;

  function collectWritingCorpus() {
    const parts = [];
    if (state.todayNotes) parts.push(state.todayNotes);
    state.courses.forEach((course) => {
      const c = state.courseNotes[course] || {};
      if (c.focus) parts.push(c.focus);
      if (c.budget) parts.push(c.budget);
      if (c.notes) parts.push(c.notes);
    });
    if (state.writingSchedule) parts.push(state.writingSchedule);
    if (state.writingThread) parts.push(state.writingThread);
    if (state.writingTargets) parts.push(state.writingTargets);
    if (state.writingNotes) parts.push(state.writingNotes);
    if (state.proseSchedule) parts.push(state.proseSchedule);
    if (state.proseProject) parts.push(state.proseProject);
    if (state.proseTargets) parts.push(state.proseTargets);
    if (state.proseNotes) parts.push(state.proseNotes);
    return normalizeText(parts.join(" "));
  }

  function computeConceptGraph() {
    const corpus = collectWritingCorpus();
    if (!corpus) return { nodes: [], edges: [] };
    const keywords = topNWords(corpus, 16).map(x => x.w);
    const nodes = keywords.map((w) => ({
      id: w,
      label: w,
      x: (Math.random() - 0.5) * graphSpacing,
      y: (Math.random() - 0.5) * graphSpacing,
      z: (Math.random() - 0.5) * graphSpacing,
      size: 2
    }));
    const edges = [];
    const sentences = splitSentences(corpus);
    const keywordSet = new Set(keywords);
    const edgeMap = new Map();

    sentences.forEach((sentence) => {
      const words = contentWords(sentence);
      const present = Array.from(new Set(words.filter((w) => keywordSet.has(w))));
      for (let i = 0; i < present.length; i++) {
        for (let j = i + 1; j < present.length; j++) {
          const key = [present[i], present[j]].sort().join("|");
          edgeMap.set(key, (edgeMap.get(key) || 0) + 1);
        }
      }
    });

    const degree = new Map();
    for (const [pair, weight] of edgeMap.entries()) {
      const [a, b] = pair.split("|");
      edges.push({ a, b, weight });
      degree.set(a, (degree.get(a) || 0) + weight);
      degree.set(b, (degree.get(b) || 0) + weight);
    }

    nodes.forEach((node) => {
      node.size = 2;
    });

    return { nodes, edges };
  }

  function projectPoint(node, rotX, rotY, zoom, w, h) {
    let { x, y, z } = node;
    const cosY = Math.cos(rotY);
    const sinY = Math.sin(rotY);
    const cosX = Math.cos(rotX);
    const sinX = Math.sin(rotX);

    const dx = x * cosY - z * sinY;
    const dz = x * sinY + z * cosY;
    const dy = y * cosX - dz * sinX;
    const dz2 = y * sinX + dz * cosX;

    const perspective = zoom / (zoom + dz2 + 2.2);
    return {
      x: w / 2 + dx * w * 0.25 * perspective,
      y: h / 2 + dy * h * 0.25 * perspective,
      scale: perspective
    };
  }

  function renderConceptGraph() {
    if (!conceptGraphCanvas) return;
    if (!graphState) {
      graphState = {
        data: computeConceptGraph(),
        rotX: -0.25,
        rotY: 0.25,
        zoom: 2.4,
        dragging: false,
        lastX: 0,
        lastY: 0
      };
      attachGraphHandlers();
      requestAnimationFrame(drawConceptGraph);
    } else {
      graphState.data = computeConceptGraph();
    }
  }

  function drawConceptGraphFrame() {
    if (!conceptGraphCanvas || !graphState) return;
    const { ctx, w, h } = initCanvasHiDPI(conceptGraphCanvas);
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = getCSSVar("--panel");
    ctx.fillRect(0, 0, w, h);

    const { nodes, edges } = graphState.data;
    if (!nodes.length) {
      ctx.fillStyle = "#8b8c9b";
      ctx.font = "12px " + getCSSVar("--sans");
      ctx.textAlign = "center";
      ctx.fillText("No writing data yet to generate concepts.", w / 2, h / 2);
      return;
    }

    const projections = new Map();
    nodes.forEach((node) => {
      projections.set(node.id, projectPoint(node, graphState.rotX, graphState.rotY, graphState.zoom, w, h));
    });

    ctx.strokeStyle = "rgba(58,61,94,0.25)";
    edges.forEach((edge) => {
      const a = projections.get(edge.a);
      const b = projections.get(edge.b);
      if (!a || !b) return;
      ctx.lineWidth = Math.max(0.6, edge.weight * 0.6);
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();
    });

    nodes.forEach((node) => {
      const p = projections.get(node.id);
      if (!p) return;
      const radius = node.size * p.scale;
      ctx.fillStyle = "#111111";
      ctx.beginPath();
      ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#111111";
      ctx.font = `${Math.max(9, 10 * p.scale)}px ${getCSSVar("--sans")}`;
      ctx.textAlign = "center";
      ctx.fillText(node.label, p.x, p.y - radius - 4);
    });
  }

  function attachGraphHandlers() {
    conceptGraphCanvas.addEventListener("mousedown", (e) => {
      graphState.dragging = true;
      graphState.lastX = e.clientX;
      graphState.lastY = e.clientY;
    });
    window.addEventListener("mouseup", () => {
      if (graphState) graphState.dragging = false;
    });
    window.addEventListener("mousemove", (e) => {
      if (!graphState?.dragging) return;
      const dx = e.clientX - graphState.lastX;
      const dy = e.clientY - graphState.lastY;
      graphState.rotY += dx * 0.005;
      graphState.rotX += dy * 0.005;
      graphState.lastX = e.clientX;
      graphState.lastY = e.clientY;
    });
    conceptGraphCanvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      graphState.zoom = clamp(graphState.zoom + e.deltaY * 0.004, 1.0, 10);
    }, { passive: false });
    btnRegenGraph?.addEventListener("click", () => {
      graphState.data = computeConceptGraph();
      toast("Regenerated concept graph");
    });
    graphSpacingEl?.addEventListener("input", () => {
      graphSpacing = Number(graphSpacingEl.value) || 1.6;
      graphState.data = computeConceptGraph();
    });
  }

  function drawConceptGraph() {
    if (!conceptGraphCanvas || !graphState) return;
    drawConceptGraphFrame();
    graphState.rotY += 0.0015;
    requestAnimationFrame(drawConceptGraph);
  }

  // ---------- Week summary ----------
  function renderWeekSummary() {
    const openToday = state.todayTasks.filter(t => !t.done).length;
    const openWeekend = state.weekendTasks.filter(t => !t.done).length;
    const doneToday = state.todayTasks.filter(t => t.done).length;
    const doneWeekend = state.weekendTasks.filter(t => t.done).length;

    const flagged = state.courses
      .map(c => ({ course: c, status: (state.courseNotes[c] || {}).status || "steady" }))
      .filter(x => x.status === "hot" || x.status === "danger");

    const keystone = state.keystoneToday || "";
    const keystoneOpen = state.todayTasks.filter(t => !t.done && t.course === keystone).length;

    const dailyTotal = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="daily").length || 1;
    const weeklyTotal = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="weekly").length || 1;

    const dailyChecked = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="daily" && state.modeChecks[k]).length;
    const weeklyChecked = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="weekly" && state.modeChecks[k]).length;

    const lines = [];
    lines.push(`Open tasks: <b>${openToday + openWeekend}</b> (Today ${openToday}, Weekend ${openWeekend})`);
    lines.push(`Completed tasks: ${doneToday + doneWeekend} (Today ${doneToday}, Weekend ${doneWeekend})`);
    lines.push(`Keystone: <b>${escapeHtml(keystone)}</b> — open today tasks in keystone: <b>${keystoneOpen}</b>`);
    lines.push(`Modes checked: daily ${dailyChecked}/${dailyTotal} • weekly ${weeklyChecked}/${weeklyTotal}`);

    if (flagged.length) {
      const list = flagged.map(x => `${escapeHtml(x.course)}: <code>${escapeHtml(x.status)}</code>`).join(" • ");
      lines.push(`Flagged courses: <b>${flagged.length}</b> — ${list}`);
    } else {
      lines.push(`Flagged courses: 0`);
    }

    weekSummaryEl.innerHTML = `<div style="display:grid;gap:6px;">${lines.map(x => `<div>${x}</div>`).join("")}</div>`;
    debouncedForest();
  }

  // ---------- Markdown generation ----------
  function mdCheckbox(label, checked) {
    return `- [${checked ? "x" : " "}] ${label}`;
  }

  function obsidianLink(name) {
    const safe = String(name || "").replaceAll("]","\\]");
    return `[[${safe}]]`;
  }

  function slugTag(word) {
    return String(word || "")
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/^-+|-+$/g, "");
  }

  const KEYWORD_SKIP = new Set([
    "make","made","making","made","need","needs","needed","want","wants","wanted",
    "good","better","best","bad","worse","worst","thing","things","stuff","like",
    "use","used","using","get","got","getting","should","could","would","might"
  ]);

  function titleCase(word) {
    const s = String(word || "");
    return s ? s[0].toUpperCase() + s.slice(1) : "";
  }

  function keyPhrases(text, n = 6) {
    const sentences = splitSentences(text);
    const freq = new Map();
    sentences.forEach((sentence) => {
      const words = contentWords(sentence);
      for (let i = 0; i < words.length; i++) {
        for (let size = 2; size <= 4; size++) {
          const slice = words.slice(i, i + size);
          if (slice.length < size) continue;
          const phrase = slice.join(" ");
          if (KEYWORD_SKIP.has(phrase)) continue;
          freq.set(phrase, (freq.get(phrase) || 0) + 1);
        }
      }
    });
    return Array.from(freq.entries())
      .sort((a, b) => b[1] - a[1])
      .map(([phrase]) => phrase)
      .slice(0, n);
  }

  function extractAcademicAnchors(text) {
    const anchors = [
      "1900s",
      "20th century",
      "continental philosophy",
      "structuralist mathematics",
      "theoretical biology",
      "set theory",
      "computation theory",
      "neurophysiology",
      "neuroecology",
      "systems theory",
      "phenomenology",
      "network epistemology",
      "cybernetics",
      "semiotics",
      "complex systems",
      "systems neuroscience",
      "information theory"
    ];
    const lower = String(text || "").toLowerCase();
    const hits = anchors.filter(a => lower.includes(a));
    return hits.map((t) => `#${slugTag(t)}`);
  }

  function tokenizeWords(text) {
    const norm = normalizeText(text);
    if (!norm) return [];
    return norm.split(/\s+/).filter(Boolean).filter(w => !STOP.has(w));
  }

  function extractSentences(text) {
    return splitSentences(text);
  }

  function sentenceScore(sentence, keywords) {
    const words = contentWords(sentence);
    if (!words.length) return 0;
    const lenScore = clamp(words.length / 20, 0, 1);
    let keyHits = 0;
    const lower = sentence.toLowerCase();
    keywords.forEach((k) => { if (lower.includes(k.toLowerCase())) keyHits += 1; });
    const keyScore = keywords.length ? clamp(keyHits / keywords.length, 0, 1) : 0;
    const structureScore = /[;:]/.test(sentence) ? 0.15 : 0;
    return lenScore + keyScore + structureScore;
  }

  function extractConceptSentences(text, n = 3) {
    const sentences = extractSentences(text);
    if (!sentences.length) return [];
    const keywords = topNWords(normalizeText(text), 8).map(x => x.w);
    const scored = sentences.map(s => ({ s, score: sentenceScore(s, keywords) }));
    return scored.sort((a, b) => b.score - a.score).map(x => x.s).slice(0, n);
  }

  function titleFromSentence(sentence) {
    const words = contentWords(sentence).slice(0, 6).map(titleCase);
    return words.length ? words.join(" ") : "Untitled Note";
  }

  function buildNoteAnalysis(noteText) {
    const concepts = extractConceptSentences(noteText, 3).map((s) => {
      const trimmed = s.trim();
      return trimmed.length > 160 ? `${trimmed.slice(0, 157)}…` : trimmed;
    });
    const title = concepts.length ? titleFromSentence(concepts[0]) : "Untitled Note";
    const anchors = [
      ...new Set([
        ...formatProperNounTags(noteText),
        ...extractAcademicAnchors(noteText)
      ])
    ];
    return { title, concepts, anchors };
  }

  function noteKeywords(text, n = 6) {
    return keyPhrases(text, n);
  }

  function titleCasePhrase(phrase) {
    return phrase.split(" ").map(titleCase).join(" ");
  }

  function noteTitleFromKeywords(keywords) {
    if (!keywords.length) return "Untitled Note";
    return keywords.slice(0, 2).map(titleCasePhrase).join(" · ");
  }

  function extractProperNouns(text, n = 6) {
    const raw = String(text || "");
    const matches = raw.match(/\b(?:[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\b/g) || [];
    const extras = raw.match(/\b\d{1,2}(?:st|nd|rd|th)\s+century\b/gi) || [];
    const seen = new Set();
    const out = [];
    [...matches, ...extras].forEach((m) => {
      const cleaned = m.trim();
      if (!cleaned || cleaned.length < 3) return;
      if (STOP.has(cleaned.toLowerCase())) return;
      const key = cleaned.toLowerCase();
      if (!seen.has(key)) {
        seen.add(key);
        out.push(cleaned);
      }
    });
    return out.slice(0, n);
  }

  function formatProperNounTags(text) {
    return extractProperNouns(text, 8)
      .map((name) => slugTag(name))
      .filter(Boolean)
      .map((tag) => `#${tag}`);
  }

  function percent(n) {
    return `${Math.round(n * 100)}%`;
  }

  function forestPngDataUrl(scale = 1, mime = "image/jpeg", quality = 0.92) {
    try {
      renderForest();
      const src = forestCanvas;
      if (!src) return "";
      const rect = src.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width));
      const h = Math.max(1, Math.floor(rect.height));
      const tmp = document.createElement("canvas");
      tmp.width = Math.floor(w * scale);
      tmp.height = Math.floor(h * scale);
      const tctx = tmp.getContext("2d");
      tctx.fillStyle = "#ffffff";
      tctx.fillRect(0, 0, tmp.width, tmp.height);
      tctx.drawImage(src, 0, 0, src.width, src.height, 0, 0, tmp.width, tmp.height);
      return mime === "image/png" ? tmp.toDataURL(mime) : tmp.toDataURL(mime, quality);
    } catch {
      return "";
    }
  }

  function conceptGraphPngDataUrl(scale = 1, mime = "image/jpeg", quality = 0.92) {
    try {
      if (!conceptGraphCanvas) return "";
      renderConceptGraph();
      if (graphState) drawConceptGraphFrame();
      const src = conceptGraphCanvas;
      const rect = src.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width));
      const h = Math.max(1, Math.floor(rect.height));
      const tmp = document.createElement("canvas");
      tmp.width = Math.floor(w * scale);
      tmp.height = Math.floor(h * scale);
      const tctx = tmp.getContext("2d");
      tctx.fillStyle = "#ffffff";
      tctx.fillRect(0, 0, tmp.width, tmp.height);
      tctx.drawImage(src, 0, 0, src.width, src.height, 0, 0, tmp.width, tmp.height);
      return mime === "image/png" ? tmp.toDataURL(mime) : tmp.toDataURL(mime, quality);
    } catch {
      return "";
    }
  }

  function wrapTextLines(ctx, text, maxWidth) {
    const words = String(text || "").split(/\s+/);
    const lines = [];
    let line = "";
    words.forEach((word) => {
      const next = line ? `${line} ${word}` : word;
      if (ctx.measureText(next).width > maxWidth && line) {
        lines.push(line);
        line = word;
      } else {
        line = next;
      }
    });
    if (line) lines.push(line);
    return lines;
  }

  function buildLegendGridRows(perCourse, courses, weekId) {
    return courses.map((course) => {
      const m = perCourse[course] || {};
      const notes = state.courseNotes?.[course]?.notes || "";
      const words = m.words || wordCount(notes);
      const recursion = Math.round((m.recursion || 0) * 100);
      const abstraction = Math.round((m.abstraction || 0) * 100);
      const cohesion = Math.round((m.cohesion || 0) * 100);
      const argument = Math.round((m.argument || 0) * 100);
      const diversityN = Math.round((m.diversity || 0) * 100);
      const keywordCount = courseKeywords(course).size;
      const phraseCount = keyPhrases(notes, 8).length;
      const conceptN = clamp((keywordCount / 12 + phraseCount / 6 + (m.cohesion || 0)) / 3, 0, 1);
      const stress = m.stress || 0;
      const tasks = m.tasks || 0;
      const weekly = weeklyScoreForCourse(course, weekId);
      const status = (state.courseNotes?.[course]?.status || "steady");
      return {
        title: `${course} (${status})`,
        lines: [
          `Words ${words} • Recursion ${recursion}% • Abstraction ${abstraction}%`,
          `Cohesion ${cohesion}% • Argument ${argument}% • Diversity ${diversityN}%`,
          `Concepts ${keywordCount} • Phrases ${phraseCount} • Linkage ${(conceptN * 100).toFixed(1)}%`,
          `Tasks ${tasks} • Stress ${(stress * 100).toFixed(1)}%`,
          `Weekly ${weekly.sessions}/6 • Score ${(weekly.score * 100).toFixed(1)}%`
        ]
      };
    });
  }

  function renderForestLegend(perCourse, courseList, weekId) {
    if (!forestLegendEl) return;
    const rows = buildLegendGridRows(perCourse, courseList, weekId);
    const html = rows.map((row) => {
      const lines = row.lines.map(line => `<div>${line}</div>`).join("");
      return `
        <div style="display:grid;gap:4px;padding:8px;border:1px solid var(--line);border-radius:10px;background:var(--panel2);color:var(--text);">
          <div><b>${escapeHtml(row.title)}</b></div>
          ${lines}
        </div>
      `;
    }).join("");

    forestLegendEl.innerHTML = `
      <div style="display:grid;gap:8px;">
        <div><b>Tree Analysis Legend</b> — per-course signals driving structure</div>
        <div style="display:grid;gap:10px;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));">
          ${html || "<div>No courses yet.</div>"}
        </div>
      </div>
    `;
  }

  function forestCardDataUrl(mime = "image/jpeg", quality = 0.92, scale = 1) {
    try {
      renderForest();
      const src = forestCanvas;
      if (!src) return "";
      const rect = src.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width));
      const h = Math.max(1, Math.floor(rect.height));
      const { perCourse, weekId } = computeForestMetrics();
      const rows = buildLegendGridRows(perCourse, state.courses || [], weekId);
      const cols = w > 960 ? 3 : (w > 640 ? 2 : 1);
      const cellW = Math.floor(w / cols);
      const lineH = 14;
      const cellPad = 10;
      const cellHeight = 6 * lineH + 20;
      const legendRows = Math.max(1, Math.ceil(rows.length / cols));
      const legendHeight = legendRows * cellHeight + cellPad;
      const totalH = h + legendHeight;

      const tmp = document.createElement("canvas");
      tmp.width = Math.max(1, Math.floor(w * scale));
      tmp.height = Math.max(1, Math.floor(totalH * scale));
      const ctx = tmp.getContext("2d");
      ctx.scale(scale, scale);
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, w, totalH);
      ctx.drawImage(src, 0, 0, src.width, src.height, 0, 0, w, h);

      ctx.fillStyle = "#111111";
      ctx.font = `12px ${getCSSVar("--sans")}`;
      const startY = h + cellPad;
      const maxTextWidth = (cellW - cellPad * 2) * scale;
      rows.forEach((row, idx) => {
        const col = idx % cols;
        const r = Math.floor(idx / cols);
        const x = col * cellW + cellPad;
        const y = startY + r * cellHeight;
        ctx.font = `12px ${getCSSVar("--sans")}`;
        ctx.fillText(row.title, x, y + 12);
        ctx.font = `11px ${getCSSVar("--sans")}`;
        row.lines.forEach((line, i) => {
          const lines = wrapTextLines(ctx, line, maxTextWidth);
          lines.forEach((l, li) => {
            const yy = y + 28 + (i * lineH) + (li * lineH);
            if (yy < y + cellHeight - 4) ctx.fillText(l, x, yy);
          });
        });
      });
      return mime === "image/png" ? tmp.toDataURL(mime) : tmp.toDataURL(mime, quality);
    } catch {
      return "";
    }
  }

  function formatDelta(delta) {
    const pct = Math.round(delta * 100);
    if (!pct) return "0%";
    return `${pct > 0 ? "+" : ""}${pct}%`;
  }

  function crc32(buf) {
    const table = crc32.table || (crc32.table = (() => {
      const t = new Uint32Array(256);
      for (let i = 0; i < 256; i++) {
        let c = i;
        for (let k = 0; k < 8; k++) {
          c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
        }
        t[i] = c >>> 0;
      }
      return t;
    })());
    let crc = 0xFFFFFFFF;
    for (let i = 0; i < buf.length; i++) {
      crc = table[(crc ^ buf[i]) & 0xFF] ^ (crc >>> 8);
    }
    return (crc ^ 0xFFFFFFFF) >>> 0;
  }

  function textToUint8(text) {
    return new TextEncoder().encode(text);
  }

  function dataUrlToUint8(dataUrl) {
    const [meta, data] = dataUrl.split(",");
    const isBase64 = meta.includes(";base64");
    if (!isBase64) return textToUint8(decodeURIComponent(data));
    const bin = atob(data);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
    return arr;
  }

  function zipFiles(files) {
    const records = [];
    let offset = 0;

    files.forEach((file) => {
      const nameBytes = textToUint8(file.name);
      const data = file.data;
      const crc = crc32(data);
      const localHeader = new Uint8Array(30 + nameBytes.length);
      const view = new DataView(localHeader.buffer);
      view.setUint32(0, 0x04034b50, true);
      view.setUint16(4, 20, true);
      view.setUint16(6, 0, true);
      view.setUint16(8, 0, true);
      view.setUint16(10, 0, true);
      view.setUint16(12, 0, true);
      view.setUint32(14, crc, true);
      view.setUint32(18, data.length, true);
      view.setUint32(22, data.length, true);
      view.setUint16(26, nameBytes.length, true);
      view.setUint16(28, 0, true);
      localHeader.set(nameBytes, 30);

      const centralHeader = new Uint8Array(46 + nameBytes.length);
      const cview = new DataView(centralHeader.buffer);
      cview.setUint32(0, 0x02014b50, true);
      cview.setUint16(4, 20, true);
      cview.setUint16(6, 20, true);
      cview.setUint16(8, 0, true);
      cview.setUint16(10, 0, true);
      cview.setUint16(12, 0, true);
      cview.setUint16(14, 0, true);
      cview.setUint32(16, crc, true);
      cview.setUint32(20, data.length, true);
      cview.setUint32(24, data.length, true);
      cview.setUint16(28, nameBytes.length, true);
      cview.setUint16(30, 0, true);
      cview.setUint16(32, 0, true);
      cview.setUint16(34, 0, true);
      cview.setUint16(36, 0, true);
      cview.setUint32(38, 0, true);
      cview.setUint32(42, offset, true);
      centralHeader.set(nameBytes, 46);

      records.push({ localHeader, data, centralHeader });
      offset += localHeader.length + data.length;
    });

    const centralSize = records.reduce((sum, r) => sum + r.centralHeader.length, 0);
    const end = new Uint8Array(22);
    const endView = new DataView(end.buffer);
    endView.setUint32(0, 0x06054b50, true);
    endView.setUint16(4, 0, true);
    endView.setUint16(6, 0, true);
    endView.setUint16(8, records.length, true);
    endView.setUint16(10, records.length, true);
    endView.setUint32(12, centralSize, true);
    endView.setUint32(16, offset, true);
    endView.setUint16(20, 0, true);

    const totalSize = offset + centralSize + end.length;
    const out = new Uint8Array(totalSize);
    let ptr = 0;
    records.forEach((r) => {
      out.set(r.localHeader, ptr);
      ptr += r.localHeader.length;
      out.set(r.data, ptr);
      ptr += r.data.length;
    });
    records.forEach((r) => {
      out.set(r.centralHeader, ptr);
      ptr += r.centralHeader.length;
    });
    out.set(end, ptr);
    return out;
  }

  function downloadBlob(filename, blob) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function downloadText(filename, text, mime = "text/plain") {
    const blob = new Blob([text], { type: mime });
    downloadBlob(filename, blob);
  }

  function downloadDataUrl(filename, dataUrl) {
    const a = document.createElement("a");
    a.href = dataUrl;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  async function writeFileToDir(dirHandle, name, blob) {
    const fileHandle = await dirHandle.getFileHandle(name, { create: true });
    const writable = await fileHandle.createWritable();
    await writable.write(blob);
    await writable.close();
  }

  async function saveArchiveToVault() {
    if (!window.isSecureContext || !window.showDirectoryPicker) {
      toast("Vault save requires Chrome/Edge on https or localhost");
      return;
    }
    try {
      const d = new Date();
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const dd = String(d.getDate()).padStart(2, "0");
      const folderName = `Dashboard_${yyyy}-${mm}-${dd}`;

      const md = state.mdCache || generateMarkdown({ forestFilename: "forest.jpg", graphFilename: "concept_graph.jpg" });
      setMdPreview(md);

      const forestUrl = forestCardDataUrl("image/jpeg", 0.92, state.forest.hiResPng ? 2 : 1);
      const graphUrl = conceptGraphPngDataUrl(1, "image/jpeg", 0.92);

      const dirHandle = await window.showDirectoryPicker({ id: "umo-vault", mode: "readwrite" });
      const dashDir = await dirHandle.getDirectoryHandle(folderName, { create: true });

      await writeFileToDir(dashDir, `Dashboard_${yyyy}-${mm}-${dd}.md`, new Blob([md], { type: "text/markdown" }));

      if (forestUrl) {
        const forestBytes = dataUrlToUint8(forestUrl);
        await writeFileToDir(dashDir, "forest.jpg", new Blob([forestBytes], { type: "image/jpeg" }));
      }
      if (graphUrl) {
        const graphBytes = dataUrlToUint8(graphUrl);
        await writeFileToDir(dashDir, "concept_graph.jpg", new Blob([graphBytes], { type: "image/jpeg" }));
      }

      toast("Saved to vault");
    } catch (err) {
      if (err && err.name === "AbortError") return;
      toast("Vault save failed");
    }
  }

  function forestToSVG(geom) {
    if (!geom) return "";
    const w = Math.max(1, Math.round(geom.width || 1));
    const h = Math.max(1, Math.round(geom.height || 1));
    const parts = [
      `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">`,
      `<rect width="100%" height="100%" fill="white"/>`
    ];

    geom.trees.forEach((tree) => {
      tree.paths.forEach((p) => {
        if (p.type === "circle") {
          const stroke = p.stroke || "#3a3d5e";
          const sw = p.sw || 1;
          const fill = p.fill || "none";
          const alpha = p.alpha ?? 1;
          parts.push(
            `<circle cx="${p.cx}" cy="${p.cy}" r="${p.r}" stroke="${stroke}" stroke-width="${sw}" fill="${fill}" opacity="${alpha}"/>`
          );
        } else if (p.d) {
          const stroke = p.stroke || "#3a3d5e";
          const sw = p.sw || 1;
          const alpha = p.alpha ?? 1;
          parts.push(
            `<path d="${p.d}" stroke="${stroke}" stroke-width="${sw}" fill="none" opacity="${alpha}"/>`
          );
        } else if (typeof p.x1 === "number") {
          const stroke = p.stroke || "#3a3d5e";
          const sw = p.sw || 1;
          const alpha = p.alpha ?? 1;
          parts.push(
            `<line x1="${p.x1}" y1="${p.y1}" x2="${p.x2}" y2="${p.y2}" stroke="${stroke}" stroke-width="${sw}" opacity="${alpha}"/>`
          );
        }
      });
    });

    parts.push("</svg>");
    return parts.join("");
  }

  function wordCount(text) {
    return String(text || "").trim().split(/\s+/).filter(Boolean).length;
  }

  function enforceWordCount(text, target) {
    let words = String(text || "").trim().split(/\s+/).filter(Boolean);
    const filler = [
      "The argument would benefit from clearer operational definitions and a sharper distinction between descriptive claims and interpretive stakes.",
      "Methodologically, a tighter articulation of evidence warrants would strengthen the transition from observation to inference.",
      "The conceptual framing aligns with literature on knowledge-building communities and warrants further triangulation with empirical traces.",
      "I encourage foregrounding how the analytic lens translates into concrete revision decisions for the next iteration."
    ];
    let i = 0;
    while (words.length < target) {
      words = words.concat(filler[i % filler.length].split(/\s+/));
      i += 1;
    }
    if (words.length > target) words = words.slice(0, target);
    return words.join(" ");
  }

  const RESPONDENT_CANON = [
    "Alain Badiou", "Joan Copjec", "Slavoj Zizek", "Alexander Galloway",
    "Sarah Pourciau", "Anil Bawa Cavvia", "Leif Weatherby", "Reza Negarestani",
    "Luciana Parisi", "Gualtieri Piccinini", "Katherine Hayles", "Mary Tiles",
    "Jose Ferreiros", "Denise Ferreira da Silva", "Fermin Fulda",
    "Stewart A. Newman", "Michael Heinrich", "Bruce Fink", "Bracha Ettinger"
  ];

  function bestSentenceFromText(text) {
    const sentences = extractConceptSentences(text, 1);
    return sentences[0] || "";
  }

  function summaryCorpusFromState() {
    const parts = [];
    if (state.todayNotes) parts.push(`Today notes: ${state.todayNotes}`);
    state.courses.forEach((course) => {
      const c = state.courseNotes?.[course] || {};
      if (c.focus) parts.push(`${course} focus: ${c.focus}`);
      if (c.notes) parts.push(`${course} notes: ${c.notes}`);
    });
    if (state.writingThread) parts.push(`GCAS thread: ${state.writingThread}`);
    if (state.writingNotes) parts.push(`GCAS notes: ${state.writingNotes}`);
    if (state.proseProject) parts.push(`Prose project: ${state.proseProject}`);
    if (state.proseNotes) parts.push(`Prose notes: ${state.proseNotes}`);
    return parts.join("\n");
  }

  async function callOpenAI(messages, temperature = 0.5) {
    const key = (state.llmKey || "").trim();
    if (!key) throw new Error("Missing OpenAI API key");
    const res = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${key}`
      },
      body: JSON.stringify({
        model: "gpt-4o-mini",
        temperature,
        messages
      })
    });
    if (!res.ok) {
      const err = await res.json().catch(() => ({}));
      throw new Error(err?.error?.message || `OpenAI error ${res.status}`);
    }
    const data = await res.json();
    return (data.choices?.[0]?.message?.content || "").trim();
  }
  function extractFirstUrl(text) {
    const match = String(text || "").match(/https?:\/\/[^\s\)\]]+/i);
    return match ? match[0].replace(/[\]\)\.,]+$/, "") : "";
  }

  function extractFirstDoi(text) {
    const match = String(text || "").match(/\b10\.\d{4,9}\/[\w.()\-;/:]+/i);
    return match ? match[0] : "";
  }

  const NOTE_GLOSSARY = [
    {
      keys: ["membrane", "potential"],
      concept: "Ion channels",
      gloss: "Ion channels are selective pore-forming proteins that regulate ion flow and thus shape membrane potential dynamics.",
      resource: "https://www.ncbi.nlm.nih.gov/books/"
    },
    {
      keys: ["action", "potential"],
      concept: "Voltage-gated channels",
      gloss: "Voltage-gated channels open or close in response to membrane voltage, enabling rapid spike initiation and propagation.",
      resource: "https://www.ncbi.nlm.nih.gov/books/"
    },
    {
      keys: ["synapse", "synaptic"],
      concept: "Neurotransmitter release",
      gloss: "Release couples presynaptic calcium influx to vesicle fusion, converting electrical signals into chemical transmission.",
      resource: "https://www.ncbi.nlm.nih.gov/books/"
    },
    {
      keys: ["model", "modeling", "system"],
      concept: "Model validation",
      gloss: "Validation tests whether a model reproduces key behaviors and predictions against data, not just fit quality.",
      resource: "https://www.ncbi.nlm.nih.gov/books/"
    },
    {
      keys: ["calculus", "integral", "derivative"],
      concept: "Fundamental Theorem of Calculus",
      gloss: "The theorem links derivatives and integrals, showing accumulation and rate of change are inverse processes.",
      resource: "https://www.khanacademy.org/"
    },
    {
      keys: ["probability", "random", "stochastic"],
      concept: "Random variables",
      gloss: "Random variables formalize uncertainty by mapping outcomes to numerical values with a defined distribution.",
      resource: "https://www.khanacademy.org/"
    }
  ];

  function glossForNote(noteText) {
    const lower = String(noteText || "").toLowerCase();
    let best = null;
    let bestScore = 0;
    NOTE_GLOSSARY.forEach((entry) => {
      const score = entry.keys.reduce((sum, k) => sum + (lower.includes(k) ? 1 : 0), 0);
      if (score > bestScore) {
        bestScore = score;
        best = entry;
      }
    });
    if (best) return best;
    const fallback = topNWords(lower, 1)[0]?.w || "related concept";
    return {
      concept: titleCase(fallback),
      gloss: "This adjacent concept provides framing that can clarify the mechanisms and assumptions in the note.",
      resource: "https://www.ncbi.nlm.nih.gov/books/"
    };
  }

  async function generateGptConferenceResponse() {
    const courses = state.courses || [];
    const entries = courses
      .map((course) => ({ course, notes: state.courseNotes?.[course]?.notes || "" }))
      .filter((c) => c.notes.trim());
    if (!entries.length) return "";
    const prompt = [
      "For each course note, return markdown with this exact structure:",
      "### <Course>",
      "- Summary:",
      "  - ...",
      "  - ...",
      "- Corrections: <1-2 sentences correcting misunderstandings if needed; otherwise write 'No correction needed.'>",
      "- Related concept: <2-4 sentence gloss directly tied to the note>",
      "- Recent article: <URL to a peer-reviewed article from the last ~5 years>",
      "- Resource: <URL to a good learning resource>",
      "Provide best-effort real URLs. If unsure, use a reputable journal homepage or DOI resolver search link.",
      "Be concise and helpful, not critical.",
      "Notes:",
      entries.map((c) => `### ${c.course}\n${c.notes}`).join("\n\n")
    ].join("\n");
    return callOpenAI([{ role: "user", content: prompt }], 0.35);
  }

  function buildConferenceResponse() {
    const courses = state.courses || [];
    const blocks = [];
    courses.forEach((course) => {
      const noteText = state.courseNotes?.[course]?.notes || "";
      if (!noteText.trim()) return;
      const bullets = extractConceptSentences(noteText, 3);
      const fallbackBullets = extractSentences(noteText).slice(0, 2);
      const summaryBullets = bullets.length ? bullets : (fallbackBullets.length ? fallbackBullets : ["—"]);
      const gloss = glossForNote(noteText);
      const resourceUrl = extractFirstUrl(noteText) || gloss.resource || "";
      const doi = extractFirstDoi(noteText);
      const articleUrl = doi ? `https://doi.org/${doi}` : "";
      blocks.push(`### ${course}`);
      blocks.push("- Summary:");
      summaryBullets.forEach((b) => blocks.push(`  - ${b}`));
      blocks.push("- Corrections: No correction needed.");
      blocks.push(`- Related concept: ${gloss.concept}. ${gloss.gloss}`);
      blocks.push(`- Recent article: ${articleUrl || "Add link"}`);
      blocks.push(`- Resource: ${resourceUrl || "Add link"}`);
      blocks.push("");
    });
    return blocks.length ? blocks.join("\n") : "";
  }

  async function analyzeNotesWithGpt(course, noteText) {
    if (!noteText || !noteText.trim()) return null;
    const prompt = [
      "Return strict JSON only (no markdown).",
      "Fields: title (string), key_concepts (array of 3 short sentences), academic_anchors (array of short tags).",
      "Title should be 3-8 words. Concepts should be short sentences.",
      `Course: ${course}`,
      `Notes: ${noteText}`
    ].join("\n");
    const raw = await callOpenAI([{ role: "user", content: prompt }], 0.3);
    try {
      const parsed = JSON.parse(raw);
      return {
        title: String(parsed.title || ""),
        concepts: Array.isArray(parsed.key_concepts) ? parsed.key_concepts.map(String) : [],
        anchors: Array.isArray(parsed.academic_anchors) ? parsed.academic_anchors.map(String) : []
      };
    } catch {
      return null;
    }
  }

  function generateMarkdown(opts = {}) {
    const d = new Date();
    const dateISO = d.toISOString().slice(0,10);
    const dateStr = d.toLocaleDateString(undefined, { weekday:"long", year:"numeric", month:"long", day:"numeric" });

    const { perCourse, mode, weekId } = computeForestMetrics();
    const courseList = state.courses || [];
    const doneToday = state.todayTasks.filter(t => t.done).length;
    const doneWeekend = state.weekendTasks.filter(t => t.done).length;
    const totalToday = state.todayTasks.length;
    const totalWeekend = state.weekendTasks.length;
    const totalTasks = totalToday + totalWeekend;
    const doneTotal = doneToday + doneWeekend;
    const completionRate = totalTasks ? (doneTotal / totalTasks) : 0;
    const writingText = normalizeText([state.writingSchedule, state.writingThread, state.writingTargets, state.writingNotes].filter(Boolean).join(" "));
    const proseText = normalizeText([state.proseSchedule, state.proseProject, state.proseTargets, state.proseNotes].filter(Boolean).join(" "));

    const perCourseMax = state.forest.perCourseMax || {};
    const averages = courseList.length
      ? courseList.reduce((acc, course) => {
        const cur = perCourse[course] || {};
        const max = perCourseMax[course] || {};
        acc.words += cur.words || 0;
        acc.recursion += cur.recursion || 0;
        acc.abstraction += cur.abstraction || 0;
        acc.cohesion += cur.cohesion || 0;
        acc.argument += cur.argument || 0;
        acc.diversity += cur.diversity || 0;
        acc.tasks += cur.tasks || 0;
        acc.maxWords += max.words || 0;
        acc.maxRecursion += max.recursion || 0;
        acc.maxAbstraction += max.abstraction || 0;
        acc.maxCohesion += max.cohesion || 0;
        acc.maxArgument += max.argument || 0;
        acc.maxDiversity += max.diversity || 0;
        acc.maxTasks += max.tasks || 0;
        return acc;
      }, { words: 0, recursion: 0, abstraction: 0, cohesion: 0, argument: 0, diversity: 0, tasks: 0, maxWords: 0, maxRecursion: 0, maxAbstraction: 0, maxCohesion: 0, maxArgument: 0, maxDiversity: 0, maxTasks: 0 })
      : { words: 0, recursion: 0, abstraction: 0, cohesion: 0, argument: 0, diversity: 0, tasks: 0, maxWords: 0, maxRecursion: 0, maxAbstraction: 0, maxCohesion: 0, maxArgument: 0, maxDiversity: 0, maxTasks: 0 };

    const avgWords = courseList.length ? averages.words / courseList.length : 0;
    const avgRecursion = courseList.length ? averages.recursion / courseList.length : 0;
    const avgAbstraction = courseList.length ? averages.abstraction / courseList.length : 0;
    const avgCohesion = courseList.length ? averages.cohesion / courseList.length : 0;
    const avgArgument = courseList.length ? averages.argument / courseList.length : 0;
    const avgDiversity = courseList.length ? averages.diversity / courseList.length : 0;

    const avgMaxWords = courseList.length ? averages.maxWords / courseList.length : 0;
    const avgMaxRecursion = courseList.length ? averages.maxRecursion / courseList.length : 0;
    const avgMaxAbstraction = courseList.length ? averages.maxAbstraction / courseList.length : 0;
    const avgMaxCohesion = courseList.length ? averages.maxCohesion / courseList.length : 0;
    const avgMaxArgument = courseList.length ? averages.maxArgument / courseList.length : 0;
    const avgMaxDiversity = courseList.length ? averages.maxDiversity / courseList.length : 0;

    const complexityTrend = avgMaxWords + avgMaxRecursion + avgMaxAbstraction + avgMaxCohesion + avgMaxArgument + avgMaxDiversity
      ? formatDelta(((avgWords + avgRecursion + avgAbstraction + avgCohesion + avgArgument + avgDiversity) - (avgMaxWords + avgMaxRecursion + avgMaxAbstraction + avgMaxCohesion + avgMaxArgument + avgMaxDiversity)) / ((avgMaxWords + avgMaxRecursion + avgMaxAbstraction + avgMaxCohesion + avgMaxArgument + avgMaxDiversity) || 1))
      : "0%";

    const distribution = courseList.length
      ? (() => {
        const high = courseList.filter(c => (perCourse[c]?.stress || 0) >= 0.66).length;
        const low = courseList.filter(c => (perCourse[c]?.stress || 0) <= 0.33).length;
        const mid = courseList.length - high - low;
        return `Stress distribution: ${high} hot / ${mid} warm / ${low} steady.`;
      })()
      : "Stress distribution: 0 hot / 0 warm / 0 steady.";

    const keywords = topNWords(writingText, 6).map(x => titleCase(x.w));
    const linkages = keyPhrases(writingText, 6).map(titleCasePhrase);
    const confResponse = state.llmConferenceResponse || buildConferenceResponse();

    const forestFilename = opts.forestFilename || "forest.jpg";
    const graphFilename = opts.graphFilename || "concept_graph.jpg";

    const header = [
      `# Semester Dashboard — ${dateStr}`,
      ``,
      `**Intent:** ${state.intent || "—"}`,
      `**Core window:** ${state.coreWindow || "—"} | **Weekend posture:** ${state.weekendPosture || "—"} | **Rebalance:** ${state.rebalanceDay || "—"}`
    ].join("\n");

    const modes = Object.keys(state.modeChecks).map(label => {
      return mdCheckbox(label + ` (${(state.modeScope?.[label] || "weekly").toUpperCase()})`, !!state.modeChecks[label]);
    }).join("\n");

    const courseNotes = state.courses.map(course => {
      const c = state.courseNotes[course] || {};
      const t = [];
      t.push(`- ${obsidianLink(course)} — status: **${c.status || "steady"}**`);
      if (c.focus) t.push(`  - Focus: ${c.focus}`);
      if (c.budget) t.push(`  - Block budget: ${c.budget}`);
      const noteText = c.notes || "";
      const gptAnalysis = noteText.trim() ? (state.llmNoteAnalyses?.[course] || null) : null;
      const analysis = gptAnalysis && (gptAnalysis.title || gptAnalysis.concepts)
        ? {
          title: gptAnalysis.title || "Untitled Note",
          concepts: Array.isArray(gptAnalysis.concepts) ? gptAnalysis.concepts : [],
          anchors: Array.isArray(gptAnalysis.anchors) ? gptAnalysis.anchors : []
        }
        : buildNoteAnalysis(noteText);
      const noteBullets = analysis.concepts.map(p => `    - ${p || "—"}`).join("\n");
      const noteAnchors = (analysis.anchors || []).map((a) => a.startsWith("#") ? a : `#${slugTag(a)}`);
      t.push(`  - Note title: ${analysis.title}`);
      t.push(`  - Key concepts:`);
      t.push(noteBullets || "    - —");
      t.push(`  - Academic anchors: ${noteAnchors.join(" ") || "—"}`);
      if (noteText) t.push(`  - Notes: ${noteText}`);
      return t.join("\n");
    }).join("\n");

    const taskList = (title, list) => {
      if (!list.length) return `### ${title}\n- (none)`;
      return `### ${title}\n` + list.map(t => {
        const status = t.done ? "x" : " ";
        const course = t.course ? ` (${t.course})` : "";
        const mode = (t.mode && t.mode !== "(mode)") ? ` [${t.mode}]` : "";
        const label = (t.title || "Untitled").replace(/\n/g, " ");
        return `- [${status}] ${label}${course}${mode}`;
      }).join("\n");
    };

    const writing = [
      `### GCAS Writing`,
      `- Schedule: ${state.writingSchedule || "—"}`,
      `- Thread: ${state.writingThread || "—"}`,
      `- Targets: ${state.writingTargets || "—"}`,
      `- Notes: ${state.writingNotes || "—"}`
    ].join("\n");

    const prose = [
      `### Prose Writing`,
      `- Schedule: ${state.proseSchedule || "—"}`,
      `- Project: ${state.proseProject || "—"}`,
      `- Targets: ${state.proseTargets || "—"}`,
      `- Notes: ${state.proseNotes || "—"}`
    ].join("\n");

    const forestFile = forestFilename;
    const graphFile = graphFilename;

    const out = [
      header,
      ``,
      `## Modes`,
      modes,
      ``,
      `## Courses`,
      courseNotes,
      ``,
      taskList("Today Tasks", state.todayTasks),
      ``,
      taskList("Weekend Deliverables", state.weekendTasks),
      ``,
      writing,
      ``,
      prose,
      ``,
      `## Note Briefs + Concept Gloss`,
      confResponse,
      ``,
      `## Forest Snapshot`,
      `- Week: ${weekId}`,
      `- Avg words: ${avgWords.toFixed(1)} (max ${avgMaxWords.toFixed(1)})`,
      `- Avg recursion: ${avgRecursion.toFixed(2)} (max ${avgMaxRecursion.toFixed(2)})`,
      `- Avg abstraction: ${avgAbstraction.toFixed(2)} (max ${avgMaxAbstraction.toFixed(2)})`,
      `- Avg cohesion: ${avgCohesion.toFixed(2)} (max ${avgMaxCohesion.toFixed(2)})`,
      `- Avg argument: ${avgArgument.toFixed(2)} (max ${avgMaxArgument.toFixed(2)})`,
      `- Avg diversity: ${avgDiversity.toFixed(2)} (max ${avgMaxDiversity.toFixed(2)})`,
      `- Completion rate: ${percent(completionRate)}`,
      `- Forest image: ${forestFile ? `![[${forestFile}]]` : "N/A"}`,
      `- Concept graph image: ${graphFile ? `![[${graphFile}]]` : "N/A"}`
    ].join("\n");

    return out;
  }

  function setMdPreview(md) {
    state.mdCache = md;
    saveState();
    mdPreviewEl.textContent = md;
  }

  // ---------- Basic NLP helpers ----------
  const STOP = new Set([
    "the","a","an","and","or","but","if","then","else","when","where","why","how","what","which",
    "of","to","in","on","for","from","by","with","about","as","at","into","over","after","before","between","through",
    "is","are","was","were","be","been","being","it","its","this","that","these","those","i","you","he","she","they",
    "we","me","my","our","your","their","them","his","her","not","no","yes","so","do","did","does","doing","can","will",
    "just","than","too","very","more","most","less","least","up","down","out","off","again","new","old","also","still"
  ]);

  function normalizeText(s){
    return String(s || "")
      .replace(/\n/g, " ")
      .replace(/[^a-zA-Z0-9\s]/g, " ")
      .replace(/\s+/g, " ")
      .trim()
      .toLowerCase();
  }

  function splitSentences(text){
    if (!text) return [];
    return text.split(/[\.\?\!\n]/).map(s => s.trim()).filter(Boolean);
  }

  function contentWords(text){
    return String(text || "")
      .toLowerCase()
      .replace(/[^a-z0-9\s]/g, " ")
      .split(/\s+/)
      .filter(Boolean)
      .filter(w => !STOP.has(w))
      .filter(w => w.length > 2);
  }

  function topNWords(text, n=8){
    const freq = new Map();
    contentWords(text).forEach(w => freq.set(w, (freq.get(w)||0)+1));
    return Array.from(freq.entries())
      .sort((a,b)=>b[1]-a[1])
      .slice(0,n)
      .map(([w,count])=>({w,count}));
  }

  // ---------- Forest visualization ----------
  let lastForestGeom = null;

  function getWeeklyStore(weekId) {
    state.forest.weekly = state.forest.weekly || { weekId: "", courses: {} };
    if (state.forest.weekly.weekId !== weekId) {
      state.forest.weekly = { weekId, courses: {} };
    }
    return state.forest.weekly;
  }

  const SUBORDINATE_MARKERS = ["that","which","because","if","since","although","while","unless","whereas","who","whom","whose"];
  const ABSTRACT_SUFFIXES = ["ness","ity","tion","sion","ment","ism","ence","hood","ship","tude"];
  const CONCEPT_VOCAB = new Set([
    "system","structure","function","process","mechanism","model","theory","framework","method",
    "concept","category","relation","dynamics","complexity","network","representation","inference",
    "causality","ontology","epistemology","phenomenology","semiotics","cybernetics","feedback",
    "homeostasis","entropy","information","computation","evidence","interpretation","hypothesis",
    "axiom","proof","lemma","constraint","parameter","variable","mapping","topology","category",
    "agent","ecology","evolution","plasticity","signal","encoding","decoding","gradient",
    "probability","distribution","derivative","integral","potential","channel","synapse","membrane"
  ]);
  const LOGICAL_CONNECTIVES = ["therefore","however","thus","hence","moreover","nevertheless","consequently","since","because","while","whereas","although"];
  const REFERENTIAL_PRONOUNS = ["this","that","these","those","such"];
  const MODAL_MARKERS = ["must","cannot","can't","should","ought","entails","implies","requires"];

  function countMatches(text, regex) {
    return (String(text || "").match(regex) || []).length;
  }

  function computeLinguisticMetrics(text) {
    const raw = String(text || "");
    const lower = raw.toLowerCase();
    const sentences = extractSentences(raw);
    const rawWords = lower.match(/\b[a-z][a-z'’\-]*\b/g) || [];
    const words = rawWords.length;

    const clauseSeparators = countMatches(raw, /[,;:—-]/g);
    const totalClauses = Math.max(1, sentences.length + clauseSeparators);
    const avgClauseLen = words ? (words / totalClauses) : 0;

    const subordinateCount = countMatches(lower, new RegExp(`\b(${SUBORDINATE_MARKERS.join("|")})\b`, "g"));
    const punctCount = countMatches(raw, /[,;:—-]/g);

    const clauseLenN = clamp((avgClauseLen - 6) / 16, 0, 1);
    const subordinateN = clamp(subordinateCount / Math.max(1, sentences.length * 1.5), 0, 1);
    const punctN = clamp(punctCount / Math.max(1, sentences.length * 2), 0, 1);
    const recursionScore = clamp(0.45 * clauseLenN + 0.35 * subordinateN + 0.2 * punctN, 0, 1);

    const suffixCount = rawWords.filter(w => ABSTRACT_SUFFIXES.some(s => w.endsWith(s))).length;
    const conceptCount = rawWords.filter(w => CONCEPT_VOCAB.has(w)).length;
    const abstractionScore = clamp(((suffixCount / Math.max(1, words)) * 6) + ((conceptCount / Math.max(1, words)) * 4), 0, 1);

    const pronounCount = rawWords.filter(w => REFERENTIAL_PRONOUNS.includes(w)).length;
    const connectiveCount = rawWords.filter(w => LOGICAL_CONNECTIVES.includes(w)).length;
    const cohesionScore = clamp(((pronounCount / Math.max(1, words)) * 6) + ((connectiveCount / Math.max(1, words)) * 8), 0, 1);

    const modalCount = rawWords.filter(w => MODAL_MARKERS.includes(w)).length;
    const conditionalCount = sentences.filter(s => /\bif\b/i.test(s) && /\bthen\b/i.test(s)).length;
    const argumentScore = clamp(((modalCount / Math.max(1, words)) * 8) + (conditionalCount / Math.max(1, sentences.length)) * 2, 0, 1);

    const freq = new Map();
    rawWords.forEach(w => freq.set(w, (freq.get(w) || 0) + 1));
    const unique = freq.size;
    const typeToken = words ? unique / words : 0;
    const hapax = Array.from(freq.values()).filter(v => v === 1).length;
    const rareLong = rawWords.filter(w => w.length >= 9).length;
    const diversityScore = clamp(0.5 * typeToken + 0.3 * (hapax / Math.max(1, words)) + 0.2 * (rareLong / Math.max(1, words)), 0, 1);

    return {
      words,
      recursionScore,
      abstractionScore,
      cohesionScore,
      argumentScore,
      diversityScore
    };
  }

  function noteSessionScore(notes) {
    const metrics = computeLinguisticMetrics(notes);
    const words = metrics.words || 0;
    if (words < 10) return 0;

    const lengthTarget = 180;
    const lengthFactor = clamp(Math.sqrt(words) / Math.sqrt(lengthTarget), 0, 1);
    const complexity = clamp(
      0.25 * metrics.recursionScore +
      0.2 * metrics.abstractionScore +
      0.2 * metrics.cohesionScore +
      0.2 * metrics.argumentScore +
      0.15 * metrics.diversityScore,
      0,
      1
    );
    return clamp(0.35 * lengthFactor + 0.65 * complexity, 0, 1);
  }

  function updateWeeklySession(course, notes) {
    const weekId = isoWeekId(new Date());
    const store = getWeeklyStore(weekId);
    const dayKey = etDateKey();
    store.courses[course] = store.courses[course] || { days: {}, total: 0 };
    const score = noteSessionScore(notes);
    if (score <= 0) return;
    const prev = store.courses[course].days[dayKey] || 0;
    if (score > prev) {
      store.courses[course].days[dayKey] = score;
      const total = Object.values(store.courses[course].days).reduce((sum, v) => sum + v, 0);
      store.courses[course].total = total;
      saveState();
    }
  }

  function weeklyScoreForCourse(course, weekId) {
    const store = getWeeklyStore(weekId);
    const c = store.courses[course];
    if (!c) return { score: 0, sessions: 0 };
    const scores = Object.values(c.days || {});
    const sessions = scores.filter(s => s >= 0.2).length;
    const score = clamp(scores.reduce((sum, s) => sum + s, 0) / 5, 0, 1);
    return { score, sessions };
  }

  function computeForestMetrics() {
    const courses = state.courses || [];
    const perCourse = {};
    let total = 0;

    courses.forEach((course) => {
      const notes = (state.courseNotes[course]?.notes || "");
      const metrics = computeLinguisticMetrics(notes);
      const words = metrics.words || 0;
      const tasks = state.todayTasks.filter(t => t.course === course && t.done).length
        + state.weekendTasks.filter(t => t.course === course && t.done).length;

      const status = state.courseNotes[course]?.status || "steady";
      const stress = status === "danger" ? 1 : status === "hot" ? 0.75 : status === "watch" ? 0.45 : 0.2;

      perCourse[course] = {
        words,
        recursion: metrics.recursionScore,
        abstraction: metrics.abstractionScore,
        cohesion: metrics.cohesionScore,
        argument: metrics.argumentScore,
        diversity: metrics.diversityScore,
        tasks,
        stress
      };
      total += words + tasks * 20;
    });

    const dailyTotal = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="daily").length || 1;
    const weeklyTotal = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="weekly").length || 1;
    const dailyChecked = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="daily" && state.modeChecks[k]).length;
    const weeklyChecked = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="weekly" && state.modeChecks[k]).length;

    const mode = {
      dailyRatio: dailyChecked / dailyTotal,
      weeklyRatio: weeklyChecked / weeklyTotal,
      dailyChecked,
      weeklyChecked
    };

    const weekId = isoWeekId(new Date());
    return { perCourse, total, mode, weekId };
  }

  function hashString(str) {
    let h = 2166136261;
    for (let i = 0; i < str.length; i++) {
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h >>> 0;
  }

  function makeRng(seed) {
    let s = hashString(String(seed)) || 1;
    return () => {
      s = (s * 1664525 + 1013904223) >>> 0;
      return (s >>> 8) / 16777216;
    };
  }

  function seededRandom(key, salt = "") {
    const h = hashString(`${key}::${salt}`);
    return (h % 100000) / 100000;
  }

  function courseKeywords(course) {
    const raw = state.courseNotes?.[course]?.notes || "";
    const norm = normalizeText(raw);
    const words = topNWords(norm, 8).map(x => x.w);
    const phrases = keyPhrases(raw, 6).map(p => p.replace(/[^a-z0-9\s]/gi, "").trim()).filter(Boolean);
    return new Set([...words, ...phrases].filter(Boolean));
  }

  function courseComplexity(metrics) {
    const words = clamp((metrics.words || 0) / 220, 0, 1);
    const recursion = clamp(metrics.recursion || 0, 0, 1);
    const abstraction = clamp(metrics.abstraction || 0, 0, 1);
    const cohesion = clamp(metrics.cohesion || 0, 0, 1);
    const argument = clamp(metrics.argument || 0, 0, 1);
    const diversity = clamp(metrics.diversity || 0, 0, 1);
    const tasks = clamp((metrics.tasks || 0) / 6, 0, 1);
    return clamp(0.25 * words + 0.2 * recursion + 0.15 * abstraction + 0.15 * cohesion + 0.15 * argument + 0.1 * diversity + 0.1 * tasks, 0, 1);
  }

  function computeMyceliumGraph() {
    return { nodes: [], edges: [], weeklyByCourse: {}, conceptByCourse: {} };
  }

  function buildFullGhost(w, h, padL, padR, padT, baseY, perCourse, mode, weekId) {
    const courses = state.courses || [];
    const simulateMax = !!state.forest.simulateMax;
    const count = Math.max(1, courses.length);
    const spacing = w / (count + 1);
    const maxSource = simulateMax ? (state.forest.perCourseMax || {}) : perCourse;
    const currentMax = {
      words: Math.max(1, ...Object.values(maxSource).map(m => m.words || 0)),
      recursion: Math.max(0.1, ...Object.values(maxSource).map(m => m.recursion || 0)),
      abstraction: Math.max(0.1, ...Object.values(maxSource).map(m => m.abstraction || 0)),
      cohesion: Math.max(0.1, ...Object.values(maxSource).map(m => m.cohesion || 0)),
      argument: Math.max(0.1, ...Object.values(maxSource).map(m => m.argument || 0)),
      diversity: Math.max(0.1, ...Object.values(maxSource).map(m => m.diversity || 0)),
      tasks: Math.max(1, ...Object.values(maxSource).map(m => m.tasks || 0))
    };
    const dummyCanvas = document.createElement("canvas");
    dummyCanvas.width = w;
    dummyCanvas.height = h;
    const ctx = dummyCanvas.getContext("2d");
    const ghostGeom = { width: w, height: h, trees: [] };
    courses.forEach((course, idx) => {
      const x0 = spacing * (idx + 1);
      const metrics = perCourse[course] || { words: 0, recursion: 0, abstraction: 0, cohesion: 0, argument: 0, diversity: 0, tasks: 0, stress: 0 };
      const maxMetrics = (state.forest.perCourseMax || {})[course] || {};
      const useMetrics = simulateMax ? {
        words: maxMetrics.words ?? metrics.words,
        recursion: maxMetrics.recursion ?? metrics.recursion,
        abstraction: maxMetrics.abstraction ?? metrics.abstraction,
        cohesion: maxMetrics.cohesion ?? metrics.cohesion,
        argument: maxMetrics.argument ?? metrics.argument,
        diversity: maxMetrics.diversity ?? metrics.diversity,
        tasks: maxMetrics.tasks ?? metrics.tasks
      } : metrics;
      const wordsN = clamp((useMetrics.words || 0) / currentMax.words, 0, 1);
      const recursionN = clamp((useMetrics.recursion || 0) / currentMax.recursion, 0, 1);
      const abstractionN = clamp((useMetrics.abstraction || 0) / currentMax.abstraction, 0, 1);
      const cohesionN = clamp((useMetrics.cohesion || 0) / currentMax.cohesion, 0, 1);
      const argumentN = clamp((useMetrics.argument || 0) / currentMax.argument, 0, 1);
      const diversityN = clamp((useMetrics.diversity || 0) / currentMax.diversity, 0, 1);
      const tasksN = clamp((useMetrics.tasks || 0) / currentMax.tasks, 0, 1);
      const stress = clamp(metrics.stress || 0, 0, 1);
      const noteText = state.courseNotes?.[course]?.notes || "";
      const keywordCount = courseKeywords(course).size;
      const phraseCount = keyPhrases(noteText, 8).length;
      const conceptN = clamp((keywordCount / 12 + phraseCount / 6 + cohesionN) / 3, 0, 1);
      const weeklyScoreN = 1;
      const taskScoreN = 1;
      const isGcas = /gcas/i.test(course);
      const heightScale = isGcas ? 1 : 0.7;
      const canopyBoost = isGcas ? 1 : 1.2;
      const maxHeight = Math.max(40, baseY - padT - 70);
      const height = Math.min(
        maxHeight * 0.6 * heightScale,
        (12 + 40 * weeklyScoreN + 16 * (wordsN * weeklyScoreN) + 10 * (tasksN * weeklyScoreN)) * heightScale
      );
      const complexityN = clamp((wordsN + recursionN + abstractionN + cohesionN + argumentN + diversityN + weeklyScoreN) / 7, 0, 1);
      const branchiness = clamp(0.25 + 0.9 * recursionN * weeklyScoreN + 0.2 * tasksN * weeklyScoreN, 0.2, 1.8);
      const leaves = clamp(0.4 + 1.6 * taskScoreN * canopyBoost + 0.8 * abstractionN * weeklyScoreN + 0.4 * mode.weeklyRatio * weeklyScoreN, 0.3, 3.2);
      const crownSpread = clamp(1.0 + 1.4 * taskScoreN * canopyBoost + 0.7 * abstractionN, 1.0, 4.0);
      const dayLight = clamp(0.45 + 0.7 * mode.dailyRatio, 0.3, 1.1);

      drawTree(ctx, {
        x0,
        baseY,
        height,
        trunkW: 0.4 + 1.4 * argumentN,
        branchiness,
        leaves,
        crownSpread,
        stress,
        padT,
        padL,
        padR,
        w,
        dayLight,
        recursionN,
        abstractionN,
        cohesionN,
        argumentN,
        diversityN,
        tasksN,
        wordsN,
        conceptN,
        weeklyScoreN,
        weekendScoreN: taskScoreN,
        noteText,
        recursion: metrics.recursion || 0,
        abstraction: metrics.abstraction || 0,
        cohesion: metrics.cohesion || 0,
        argument: metrics.argument || 0,
        diversity: metrics.diversity || 0,
        complexityN,
        seedKey: `${weekId}|${course}|full`,
        course,
        mode
      }, ghostGeom);
    });
    return ghostGeom;
  }

  function applyOrderedDither(ctx, w, h, strength = 0.05) {
    if (!ctx || !w || !h || strength <= 0) return;
    const bayer8 = [
      [0, 48, 12, 60, 3, 51, 15, 63],
      [32, 16, 44, 28, 35, 19, 47, 31],
      [8, 56, 4, 52, 11, 59, 7, 55],
      [40, 24, 36, 20, 43, 27, 39, 23],
      [2, 50, 14, 62, 1, 49, 13, 61],
      [34, 18, 46, 30, 33, 17, 45, 29],
      [10, 58, 6, 54, 9, 57, 5, 53],
      [42, 26, 38, 22, 41, 25, 37, 21]
    ];
    const img = ctx.getImageData(0, 0, Math.floor(w), Math.floor(h));
    const data = img.data;
    const amp = 255 * strength;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const idx = (y * w + x) * 4;
        const threshold = (bayer8[y % 8][x % 8] / 64 - 0.5) * amp;
        data[idx] = clamp(data[idx] + threshold, 0, 255);
        data[idx + 1] = clamp(data[idx + 1] + threshold, 0, 255);
        data[idx + 2] = clamp(data[idx + 2] + threshold, 0, 255);
      }
    }
    ctx.putImageData(img, 0, 0);
  }

  function renderForest() {
    if (!forestCanvas) return;
    const { ctx, w, h } = initCanvasHiDPI(forestCanvas);
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = getCSSVar("--panel");
    ctx.fillRect(0, 0, w, h);

    const { perCourse, mode, weekId } = computeForestMetrics();
    const simulateMax = !!state.forest.simulateMax;
    const courses = state.courses || [];
    if (!courses.length) {
      ctx.fillStyle = "#8b8c9b";
      ctx.font = "12px " + getCSSVar("--sans");
      ctx.textAlign = "center";
      ctx.fillText("No courses yet to render forest.", w / 2, h / 2);
      lastForestGeom = { width: w, height: h, trees: [] };
      renderForestLegend(perCourse, courses, weekId);
      return;
    }

    if (state.forest.weekId !== weekId) {
      state.forest.weekId = weekId;
      saveState();
    }

    state.forest.perCourseMax = state.forest.perCourseMax || {};
    let maxChanged = false;
    courses.forEach((course) => {
      const cur = perCourse[course] || {};
      const max = state.forest.perCourseMax[course] || {};
      const updateMax = (key, val) => {
        const v = val || 0;
        if ((max[key] || 0) < v) {
          max[key] = v;
          maxChanged = true;
        }
      };
      updateMax("words", cur.words);
      updateMax("recursion", cur.recursion);
      updateMax("abstraction", cur.abstraction);
      updateMax("cohesion", cur.cohesion);
      updateMax("argument", cur.argument);
      updateMax("diversity", cur.diversity);
      updateMax("tasks", cur.tasks);
      state.forest.perCourseMax[course] = max;
    });
    if (maxChanged) saveState();

    const maxSource = simulateMax ? (state.forest.perCourseMax || {}) : perCourse;
    const currentMax = {
      words: Math.max(1, ...Object.values(maxSource).map(m => m.words || 0)),
      recursion: Math.max(0.1, ...Object.values(maxSource).map(m => m.recursion || 0)),
      abstraction: Math.max(0.1, ...Object.values(maxSource).map(m => m.abstraction || 0)),
      cohesion: Math.max(0.1, ...Object.values(maxSource).map(m => m.cohesion || 0)),
      argument: Math.max(0.1, ...Object.values(maxSource).map(m => m.argument || 0)),
      diversity: Math.max(0.1, ...Object.values(maxSource).map(m => m.diversity || 0)),
      tasks: Math.max(1, ...Object.values(maxSource).map(m => m.tasks || 0))
    };

    const padL = 50;
    const padR = 50;
    const padT = 30;
    const baseY = clamp(h * 0.62, padT + 140, h - 140);
    const spacing = w / (courses.length + 1);
    const geom = { width: w, height: h, trees: [] };

    if (state.forest.showFullGhost) {
      const fullGhost = buildFullGhost(w, h, padL, padR, padT, baseY, perCourse, mode, weekId);
      drawGhostForest(ctx, w, h, padL, padR, baseY, fullGhost);
    } else {
      drawGhostForest(ctx, w, h, padL, padR, baseY);
    }

    courses.forEach((course, idx) => {
      const x0 = spacing * (idx + 1);
      const metrics = perCourse[course] || { words: 0, recursion: 0, abstraction: 0, cohesion: 0, argument: 0, diversity: 0, tasks: 0, stress: 0 };
      const maxMetrics = (state.forest.perCourseMax || {})[course] || {};
      const useMetrics = simulateMax ? {
        words: maxMetrics.words ?? metrics.words,
        recursion: maxMetrics.recursion ?? metrics.recursion,
        abstraction: maxMetrics.abstraction ?? metrics.abstraction,
        cohesion: maxMetrics.cohesion ?? metrics.cohesion,
        argument: maxMetrics.argument ?? metrics.argument,
        diversity: maxMetrics.diversity ?? metrics.diversity,
        tasks: maxMetrics.tasks ?? metrics.tasks
      } : metrics;
      const wordsN = clamp((useMetrics.words || 0) / currentMax.words, 0, 1);
      const recursionN = clamp((useMetrics.recursion || 0) / currentMax.recursion, 0, 1);
      const abstractionN = clamp((useMetrics.abstraction || 0) / currentMax.abstraction, 0, 1);
      const cohesionN = clamp((useMetrics.cohesion || 0) / currentMax.cohesion, 0, 1);
      const argumentN = clamp((useMetrics.argument || 0) / currentMax.argument, 0, 1);
      const diversityN = clamp((useMetrics.diversity || 0) / currentMax.diversity, 0, 1);
      const tasksN = clamp((useMetrics.tasks || 0) / currentMax.tasks, 0, 1);
      const stress = clamp(metrics.stress || 0, 0, 1);

      const noteText = state.courseNotes?.[course]?.notes || "";
      const keywordCount = courseKeywords(course).size;
      const phraseCount = keyPhrases(noteText, 8).length;
      const conceptN = clamp((keywordCount / 12 + phraseCount / 6 + cohesionN) / 3, 0, 1);

      const weeklyScore = weeklyScoreForCourse(course, weekId);
      const weeklyScoreN = simulateMax ? 1 : clamp(weeklyScore.score || 0, 0, 1);
      const weekendDone = state.weekendTasks.filter(t => t.course === course && t.done).length;
      const weekendTotal = Math.max(1, state.weekendTasks.filter(t => t.course === course).length);
      const weekendScoreN = simulateMax ? 1 : clamp(weekendDone / weekendTotal, 0, 1);

      const isGcas = /gcas/i.test(course);
      const heightScale = isGcas ? 1 : 0.7;
      const canopyBoost = isGcas ? 1 : 1.2;
      const maxHeight = Math.max(40, baseY - padT - 70);
      const height = Math.min(
        maxHeight * 0.6 * heightScale,
        (12 + 40 * weeklyScoreN + 16 * (wordsN * weeklyScoreN) + 10 * (tasksN * weeklyScoreN)) * heightScale
      );
      const complexityN = clamp((wordsN + recursionN + abstractionN + cohesionN + argumentN + diversityN + weeklyScoreN) / 7, 0, 1);
      const branchiness = clamp(0.25 + 0.9 * recursionN * weeklyScoreN + 0.2 * tasksN * weeklyScoreN, 0.2, 1.8);
      const leaves = weekendScoreN > 0
        ? clamp(0.4 + 1.6 * weekendScoreN * canopyBoost + 0.8 * abstractionN * weeklyScoreN + 0.3 * mode.weeklyRatio * weeklyScoreN, 0.3, 3.2)
        : 0;
      const crownSpread = clamp(1.0 + 1.4 * weekendScoreN * canopyBoost + 0.7 * abstractionN, 1.0, 4.0);
      const dayLight = clamp(0.45 + 0.7 * mode.dailyRatio, 0.3, 1.1);

      drawTree(ctx, {
        x0,
        baseY,
        height,
        trunkW: 0.4 + 1.4 * argumentN,
        branchiness,
        leaves,
        crownSpread,
        stress,
        padT,
        padL,
        padR,
        w,
        dayLight,
        recursionN,
        abstractionN,
        cohesionN,
        argumentN,
        diversityN,
        tasksN,
        wordsN,
        conceptN,
        weeklyScoreN,
        weekendScoreN,
        noteText,
        recursion: metrics.recursion || 0,
        abstraction: metrics.abstraction || 0,
        cohesion: metrics.cohesion || 0,
        argument: metrics.argument || 0,
        diversity: metrics.diversity || 0,
        complexityN,
        seedKey: `${weekId}|${course}`,
        course,
        mode
      }, geom);
    });

    applyOrderedDither(ctx, w, h, 0.035);
    lastForestGeom = geom;
    renderForestLegend(perCourse, courses, weekId);
  }

  function drawGhostForest(ctx, w, h, padL, padR, baseY, overrideGhost = null) {
    if (!overrideGhost && isMondayAfterNoonET()) return;
    const current = isoWeekId(new Date());
    const prev = prevIsoWeekId(current);
    const ghost = overrideGhost || loadGhostSnapshot(prev);
    if (!ghost) return;

    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.strokeStyle = "#000000";
    ctx.lineWidth = 0.5;

    ghost.trees.forEach((tree) => {
      tree.paths.forEach((p) => {
        if (p.type === "circle") {
          ctx.beginPath();
          ctx.arc(p.cx, p.cy, p.r, 0, Math.PI * 2);
          ctx.stroke();
        } else if (p.d) {
          ctx.beginPath();
          const path = new Path2D(p.d);
          ctx.stroke(path);
        } else {
          ctx.beginPath();
          ctx.strokeStyle = "#000000";
          ctx.lineWidth = 0.5;
          ctx.moveTo(p.x1, p.y1);
          ctx.lineTo(p.x2, p.y2);
          ctx.stroke();
        }
      });
    });

    ctx.restore();
  }

  function saveGhostSnapshot(weekId) {
    if (!lastForestGeom) return;
    try {
      const data = {
        weekId,
        trees: lastForestGeom.trees.map(tree => ({
          course: tree.course,
          paths: tree.paths.map(p => ({ ...p }))
        }))
      };
      localStorage.setItem(`${STORAGE_KEY}_ghost_${weekId}`, JSON.stringify(data));
    } catch {}
  }

  function loadGhostSnapshot(weekId) {
    try {
      const raw = localStorage.getItem(`${STORAGE_KEY}_ghost_${weekId}`);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch {
      return null;
    }
  }

  function clearGhostSnapshot(weekId) {
    try { localStorage.removeItem(`${STORAGE_KEY}_ghost_${weekId}`); } catch {}
  }

  function buildLSystemParams(features, height, maxRise, signature) {
    const recursionN = features.recursionScore || 0;
    const abstractionN = features.abstractionScore || 0;
    const cohesionN = features.cohesionScore || 0;
    const argumentN = features.argumentScore || 0;
    const diversityN = features.diversityScore || 0;
    const tasksN = features.tasksN || 0;
    const stressN = features.stressN || 0;
    const wordsN = features.wordsN || 0;

    const baseHash = hashString(String(signature || ""));
    const isGcas = /gcas/i.test(signature || "");
    const sigJitter = ((baseHash % 23) - 11) * 0.7 + (isGcas ? -1.2 : 0);

    const angleBase = 24 + 22 * (1 - cohesionN) + 10 * (1 - recursionN) + 8 * diversityN + 10 * stressN;
    const angleDeg = clamp(angleBase + sigJitter, 14, 65);
    const iterations = Math.max(3, Math.round(6 + recursionN * 10 + abstractionN * 4 - stressN * 4));

    let step = clamp(7 + height * (0.04 + 0.03 * argumentN), 5, 16);
    step += 6 * tasksN;
    const stepScale = 0.85 + ((baseHash % 31) / 100) + (isGcas ? 0.06 : 0);
    step *= stepScale;
    if (maxRise) {
      const stepCap = Math.max(3, maxRise / (iterations * 2.6));
      step = Math.min(step, stepCap);
    }

    const grammarSet = [
      { "F": "F[+F]F[-F]F" },
      { "F": "FF[-F]F[+F]" },
      { "F": "F[+F]F" },
      { "F": "F[-F]F[+F]FF" },
      { "F": "F[+F]F[+F]F" },
      { "F": "F[-F]FF" },
      { "F": "FF[+F]F[-F]" },
      { "F": "F[+F][-F]F" },
      { "F": "F[+F]F[+F][-F]F" },
      { "F": "F[+F]FF[-F]F" },
      { "F": "F[+F]F[+F]FF[-F]F" },
      { "F": "FF[+F][-F]FF" }
    ];
    const key = [
      Math.round(recursionN * 10),
      Math.round(abstractionN * 10),
      Math.round(cohesionN * 10),
      Math.round(argumentN * 10),
      Math.round(diversityN * 10),
      Math.round(tasksN * 10),
      Math.round(wordsN * 10),
      baseHash
    ].join("|");
    const branchBias = Math.round(abstractionN * (grammarSet.length - 1));
    const rules = grammarSet[(hashString(key) + branchBias) % grammarSet.length];

    return {
      axiom: "F",
      rules,
      iterations,
      angle: angleDeg * (Math.PI / 180),
      step,
      sigHash: baseHash,
      seedKey: String(signature || ""),
      features: {
        recursionN,
        abstractionN,
        cohesionN,
        argumentN,
        diversityN,
        tasksN,
        wordsN
      },
      jitter: (0.08 + 0.35 * diversityN) * (1 - 0.6 * cohesionN),
      gravityBias: 0.2 + 0.6 * argumentN,
      taperRate: 0.06 + 0.08 * recursionN,
      winding: {
        baseTurnRate: 0.04, // persistent gentle turn to avoid straight runs
        curvatureFloor: 0.08, // minimum heading variance across window
        curvatureWindow: 16, // window length for variance check
        noiseAmp: 0.25, // correlated bend amplitude
        noiseScale: 14, // correlation length in px
        headingInertiaK: 0.16, // smoothing factor for heading updates
        boundaryBand: 50, // soft edge repulsion band
        boundaryGain: 0.9, // edge steering strength
        occCellSize: 12, // occupancy grid cell size
        occGain: 0.6, // avoidance turn gain
        occDecay: 0.08, // per-step local decay
        maxInternodePx: 22, // cap for internode length
        recursionBudgetBase: 2600, // total segment budget per tree
        clusterProbability: 0.14, // probability to start a cluster burst
        clusterBurstSteps: 28, // steps for burst mode
        minBranchEverySteps: 4, // enforce node event cadence
        symmetryZoneMin: 40, // min steps per symmetry/exploration zone
        symmetryZoneMax: 120, // max steps per symmetry/exploration zone
        symmetryStrengthBase: 0.7, // baseline symmetry strength
        symmetryAnglesDeg: [12, 18, 24, 33], // discrete symmetry angles
        defectCountMin: 2, // symmetry breakpoints per zone
        defectCountMax: 5, // symmetry breakpoints per zone
        defectWindow: 8, // steps a defect lasts
        exploratoryNoiseBoost: 1.35, // higher noise in exploratory zones
        symmetryNoiseScale: 0.8, // tighter noise in symmetric zones
        clusterStepScale: 0.82, // shorter steps during cluster bursts
        twigEveryMin: 2, // twigging cadence min
        twigEveryMax: 4, // twigging cadence max
        twigLenScale: 0.55 // twig length scale
      }
    };
  }

  function expandLSystem(axiom, rules, iterations, maxLen = 9000, maxRun = 2200) {
    let str = axiom;
    for (let i = 0; i < iterations; i++) {
      let next = "";
      for (let j = 0; j < str.length; j++) {
        const ch = str[j];
        next += rules[ch] || ch;
        if (next.length > maxLen) break;
      }
      str = next.slice(0, maxLen);
    }
    return str.slice(0, maxRun);
  }

      function noise1D(seedKey, branchId, s, scale) {
    const t = s / Math.max(1, scale);
    const i0 = Math.floor(t);
    const f = t - i0;
    const h0 = hashString(`${seedKey}|${branchId}|${i0}`);
    const h1 = hashString(`${seedKey}|${branchId}|${i0 + 1}`);
    const v0 = (h0 % 2000) / 1000 - 1;
    const v1 = (h1 % 2000) / 1000 - 1;
    const smooth = f * f * (3 - 2 * f);
    return v0 + (v1 - v0) * smooth;
  }

  function angleDelta(a, b) {
    return Math.atan2(Math.sin(b - a), Math.cos(b - a));
  }

  function lerpAngle(a, b, k) {
    return a + angleDelta(a, b) * k;
  }

  function makeOccGrid(w, h, cellSize) {
    const cols = Math.max(1, Math.ceil(w / cellSize));
    const rows = Math.max(1, Math.ceil(h / cellSize));
    return { cols, rows, cellSize, data: new Float32Array(cols * rows) };
  }

  function occIndex(grid, x, y) {
    const cx = Math.max(0, Math.min(grid.cols - 1, Math.floor(x / grid.cellSize)));
    const cy = Math.max(0, Math.min(grid.rows - 1, Math.floor(y / grid.cellSize)));
    return cy * grid.cols + cx;
  }

  function occSample(grid, x, y) {
    return grid.data[occIndex(grid, x, y)] || 0;
  }

  function occStamp(grid, x, y, decay) {
    const idx = occIndex(grid, x, y);
    const prev = grid.data[idx] || 0;
    grid.data[idx] = prev * (1 - decay) + 1;
  }

  function boundaryTurn(dir, x, y, w, h, band, gain) {
    if (band <= 0) return 0;
    const left = x;
    const right = w - x;
    const top = y;
    const bottom = h - y;
    const minDist = Math.min(left, right, top, bottom);
    if (minDist >= band) return 0;
    const t = (band - minDist) / band;
    const strength = t * t;
    const toward = Math.atan2(h / 2 - y, w / 2 - x);
    return angleDelta(dir, toward) * strength * gain;
  }

  function drawLSystem(ctx, start, angle, spec, leafPoints, ink, geom, minY, runScale = 1, collision = null) {
    const stack = [];
    let x = start.x;
    let y = start.y;
    let dir = angle;
    let s = 0;
    const step = spec.step;
    const maxRun = Math.max(200, Math.round(5000 * clamp(runScale, 0.1, 1)));
    const seq = expandLSystem(spec.axiom, spec.rules, spec.iterations, 20000, maxRun);

    const wind = spec.winding || {
      baseTurnRate: 0.04,
      curvatureFloor: 0.08,
      curvatureWindow: 16,
      noiseAmp: 0.25,
      noiseScale: 14,
      headingInertiaK: 0.16,
      boundaryBand: 50,
      boundaryGain: 0.9,
      occCellSize: 12,
      occGain: 0.6,
      occDecay: 0.08,
      maxInternodePx: 22,
      recursionBudgetBase: 2600,
      clusterProbability: 0.14,
      clusterBurstSteps: 28,
      minBranchEverySteps: 4,
      symmetryZoneMin: 40,
      symmetryZoneMax: 120,
      symmetryStrengthBase: 0.7,
      symmetryAnglesDeg: [12, 18, 24, 33],
      defectCountMin: 2,
      defectCountMax: 5,
      defectWindow: 8,
      exploratoryNoiseBoost: 1.35,
      symmetryNoiseScale: 0.8,
      clusterStepScale: 0.82,
      twigEveryMin: 2,
      twigEveryMax: 4,
      twigLenScale: 0.55
    };

    const features = spec.features || {
      recursionN: 0.5,
      abstractionN: 0.5,
      cohesionN: 0.5,
      argumentN: 0.5,
      diversityN: 0.5
    };

    // Metric mapping (transparent):
    // - expositionScore uses cohesion + abstraction + recursion -> symmetric zones, higher symmetryStrength, denser clustering
    // - transitionScore uses diversity + (1 - cohesion) + argument -> exploratory zones, higher noiseAmp/noiseScale
    const expoBase = clamp(0.45 * features.cohesionN + 0.35 * features.abstractionN + 0.2 * features.recursionN, 0, 1);
    const transBase = clamp(0.5 * features.diversityN + 0.3 * (1 - features.cohesionN) + 0.2 * features.argumentN, 0, 1);

    const canvasW = ctx.canvas.width / (window.devicePixelRatio || 1);
    const canvasH = ctx.canvas.height / (window.devicePixelRatio || 1);
    const occ = makeOccGrid(canvasW, canvasH, wind.occCellSize);
    const symAngles = (wind.symmetryAnglesDeg || [12, 18, 24, 33]).map(d => d * (Math.PI / 180));

    let branchId = 0;
    let branchSign = seededRandom(spec.seedKey || "", `branch:${branchId}`) < 0.5 ? -1 : 1;
    let branchSerial = 0;
    let stepsSinceNode = 0;
    const headingHistory = [];

    let segmentBudget = Math.max(200, Math.round((wind.recursionBudgetBase || 2600) * (0.7 + 0.6 * runScale) * (0.55 + 0.45 * features.recursionN)));

    const zone = {
      type: "exploratory",
      index: 0,
      step: 0,
      remaining: 0,
      symmetryAxisAngle: -Math.PI / 2,
      symmetryStrength: wind.symmetryStrengthBase || 0.7,
      breakpoints: [],
      defectSteps: 0,
      defectType: 0,
      defectSide: 1,
      twigEvery: 3
    };

    function startZone(type, dirNow, sNow) {
      zone.type = type;
      zone.index += 1;
      zone.step = 0;
      const lenSeed = seededRandom(spec.seedKey || "", `zone-len:${zone.index}`);
      const zmin = wind.symmetryZoneMin || 40;
      const zmax = wind.symmetryZoneMax || 120;
      zone.remaining = Math.round(zmin + (zmax - zmin) * lenSeed);
      const axisSeed = seededRandom(spec.seedKey || "", `zone-axis:${zone.index}`) - 0.5;
      zone.symmetryAxisAngle = lerpAngle(dirNow, -Math.PI / 2 + axisSeed * 0.8, 0.5);
      const strengthJitter = seededRandom(spec.seedKey || "", `zone-strength:${zone.index}`) * 0.2 - 0.1;
      zone.symmetryStrength = clamp((wind.symmetryStrengthBase || 0.7) + strengthJitter, 0.35, 0.95);
      const twigSeed = seededRandom(spec.seedKey || "", `zone-twig:${zone.index}`);
      const twigMin = wind.twigEveryMin || 2;
      const twigMax = wind.twigEveryMax || 4;
      zone.twigEvery = Math.round(twigMin + (twigMax - twigMin) * twigSeed);

      const breaks = [];
      const bcountSeed = seededRandom(spec.seedKey || "", `zone-breaks:${zone.index}`);
      const bmin = wind.defectCountMin || 2;
      const bmax = wind.defectCountMax || 5;
      const bcount = Math.round(bmin + (bmax - bmin) * bcountSeed);
      for (let i = 0; i < bcount; i++) {
        const t = seededRandom(spec.seedKey || "", `zone-break:${zone.index}:${i}`);
        breaks.push(Math.max(4, Math.floor(t * zone.remaining)));
      }
      zone.breakpoints = breaks;
      zone.defectSteps = 0;
      zone.defectType = 0;
      zone.defectSide = seededRandom(spec.seedKey || "", `zone-side:${zone.index}`) < 0.5 ? -1 : 1;
    }

    function updateZone(dirNow, sNow) {
      const expoNoise = 0.2 * noise1D(spec.seedKey || "", "expo", sNow, 90);
      const transNoise = 0.2 * noise1D(spec.seedKey || "", "trans", sNow, 80);
      const expositionScore = clamp(expoBase + expoNoise, 0, 1);
      const transitionScore = clamp(transBase + transNoise, 0, 1);
      const prefer = transitionScore > 0.62 ? "exploratory" : (expositionScore > 0.62 ? "symmetric" : zone.type);

      if (zone.remaining <= 0 || (prefer !== zone.type && (transitionScore > 0.75 || expositionScore > 0.75))) {
        startZone(prefer, dirNow, sNow);
      }

      zone.step += 1;
      zone.remaining -= 1;
      if (zone.breakpoints.includes(zone.step)) {
        zone.defectSteps = wind.defectWindow || 8;
        zone.defectType = Math.floor(seededRandom(spec.seedKey || "", `zone-defect:${zone.index}:${zone.step}`) * 4);
      }
      if (zone.defectSteps > 0) zone.defectSteps -= 1;

      return { expositionScore, transitionScore };
    }

    function drawBranchlet(originX, originY, baseDir, lenScale, stepCount, localBranchId, zoneType, defectSide = 0) {
      let bx = originX;
      let by = originY;
      let bdir = baseDir;
      let bs = 0;
      const localNoiseScale = (zoneType === "symmetric" ? wind.noiseScale * (wind.symmetryNoiseScale || 0.8) : wind.noiseScale) * (wind.exploratoryNoiseBoost || 1.1);
      const localNoiseAmp = wind.noiseAmp * (zoneType === "symmetric" ? 0.6 : 1.1) * (defectSide ? 1.35 : 1);
      const branchStep = Math.min(step * lenScale, wind.maxInternodePx || step);

      for (let j = 0; j < stepCount && segmentBudget > 0; j++) {
        const baseTurn = branchSign * wind.baseTurnRate * 1.2;
        const noiseTurn = noise1D(spec.seedKey || "", localBranchId, bs, localNoiseScale) * localNoiseAmp;
        const boundary = boundaryTurn(bdir, bx, by, canvasW, canvasH, wind.boundaryBand, wind.boundaryGain);
        const desired = bdir + baseTurn + noiseTurn + boundary;
        bdir = lerpAngle(bdir, desired, wind.headingInertiaK);

        const nx = bx + Math.cos(bdir) * branchStep;
        const ny = by + Math.sin(bdir) * branchStep;

        ctx.beginPath();
        ctx.moveTo(bx, by);
        ctx.lineTo(nx, ny);
        ctx.stroke();
        if (geom) {
          geom.paths.push({ x1: bx, y1: by, x2: nx, y2: ny, stroke: ink, sw: ctx.lineWidth * 0.75, alpha: 1 });
        }
        occStamp(occ, nx, ny, wind.occDecay);
        bx = nx; by = ny; bs += branchStep;
        segmentBudget -= 1;
      }
    }

    const cluster = { remaining: 0, queue: [], sideBias: 0 };

    function startCluster(sideBias = 0) {
      const burstSeed = seededRandom(spec.seedKey || "", `cluster:${branchId}:${Math.floor(s)}`);
      const burstSteps = Math.max(8, Math.round((wind.clusterBurstSteps || 28) * (0.7 + burstSeed * 0.6)));
      cluster.remaining = burstSteps;
      cluster.queue = [];
      cluster.sideBias = sideBias;
      const count = 2 + Math.floor(seededRandom(spec.seedKey || "", `cluster-count:${branchId}:${Math.floor(s)}`) * 3);
      for (let i = 0; i < count; i++) {
        const delay = 1 + Math.floor(seededRandom(spec.seedKey || "", `cluster-delay:${branchId}:${i}:${Math.floor(s)}`) * 3);
        cluster.queue.push({ delay, count: 1 + Math.floor(seededRandom(spec.seedKey || "", `cluster-child:${branchId}:${i}`) * 2) });
      }
    }

    function spawnClusterQueue(dirNow) {
      cluster.queue.forEach((item) => { item.delay -= 1; });
      const ready = cluster.queue.filter(item => item.delay <= 0);
      cluster.queue = cluster.queue.filter(item => item.delay > 0);
      ready.forEach((item) => {
        for (let i = 0; i < item.count; i++) {
          const side = cluster.sideBias || (seededRandom(spec.seedKey || "", `cluster-side:${branchId}:${i}:${Math.floor(s)}`) < 0.5 ? -1 : 1);
          const alpha = symAngles[Math.floor(seededRandom(spec.seedKey || "", `cluster-angle:${branchId}:${i}:${Math.floor(s)}`) * symAngles.length)] || (18 * Math.PI / 180);
          const branchDir = dirNow + side * alpha;
          branchSerial += 1;
          drawBranchlet(x, y, branchDir, 0.85, 6 + Math.floor(seededRandom(spec.seedKey || "", `cluster-len:${branchSerial}`) * 6), branchSerial, zone.type, side);
        }
        stepsSinceNode = 0;
      });
    }

    function spawnBranchEvent(dirNow, force, sideBias = 0) {
      if (segmentBudget <= 0) return;
      const axis = lerpAngle(dirNow, zone.symmetryAxisAngle, zone.symmetryStrength);
      const alpha = symAngles[Math.floor(seededRandom(spec.seedKey || "", `alpha:${branchId}:${Math.floor(s)}`) * symAngles.length)] || (18 * Math.PI / 180);
      const pair = zone.type === "symmetric";
      const defectActive = zone.defectSteps > 0 && zone.type === "symmetric";
      const suppressSide = defectActive && zone.defectType === 0 ? zone.defectSide : 0;
      const noiseDefect = defectActive && zone.defectType === 1 ? zone.defectSide : 0;
      const clusterDefect = defectActive && zone.defectType === 2 ? zone.defectSide : 0;

      if (pair) {
        const leftDir = axis - alpha;
        const rightDir = axis + alpha;
        if (suppressSide >= 0) {
          branchSerial += 1;
          drawBranchlet(x, y, rightDir, 0.75, 6, branchSerial, zone.type, noiseDefect > 0 ? 1 : 0);
        }
        if (suppressSide <= 0) {
          branchSerial += 1;
          drawBranchlet(x, y, leftDir, 0.75, 6, branchSerial, zone.type, noiseDefect < 0 ? -1 : 0);
        }
        if (clusterDefect != 0) startCluster(clusterDefect);
      } else {
        const side = sideBias || (seededRandom(spec.seedKey || "", `branch-side:${branchId}:${Math.floor(s)}`) < 0.5 ? -1 : 1);
        branchSerial += 1;
        drawBranchlet(x, y, dirNow + side * alpha, 0.8, 6, branchSerial, zone.type, side);
      }
      stepsSinceNode = 0;
    }

    startZone(zone.type, dir, s);

    ctx.save();
    ctx.strokeStyle = ink;
    ctx.globalAlpha = 1;

    for (let i = 0; i < seq.length && segmentBudget > 0; i++) {
      const ch = seq[i];
      if (ch === "F") {
        const depth = stack.length;
        const taper = Math.max(0.2, 0.9 - depth * (spec.taperRate || 0.06));
        ctx.lineWidth = 0.6 * taper * (zone.type === "symmetric" ? 1.05 : 0.9);

        const stepCap = wind.maxInternodePx || step;
        const subSteps = Math.max(1, Math.ceil(step / stepCap));
        const baseSubStep = step / subSteps;

        for (let sub = 0; sub < subSteps && segmentBudget > 0; sub++) {
          const scores = updateZone(dir, s);
          const expoBoost = 0.6 + 0.8 * scores.expositionScore;
          const transBoost = 0.6 + 0.8 * scores.transitionScore;

          const localNoiseAmp = wind.noiseAmp * (zone.type === "symmetric" ? 0.6 : (wind.exploratoryNoiseBoost || 1.35)) * (cluster.remaining > 0 ? 1.2 : 1);
          const localNoiseScale = wind.noiseScale * (zone.type === "symmetric" ? (wind.symmetryNoiseScale || 0.8) : 1.15) * (cluster.remaining > 0 ? 1.15 : 1);
          const baseTurn = branchSign * wind.baseTurnRate * (zone.type === "symmetric" ? 0.9 : 1.1);
          const noiseTurn = noise1D(spec.seedKey || "", branchId, s, localNoiseScale) * localNoiseAmp;
          const gravityTurn = angleDelta(dir, -Math.PI / 2) * (spec.gravityBias || 0.3) * 0.03;

          const boundary = boundaryTurn(dir, x, y, canvasW, canvasH, wind.boundaryBand, wind.boundaryGain);

          const forward = occSample(occ, x + Math.cos(dir) * baseSubStep * 1.5, y + Math.sin(dir) * baseSubStep * 1.5);
          const left = occSample(occ, x + Math.cos(dir - Math.PI / 4) * baseSubStep * 1.2, y + Math.sin(dir - Math.PI / 4) * baseSubStep * 1.2);
          const right = occSample(occ, x + Math.cos(dir + Math.PI / 4) * baseSubStep * 1.2, y + Math.sin(dir + Math.PI / 4) * baseSubStep * 1.2);
          const densityBias = (right - left) * -wind.occGain * (1 + forward * 0.2);

          headingHistory.push(dir);
          if (headingHistory.length > wind.curvatureWindow) headingHistory.shift();
          const cosAvg = headingHistory.reduce((sum, a) => sum + Math.cos(a), 0) / headingHistory.length;
          const sinAvg = headingHistory.reduce((sum, a) => sum + Math.sin(a), 0) / headingHistory.length;
          const variance = 1 - Math.sqrt(cosAvg * cosAvg + sinAvg * sinAvg);
          const curvatureTurn = variance < wind.curvatureFloor
            ? branchSign * (wind.curvatureFloor - variance) * 0.6
            : 0;

          // base + noise + boundary + avoidance + curvature floor (smooth winding)
          const desiredDir = dir + baseTurn + noiseTurn + gravityTurn + boundary + densityBias + curvatureTurn;
          dir = lerpAngle(dir, desiredDir, wind.headingInertiaK);

          if (typeof minY === "number" && y < minY + 12) {
            dir += 0.25;
          }

          const clusterScale = cluster.remaining > 0 ? (wind.clusterStepScale || 0.82) : 1;
          const subStep = Math.min(baseSubStep * clusterScale, wind.maxInternodePx || baseSubStep);

          let nx = x + Math.cos(dir) * subStep;
          let ny = y + Math.sin(dir) * subStep;

          // soften boundary if we would exit: shorten step + stronger boundary turn
          if (nx < 0 || nx > canvasW || ny < 0 || ny > canvasH) {
            const extraTurn = boundaryTurn(dir, x, y, canvasW, canvasH, wind.boundaryBand, wind.boundaryGain * 1.6);
            dir = lerpAngle(dir, dir + extraTurn, wind.headingInertiaK);
            nx = x + Math.cos(dir) * subStep * 0.6;
            ny = y + Math.sin(dir) * subStep * 0.6;
          }

          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(nx, ny);
          ctx.stroke();
          if (geom) {
            geom.paths.push({
              x1: x, y1: y, x2: nx, y2: ny,
              stroke: ink,
              sw: ctx.lineWidth,
              alpha: 1
            });
          }

          occStamp(occ, nx, ny, wind.occDecay);
          x = nx; y = ny; s += subStep; stepsSinceNode += 1; segmentBudget -= 1;

          if (cluster.remaining > 0) {
            cluster.remaining -= 1;
            spawnClusterQueue(dir);
          }

          const nodeInterval = Math.max(wind.minBranchEverySteps || 4, Math.round((wind.maxInternodePx || 20) / Math.max(1, subStep)));
          const clusterChance = wind.clusterProbability * (zone.type === "symmetric" ? expoBoost : transBoost);
          const clusterSeed = seededRandom(spec.seedKey || "", `cluster-trigger:${branchId}:${Math.floor(s)}`);
          if (cluster.remaining <= 0 && clusterSeed < clusterChance && segmentBudget > 60) {
            startCluster();
          }

          if (zone.type === "symmetric" && stepsSinceNode % zone.twigEvery == 0) {
            spawnBranchEvent(dir, false, 0);
          }

          if (stepsSinceNode >= nodeInterval) {
            spawnBranchEvent(dir, true, 0);
          } else {
            const spawnSeed = seededRandom(spec.seedKey || "", `spawn:${branchId}:${Math.floor(s)}`);
            const spawnProb = zone.type === "symmetric" ? 0.06 * expoBoost : 0.08 * transBoost;
            if (spawnSeed < spawnProb && segmentBudget > 40) {
              spawnBranchEvent(dir, false, 0);
            }
          }
        }
      } else if (ch === "+") {
        dir += spec.angle;
      } else if (ch === "-") {
        dir -= spec.angle;
      } else if (ch === "[") {
        stack.push({ x, y, dir, branchId, branchSign, stepsSinceNode });
        branchId += 1;
        branchSign = seededRandom(spec.seedKey || "", `branch:${branchId}`) < 0.5 ? -1 : 1;
        stepsSinceNode = 0;
        headingHistory.length = 0;
      } else if (ch === "]") {
        if (stack.length) {
          const s0 = stack.pop();
          x = s0.x; y = s0.y; dir = s0.dir;
          branchId = s0.branchId;
          branchSign = s0.branchSign;
          stepsSinceNode = s0.stepsSinceNode || 0;
          leafPoints.push({ x, y });
          headingHistory.length = 0;
        }
      }
    }
    leafPoints.push({ x, y });
    ctx.restore();
  }

  function drawTree(ctx, opts, forestGeom) {
    const {
      x0, baseY, height, trunkW, branchiness, leaves, crownSpread,
      stress, padT, padL, padR, w, dayLight, recursionN, abstractionN, cohesionN, argumentN, diversityN, tasksN, wordsN, conceptN, weeklyScoreN, weekendScoreN, noteText, recursion, abstraction, cohesion, argument, diversity,
      complexityN,
      seedKey, course, mode
    } = opts;

    const ink = "#000000";
    const geom = {
      course,
      paths: []
    };
    forestGeom.trees.push(geom);

    // No per-tree background fill to keep forest minimal

      // Draw trunk
      ctx.save();
      ctx.strokeStyle = ink;
      ctx.globalAlpha = 1;
      ctx.lineWidth = trunkW;
      ctx.setLineDash([]);

      const leafPoints = [];
      const maxRise = Math.min(220, Math.max(60, baseY - padT - 20));
      const lsys = buildLSystemParams({
        recursionScore: recursionN,
        abstractionScore: abstractionN,
        cohesionScore: cohesionN,
        argumentScore: argumentN,
        diversityScore: diversityN,
        tasksN,
        stressN: stress,
        wordsN
      }, height, maxRise, `${seedKey}|${course}`);
      const growthN = Math.max(0.06, clamp(weeklyScoreN, 0, 1));
      const runScale = 0.1 + 0.9 * growthN;
      const fitScale = clamp((baseY - padT - 20) / Math.max(1, height * 1.6), 0.4, 1);
      const stepJitter = 0.9 + (seededRandom(seedKey, "step") - 0.5) * 0.18;
      lsys.step *= runScale * fitScale * stepJitter;
      const heightScale = clamp(1 - (lsys.iterations - 2) * 0.12, 0.55, 1);
      const trunkLen = height * dayLight * heightScale;
      const angleBias = 0.28 + 0.45 * (1 - weeklyScoreN);
      const angleSign = (tasksN - 0.5) >= 0 ? 1 : -1;
      const angleJitter = (seededRandom(seedKey, "angle") - 0.5) * 0.4;
      const trunkAngle = -Math.PI / 2 + angleSign * angleBias + angleJitter;
      const trunkJitter = (seededRandom(seedKey, "trunk") - 0.5) * 12;
      const trunkBaseX = clamp(x0 + trunkJitter, padL + 4, w - padR - 4);
      const trunkTop = {
        x: trunkBaseX + Math.cos(trunkAngle) * trunkLen,
        y: baseY + Math.sin(trunkAngle) * trunkLen
      };
      trunkTop.y = Math.max(trunkTop.y, padT + 8);

      ctx.beginPath();
      ctx.moveTo(trunkBaseX, baseY);
      ctx.lineTo(trunkTop.x, trunkTop.y);
      ctx.stroke();
      ctx.restore();

      geom.paths.push({
        d: `M ${trunkBaseX} ${baseY} L ${trunkTop.x} ${trunkTop.y}`,
        stroke: ink,
        sw: trunkW,
        alpha: (0.33 + 0.22*stress),
        fill: "none"
      });
      const lean = clamp((tasksN - 0.5) * 0.12 + (stress - 0.5) * 0.08 + (argumentN - 0.5) * 0.05 + angleJitter * 0.35, -0.25, 0.25);
      const collision = new Set();
      if (growthN > 0.05) {
        drawLSystem(ctx, trunkTop, -Math.PI / 2 + lean, lsys, leafPoints, ink, geom, padT + 8, runScale * fitScale, collision);
      }

      // Leaves
      const leafCount = leaves > 0 ? Math.min(
        1400,
        Math.round(leaves * (26 + 32 * cohesionN + 26 * (complexityN || 0) + 32 * (weekendScoreN || 0)) * (1.0 + 0.35 * mode.dailyRatio))
      ) : 0;
      const autumnPalette = [
        "#3a2c1b", "#5a3a1c", "#7a3d1a", "#9b4a1f",
        "#b8572a", "#d26a3a", "#e07f3f", "#f29c38",
        "#c6423a", "#a8332b", "#7f2b2b", "#612727",
        "#8d6a3c", "#a07c43"
      ];
      const richness = clamp((recursion + abstraction + cohesion) / 3 + (complexityN || 0) * 0.35, 0, 1);
      const paletteCount = Math.max(3, Math.round(3 + richness * (autumnPalette.length - 5)));
      const stressMix = clamp(stress, 0, 1) * 0.5;
      const palette = autumnPalette.slice(0, paletteCount).map((c) => mixHex(c, "#2a2a2a", stressMix));
      if (leafCount > 0 && leafPoints.length) {
        ctx.save();
        ctx.strokeStyle = ink;
        ctx.fillStyle = palette[0];
        ctx.globalAlpha = 1;

        const points = (leafPoints.length ? leafPoints : [
          { x: trunkTop.x, y: trunkTop.y },
          { x: trunkBaseX, y: baseY - (height * 0.3) },
          { x: trunkBaseX, y: baseY - (height * 0.6) }
        ]).slice().sort((a, b) => a.y - b.y);
        const topCount = Math.max(6, Math.round(points.length * 0.65));
        const upperPoints = points.slice(0, topCount);
        const lowerPoints = points.slice(topCount);
        const dropCount = Math.round(leafCount * 0.2);
        for (let k=0;k<leafCount;k++){
          let px = 0;
          let py = 0;
          if (k < dropCount) {
            const pick = points[k % points.length] || trunkTop;
            const fall = (k / Math.max(1, dropCount)) * (40 + 80 * (1 - cohesionN));
            px = pick.x + ((k % 7) - 3) * 2;
            py = pick.y + fall;
          } else {
            const pick = (k % 3 === 0) ? points[k % points.length]
              : (k % 7 === 0 && lowerPoints.length ? lowerPoints[k % lowerPoints.length]
                : upperPoints[k % upperPoints.length]);
            const spread = 30 + 60 * (1 - cohesionN);
            const t = (k * 0.6180339887) % 1;
            const theta = t * Math.PI * 2;
            px = pick.x + Math.cos(theta) * spread * (0.35 + 0.65 * t);
            py = Math.max(padT + 6, pick.y + Math.sin(theta) * spread * (0.35 + 0.65 * t));
          }

          const rad = 1.1 + 1.4 * ((k % 11) / 10);
          const stretch = 1.2 + 0.9 * ((k % 7) / 6);
          const angle = (k % 9) * (Math.PI / 8);
          ctx.fillStyle = palette[k % palette.length];
          ctx.save();
          ctx.translate(px, py);
          ctx.rotate(angle);
          ctx.beginPath();
          ctx.ellipse(0, 0, rad * stretch, rad, 0, 0, Math.PI * 2);
          ctx.fill();
          if ((k % 5) === 0) { ctx.globalAlpha = 1; ctx.stroke(); }
          ctx.restore();

          geom.paths.push({
            type: "circle",
            cx: px, cy: py, r: rad,
            stroke: ink, sw: 0.8,
            alpha: 0.15,
            fill: "rgba(58,61,94,0.10)",
            fillAlpha: 1
          });
        }
        ctx.restore();
      }

      // Course labels (horizontal below sprout)
      ctx.save();
      ctx.fillStyle = ink;
      ctx.globalAlpha = 1;
      ctx.font = "600 12px " + getCSSVar("--sans");
      const labelX = clamp(x0, padL + 4, w - padR - 4);
      const labelY = Math.min(baseY + 16, baseY + 26);
      ctx.textAlign = "center";
      ctx.fillText(course, labelX, labelY);
      ctx.restore();
    }

  // Debounced forest updates while typing
  const debouncedForest = debounce(() => {
    try { renderForest(); } catch {}
  }, 180);

  const debouncedGraph = debounce(() => {
    try { renderConceptGraph(); } catch {}
  }, 220);

  // ---------- Hydration ----------
  function setPrintPreview(enabled) {
    state.printPreview = !!enabled;
    saveState();
    document.body.classList.toggle("print-preview", state.printPreview);
    toast(state.printPreview ? "Print preview on" : "Print preview off");
  }

  function hydrateInputs() {
    intentEl.value = state.intent || "";
    coreWindowEl.value = state.coreWindow || "";
    weekendPostureEl.value = state.weekendPosture || "";
    rebalanceDayEl.value = state.rebalanceDay || "Sunday";
    if (themeSelectEl) themeSelectEl.value = state.theme || "soft";
    applyTheme(state.theme || "soft");

    absorptionEl.value = state.absorption || "";
    workoutEl.value = state.workout || "";
    todayNotesEl.value = state.todayNotes || "";

    courseListEl.value = state.courses.join("; ");

    writingScheduleEl.value = state.writingSchedule || "";
    writingThreadEl.value = state.writingThread || "";
    writingTargetsEl.value = state.writingTargets || "";
    writingNotesEl.value = state.writingNotes || "";

    proseScheduleEl.value = state.proseSchedule || "";
    proseProjectEl.value = state.proseProject || "";
    proseTargetsEl.value = state.proseTargets || "";
    proseNotesEl.value = state.proseNotes || "";
    if (graphSpacingEl) graphSpacingEl.value = String(graphSpacing);

    if (openaiKeyEl) openaiKeyEl.value = state.llmKey || "";
    downtimeRuleEl.value = state.downtimeRule || "";

    renderModeChips();
    renderKeystoneDropdown();
    renderCourseCards();
    renderTasks();
    renderWeekSummary();
    renderConceptGraph();
    setupCardToggles();

    if (state.mdCache) mdPreviewEl.textContent = state.mdCache;

    forestLegendEl.classList.toggle("show", !!state.forest.legendOn);
    toggleHiResPngEl.checked = !!state.forest.hiResPng;
    if (toggleFullGhostEl) toggleFullGhostEl.checked = !!state.forest.showFullGhost;
    document.body.classList.toggle("print-preview", !!state.printPreview);
    debouncedForest();
  }

  // ---------- Wire up ----------
    // ---------- Wire up ----------
    intentEl.addEventListener("input", () => { state.intent = intentEl.value; saveState(); });
  coreWindowEl.addEventListener("input", () => { state.coreWindow = coreWindowEl.value; saveState(); });
  weekendPostureEl.addEventListener("input", () => { state.weekendPosture = weekendPostureEl.value; saveState(); });
  rebalanceDayEl.addEventListener("change", () => { state.rebalanceDay = rebalanceDayEl.value; saveState(); });
  themeSelectEl?.addEventListener("change", () => { applyTheme(themeSelectEl.value); });

  keystoneTodayEl.addEventListener("change", () => {
    state.keystoneToday = keystoneTodayEl.value;
    saveState();
    renderWeekSummary();
    debouncedForest();
  });

  absorptionEl.addEventListener("input", () => {
    state.absorption = absorptionEl.value;
    saveState();
  });

  workoutEl.addEventListener("input", () => {
    state.workout = workoutEl.value;
    saveState();
  });

  todayNotesEl.addEventListener("input", () => {
    state.todayNotes = todayNotesEl.value;
    saveState();
    debouncedForest();
    debouncedGraph();
  });

  courseListEl.addEventListener("keydown", (e) => {
    if (e.key === "Enter") { e.preventDefault(); el("btnApplyCourses").click(); }
  });

  writingScheduleEl.addEventListener("input", () => { state.writingSchedule = writingScheduleEl.value; saveState(); debouncedGraph(); });
  writingThreadEl.addEventListener("input", () => { state.writingThread = writingThreadEl.value; saveState(); debouncedGraph(); });
  writingTargetsEl.addEventListener("input", () => { state.writingTargets = writingTargetsEl.value; saveState(); debouncedGraph(); });
  writingNotesEl.addEventListener("input", () => { state.writingNotes = writingNotesEl.value; saveState(); debouncedGraph(); });

  proseScheduleEl.addEventListener("input", () => { state.proseSchedule = proseScheduleEl.value; saveState(); debouncedGraph(); });
  proseProjectEl.addEventListener("input", () => { state.proseProject = proseProjectEl.value; saveState(); debouncedGraph(); });
  proseTargetsEl.addEventListener("input", () => { state.proseTargets = proseTargetsEl.value; saveState(); debouncedGraph(); });
  proseNotesEl.addEventListener("input", () => { state.proseNotes = proseNotesEl.value; saveState(); debouncedGraph(); });

  downtimeRuleEl.addEventListener("input", () => { state.downtimeRule = downtimeRuleEl.value; saveState(); });

  if (openaiKeyEl) {
    openaiKeyEl.addEventListener("input", () => {
      state.llmKey = openaiKeyEl.value;
      saveState();
    });
  }

  // Mode editor
  el("btnAddMode").addEventListener("click", () => {
    const label = String(newModeLabelEl.value || "").trim();
    if (!label) { toast("Mode label is empty"); return; }
    if (state.modeChecks[label]) { toast("Mode already exists"); return; }
    const scope = newModeScopeEl.value === "daily" ? "daily" : "weekly";
    state.modeChecks[label] = false;
    state.modeScope[label] = scope;
    newModeLabelEl.value = "";
    saveState();
    renderModeChips();
    renderWeekSummary();
    debouncedForest();
  });

  // ---------- Buttons ----------

    // ---------- Buttons ----------
    el("btnAddTodayTask").addEventListener("click", () => {
      state.todayTasks.push({ id: uid(), done: false, title: "", course: state.keystoneToday || state.courses[0], mode: "(mode)" });
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
      toast("Added Today task");
      // focus newest title
      setTimeout(() => {
        const rows = todayTasksEl.querySelectorAll(".task input.title");
        rows[rows.length - 1]?.focus();
      }, 0);
    });

    el("btnClearTodayDone").addEventListener("click", () => {
      state.todayTasks = state.todayTasks.filter(t => !t.done);
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
      toast("Cleared completed Today tasks");
    });

    el("btnAddWeekendTask").addEventListener("click", () => {
      state.weekendTasks.push({ id: uid(), done: false, title: "", course: state.courses[0], mode: "(mode)" });
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
      toast("Added Weekend deliverable");
      setTimeout(() => {
        const rows = weekendTasksEl.querySelectorAll(".task input.title");
        rows[rows.length - 1]?.focus();
      }, 0);
    });

    el("btnClearWeekendDone").addEventListener("click", () => {
      state.weekendTasks = state.weekendTasks.filter(t => !t.done);
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
      toast("Cleared completed Weekend tasks");
    });

    el("btnApplyCourses").addEventListener("click", () => {
      const raw = String(courseListEl.value || "");
      const list = raw.split(";").map(x => x.trim()).filter(Boolean);

      if (!list.length) {
        toast("Course list is empty");
        return;
      }

      // Preserve existing notes where possible
      const old = state.courseNotes || {};
      const nextNotes = {};
      list.forEach(c => { nextNotes[c] = old[c] || { status: "steady", focus: "", budget: "", notes: "" }; });

      // Update tasks that pointed to removed courses -> move to first course
      const fallback = list[0];
      for (const t of [...state.todayTasks, ...state.weekendTasks]) {
        if (!list.includes(t.course)) t.course = fallback;
      }

      state.courses = list;
      state.courseNotes = nextNotes;

      if (!list.includes(state.keystoneToday)) state.keystoneToday = fallback;

      saveState();
      renderKeystoneDropdown();
      renderCourseCards();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
      toast("Applied courses");
    });

    // Markdown export buttons
    el("btnGenerateMd").addEventListener("click", async () => {
      if (openaiKeyEl && openaiKeyEl.value.trim()) {
        state.llmKey = openaiKeyEl.value.trim();
        saveState();
      }
      let usedGpt = false;
      if (state.llmKey) {
        try {
          const analyses = { ...(state.llmNoteAnalyses || {}) };
          for (const course of state.courses || []) {
            const noteText = state.courseNotes?.[course]?.notes || "";
            if (!noteText.trim()) continue;
            const res = await analyzeNotesWithGpt(course, noteText);
            if (res) analyses[course] = res;
          }
          state.llmNoteAnalyses = analyses;
          const response = await generateGptConferenceResponse();
          if (response) state.llmConferenceResponse = response;
          saveState();
          usedGpt = true;
        } catch (err) {
          console.warn("GPT markdown helpers failed", err);
          toast("GPT failed (fallback used)");
        }
      }
      const md = generateMarkdown({ forestFilename: "forest.jpg", graphFilename: "concept_graph.jpg" });
      setMdPreview(md);
      toast(usedGpt ? "Generated markdown (GPT)" : "Generated markdown");
    });

    el("btnCopyMd").addEventListener("click", async () => {
      const md = state.mdCache || generateMarkdown({ forestFilename: "forest.jpg", graphFilename: "concept_graph.jpg" });
      setMdPreview(md);
      try {
        await navigator.clipboard.writeText(md);
        toast("Copied");
      } catch {
        toast("Copy failed (browser blocked)");
      }
    });

    el("btnDownloadMd").addEventListener("click", () => {
      const md = state.mdCache || generateMarkdown({ forestFilename: "forest.jpg", graphFilename: "concept_graph.jpg" });
      setMdPreview(md);
      downloadText("download.md", md, "text/markdown");
      toast("Downloaded .md");
    });

    el("btnClearMd").addEventListener("click", () => {
      state.mdCache = "";
      saveState();
      mdPreviewEl.textContent = "(Generate markdown to preview here.)";
      toast("Cleared markdown");
    });

    el("btnArchiveBundle").addEventListener("click", async () => {
      try {
        const md = state.mdCache || generateMarkdown({ forestFilename: "forest.jpg", graphFilename: "concept_graph.jpg" });
        setMdPreview(md);
        const d = new Date();
        const yyyy = d.getFullYear();
        const mm = String(d.getMonth() + 1).padStart(2, "0");
        const dd = String(d.getDate()).padStart(2, "0");
        const folder = `Dashboard_${yyyy}-${mm}-${dd}`;
        const forestName = `${folder}/forest.jpg`;
        const graphName = `${folder}/concept_graph.jpg`;
        const mdName = `${folder}/Dashboard_${yyyy}-${mm}-${dd}.md`;
        const forestUrl = forestCardDataUrl("image/jpeg", 0.92, state.forest.hiResPng ? 2 : 1);
        const graphUrl = conceptGraphPngDataUrl(1, "image/jpeg", 0.92);
        const mdBytes = textToUint8(md);
        const forestBytes = forestUrl ? dataUrlToUint8(forestUrl) : new Uint8Array();
        const graphBytes = graphUrl ? dataUrlToUint8(graphUrl) : new Uint8Array();
        const zip = zipFiles([
          { name: mdName, data: mdBytes },
          ...(forestUrl ? [{ name: forestName, data: forestBytes }] : []),
          ...(graphUrl ? [{ name: graphName, data: graphBytes }] : [])
        ]);
        const blob = new Blob([zip], { type: "application/zip" });
        downloadBlob(`Dashboard_${yyyy}-${mm}-${dd}.zip`, blob);
        toast("Downloaded archive bundle");
      } catch {
        toast("Archive bundle failed");
      }
    });

    // Reset day/week checkboxes
    el("btnResetDay").addEventListener("click", () => {
      state.absorption = "";
      state.workout = "";
      state.todayNotes = "";
      state.writingSchedule = "";
      state.writingThread = "";
      state.writingTargets = "";
      state.writingNotes = "";
      state.proseSchedule = "";
      state.proseProject = "";
      state.proseTargets = "";
      state.proseNotes = "";
      state.mdCache = "";
      saveState();
      hydrateInputs();
      mdPreviewEl.textContent = "(Generate markdown to preview here.)";
      toast("Cleared daily inputs");
    });

    el("btnResetWeek").addEventListener("click", () => {
      if (!lastForestGeom) renderForest();
      saveGhostSnapshot(state.forest.weekId || isoWeekId(new Date()));
      state.todayTasks = [];
      state.weekendTasks = [];
      state.todayNotes = "";
      state.writingNotes = "";
      state.writingThread = "";
      state.writingTargets = "";
      state.proseNotes = "";
      state.proseProject = "";
      state.proseTargets = "";
      Object.keys(state.courseNotes || {}).forEach((course) => {
        state.courseNotes[course].notes = "";
        state.courseNotes[course].status = "steady";
      });
      state.llmNoteAnalyses = {};
      state.llmConferenceResponse = "";
      state.forest.perCourseMax = {};
      state.forest.weekId = isoWeekId(new Date());
      state.forest.weekly = { weekId: state.forest.weekId, courses: {} };
      saveState();
      renderModeChips();
      renderTasks();
      renderCourseCards();
      renderWeekSummary();
      debouncedForest();
      toast("Reset week");
    });

    // Backup / reset
    el("btnBackup").addEventListener("click", () => {
      try {
        const dateISO = new Date().toISOString().slice(0,10);
        downloadText(`semester-dashboard_backup_${dateISO}.json`, JSON.stringify(state, null, 2), "application/json");
        toast("Exported JSON");
      } catch {
        toast("Export failed");
      }
    });

    btnImportEl?.addEventListener("click", () => {
      importFileEl?.click();
    });

    importFileEl?.addEventListener("change", async () => {
      const file = importFileEl.files?.[0];
      if (!file) return;
      try {
        const rawText = await file.text();
        const raw = JSON.parse(rawText);
        applyImportedState(raw);
        toast("Imported JSON");
      } catch {
        toast("Import failed (invalid JSON)");
      } finally {
        importFileEl.value = "";
      }
    });

    btnSaveVaultEl?.addEventListener("click", async () => {
      await saveArchiveToVault();
    });

    el("btnHardReset").addEventListener("click", () => {
      const ok = confirm("Hard reset will wipe all locally saved dashboard data. Continue?");
      if (!ok) return;
      try { localStorage.removeItem(STORAGE_KEY); } catch {}
      state = structuredDefault();
      saveState();
      hydrateInputs();
      toast("Wiped local data");
    });

    el("btnPrintPreview").addEventListener("click", () => {
      setPrintPreview(!state.printPreview);
    });

    el("btnExitPrintPreview").addEventListener("click", () => {
      setPrintPreview(false);
    });

    // Forest controls
    el("btnToggleLegend").addEventListener("click", () => {
      state.forest.legendOn = !state.forest.legendOn;
      saveState();
      forestLegendEl.classList.toggle("show", !!state.forest.legendOn);
      toast(state.forest.legendOn ? "Legend on" : "Legend off");
    });

    toggleHiResPngEl.addEventListener("change", () => {
      state.forest.hiResPng = !!toggleHiResPngEl.checked;
      saveState();
      toast(state.forest.hiResPng ? "Hi-res JPG on" : "Hi-res JPG off");
    });

    if (toggleFullGhostEl) {
      toggleFullGhostEl.addEventListener("change", () => {
        state.forest.showFullGhost = !!toggleFullGhostEl.checked;
        saveState();
        debouncedForest();
        toast(state.forest.showFullGhost ? "Full ghost on" : "Full ghost off");
      });
    }

    el("btnExportPNG").addEventListener("click", () => {
      try {
        const dateISO = new Date().toISOString().slice(0,10);
        const url = forestCardDataUrl("image/jpeg", 0.92, state.forest.hiResPng ? 2 : 1);
        downloadDataUrl(`forest_${dateISO}.jpg`, url);
        toast("Exported JPG");
      } catch {
        toast("JPG export failed");
      }
    });

    el("btnExportSVG").addEventListener("click", () => {
      try {
        if (!lastForestGeom) renderForest();
        const dateISO = new Date().toISOString().slice(0,10);
        const svg = forestToSVG(lastForestGeom);
        downloadText(`forest_${dateISO}.svg`, svg, "image/svg+xml");
        toast("Exported SVG");
      } catch {
        toast("SVG export failed");
      }
    });


    btnSimForest?.addEventListener("click", () => {
      state.forest.simulateMax = !state.forest.simulateMax;
      saveState();
      debouncedForest();
      toast(state.forest.simulateMax ? "Simulation on" : "Simulation off");
    });
    el("btnClearGhost").addEventListener("click", () => {
      const current = isoWeekId(new Date());
      const prev = prevIsoWeekId(current);
      clearGhostSnapshot(prev);
      debouncedForest();
      toast("Cleared last-week ghost");
    });

    document.addEventListener("click", (e) => {
      if (!expandedCard) return;
      if (expandedCard.contains(e.target)) return;
      if (e.target.closest(".card-toggle")) return;
      setCardFocus(expandedCard, false);
    });

    // ---------- Responsive: rerender canvas on resize ----------
    window.addEventListener("resize", debounce(() => {
      debouncedForest();
    }, 120));

  async function fetchMaineEnvironment() {
    try {
      const url = "https://api.open-meteo.com/v1/forecast?latitude=43.6591&longitude=-70.2568&current_weather=true&hourly=relativehumidity_2m,cloudcover&timezone=America%2FNew_York";
      const res = await fetch(url);
      if (!res.ok) throw new Error("weather fetch failed");
      const data = await res.json();
      const current = data.current_weather || {};
      const hourly = data.hourly || {};
      const timeIndex = hourly.time ? hourly.time.indexOf(current.time) : -1;
      const humidity = timeIndex >= 0 ? hourly.relativehumidity_2m?.[timeIndex] : null;
      const cloudCover = timeIndex >= 0 ? hourly.cloudcover?.[timeIndex] : null;
      state.env = {
        temperature: current.temperature ?? 12,
        windSpeed: current.windspeed ?? 6,
        humidity: humidity ?? 65,
        cloudCover: cloudCover ?? 40,
        updated: current.time || new Date().toISOString()
      };
      saveState();
      debouncedForest();
    } catch {
      state.env = state.env || { temperature: 12, windSpeed: 6, humidity: 65, cloudCover: 40, updated: new Date().toISOString() };
      saveState();
    }
  }

  // ---------- Init ----------
  // Ensure weekId is set early to support ghost logic without flicker
  if (!state.forest.weekId) state.forest.weekId = isoWeekId(new Date());
  hydrateInputs();
  fetchMaineEnvironment();

    // If first load has no md cache, show empty but ready
    if (!state.mdCache) mdPreviewEl.textContent = "(Generate markdown to preview here.)";

  </script>
</body>
</html>