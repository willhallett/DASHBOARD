<!-- CANARY: local edit -->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Semester Dashboard — Modes + .md Export</title>
  <style>
    :root {
      --bg: #fbfaf7;
      --bg-grad-1: #fffdfa;
      --bg-grad-2: #f1ebdf;
      --panel: #ffffff;
      --panel2: #f6f4ef;
      --text: #1f1b16;
      --muted: #6f675d;
      --line: #e7e1d7;
      --accent: #efeae0;
      --chip: #f3eee5;
      --danger: #d92b4b;
      --ok: #1faa7a;
      --warn: #d9a12b;
      --radius: 16px;
      --shadow: 0 18px 40px rgba(32, 24, 14, 0.08);
      --shadowSoft: 0 8px 16px rgba(32, 24, 14, 0.05);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --serif: "Palatino Linotype", Palatino, "Book Antiqua", Georgia, "Times New Roman", serif;
      --sans: "Avenir Next", "Gill Sans", "Trebuchet MS", "Segoe UI", Arial, sans-serif;
      --ink: #2b2620;
    }
    body[data-theme="bright"] {
      --bg: #ffffff;
      --bg-grad-1: #ffffff;
      --bg-grad-2: #f4f4f4;
      --panel: #ffffff;
      --panel2: #f7f7f7;
      --text: #111111;
      --muted: #666666;
      --line: #e6e6e6;
      --accent: #f2f2f2;
      --chip: #f3f3f3;
      --ink: #2d2a26;
      --shadow: 0 16px 34px rgba(32, 32, 32, 0.08);
      --shadowSoft: 0 8px 16px rgba(32, 32, 32, 0.05);
    }
    body[data-theme="dark"] {
      --bg: #141210;
      --bg-grad-1: #191613;
      --bg-grad-2: #0f0d0b;
      --panel: #1c1a17;
      --panel2: #23201c;
      --text: #e8e4dc;
      --muted: #b0a79a;
      --line: #2c2924;
      --accent: #26231f;
      --chip: #2a2722;
      --ink: #f0ece4;
      --shadow: 0 18px 40px rgba(0, 0, 0, 0.35);
      --shadowSoft: 0 8px 16px rgba(0, 0, 0, 0.25);
    }
    body[data-theme="dark"] header {
      background: rgba(20, 18, 16, 0.72);
      border-bottom-color: rgba(255, 255, 255, 0.06);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: var(--sans);
      background:
        radial-gradient(1200px 900px at 15% 0%, var(--bg-grad-1) 0%, var(--bg) 55%),
        linear-gradient(180deg, var(--bg-grad-1) 0%, var(--bg-grad-2) 100%);
      color: var(--text);
      transition: background .18s ease, color .18s ease;
    }
    :focus-visible { outline: 2px solid var(--ink); outline-offset: 2px; border-radius: 10px; }

    header {
      position: sticky;
      top: 0;
      z-index: 10;
      background: rgba(255, 255, 255, 0.72);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--line);
    }
    .wrap { max-width: 1180px; margin: 0 auto; padding: 18px 18px 48px; }
    .topbar {
      display: grid;
      grid-template-columns: 1.6fr 1fr;
      gap: 18px;
      align-items: center;
    }
    h1 { margin: 0 0 4px; font-size: 18px; letter-spacing: .3px; font-family: var(--sans); }
    .subtitle { color: var(--muted); font-size: 12px; line-height: 1.4; }
    .controls {
      display: flex; gap: 10px; justify-content: flex-end; flex-wrap: wrap;
    }
    .controls details {
      border: 1px solid var(--line);
      background: var(--panel2);
      border-radius: 12px;
      padding: 6px 10px;
    }
    .controls details[open] {
      box-shadow: var(--shadowSoft);
    }
    .controls summary {
      cursor: pointer;
      font-weight: 700;
      font-size: 12px;
      list-style: none;
    }
    .controls summary::-webkit-details-marker { display: none; }
    .controls .utility-actions {
      display: grid;
      gap: 8px;
      margin-top: 8px;
    }
    button, .btn {
      border: 1px solid var(--line);
      background: var(--panel2);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      cursor: pointer;
      box-shadow: none;
      font-weight: 600;
      font-size: 13px;
      transition: background .18s ease, border-color .18s ease, color .18s ease, box-shadow .18s ease;
    }
    button:hover { border-color: var(--ink); background: var(--accent); }
    button:active { transform: translateY(1px); }
    .btn-secondary { background: var(--accent); box-shadow: none; }
    .btn-danger { border-color: rgba(255,92,122,.35); }
    .btn-danger:hover { border-color: rgba(255,92,122,.65); }
    .theme-switch { display: flex; gap: 6px; align-items: center; }
    .theme-switch select {
      border: 1px solid var(--line);
      background: var(--panel2);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 12px;
      font-weight: 600;
    }

    main { padding-top: 18px; }
    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 980px) {
      .topbar { grid-template-columns: 1fr; }
      .controls { justify-content: flex-start; }
      .grid { grid-template-columns: 1fr; }
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 18px;
      box-shadow: var(--shadowSoft);
      position: relative;
      transition: background .18s ease, border-color .18s ease, box-shadow .18s ease, transform .18s ease, opacity .18s ease;
    }
    .card-toggle {
      position: absolute;
      top: 12px;
      right: 12px;
      border: 1px solid var(--line);
      background: var(--panel2);
      color: var(--text);
      padding: 6px 10px;
      border-radius: 10px;
      font-size: 11px;
      font-weight: 700;
      cursor: pointer;
    }
    .card-toggle:hover { background: var(--accent); border-color: var(--ink); }
    body.card-focus { overflow: hidden; }
    body.card-focus::before {
      content: "";
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.08);
      z-index: 50;
    }
    .card.expanded {
      position: fixed;
      inset: 78px 22px 22px;
      z-index: 70;
      box-shadow: var(--shadow);
      overflow: auto;
      transform: translateZ(0);
    }
    .card.dimmed {
      opacity: 0.2;
      filter: blur(0.6px) saturate(0.9);
      pointer-events: none;
    }
    .card h2 {
      margin: 0 0 10px;
      font-size: 15px;
      letter-spacing: .6px;
      font-family: var(--sans);
    }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .row > * { flex: 1; }
    .row .tight { flex: 0 0 auto; }
    label { font-size: 12px; color: var(--muted); display: block; margin: 8px 0 6px; }
    input[type="text"], input[type="number"], textarea, select {
      width: 100%;
      border: 1px solid var(--line);
      background: var(--panel2);
      color: var(--text);
      padding: 10px 10px;
      border-radius: 12px;
      outline: none;
      font-size: 13px;
      transition: background .18s ease, border-color .18s ease, color .18s ease;
    }
    textarea { min-height: 92px; resize: vertical; }
    .mini { font-size: 12px; color: var(--muted); margin-top: 8px; }

    .chips { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 6px; }
    .chip {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      background: var(--chip);
      border: 1px solid var(--line);
      padding: 8px 10px;
      border-radius: 999px;
      font-size: 12px;
      color: var(--text);
      user-select: none;
      transition: background .18s ease, border-color .18s ease, color .18s ease;
    }
    .chip input { transform: translateY(1px); }
    .chip .chip-btn {
      border: 1px solid var(--line);
      background: var(--panel);
      color: var(--text);
      border-radius: 8px;
      padding: 2px 6px;
      font-size: 11px;
      cursor: pointer;
    }
    .pill {
      font-family: var(--mono);
      padding: 5px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--panel2);
      color: var(--muted);
      font-size: 11px;
      white-space: nowrap;
    }
    .pill.ink { color: var(--ink); border-color: rgba(58,61,94,.25); }

    .section-title {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      align-items: baseline;
      margin-bottom: 8px;
      padding-bottom: 6px;
      border-bottom: 1px dashed rgba(45,42,38,.15);
    }
    .section-title .hint { color: var(--muted); font-size: 12px; }

    .task {
      display: grid;
      grid-template-columns: 24px 1fr 110px 110px 34px;
      gap: 10px;
      align-items: center;
      padding: 9px 10px;
      border: 1px solid var(--line);
      background: var(--panel2);
      border-radius: 14px;
      margin-bottom: 8px;
      transition: background .18s ease, border-color .18s ease, color .18s ease;
    }
    .task input[type="checkbox"] { width: 18px; height: 18px; }
    .task input[type="text"] { padding: 9px 9px; }
    .task select { padding: 9px 9px; }
    .task .del {
      width: 34px; height: 34px; border-radius: 12px;
      background: rgba(255,92,122,.08);
      border: 1px solid rgba(255,92,122,.25);
      color: var(--text); cursor: pointer;
      box-shadow: none;
      font-weight: 900;
    }
    .task .del:hover { border-color: rgba(255,92,122,.55); }
    .task.done { opacity: .7; }
    .task.done .title { text-decoration: line-through; color: var(--muted); }

    .cols {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
    }
    @media (max-width: 980px) { .cols { grid-template-columns: 1fr; } }
    .stack-col {
      display: grid;
      grid-template-rows: 1fr 1fr;
      gap: 14px;
    }

    .mdbox {
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.45;
      white-space: pre-wrap;
      border: 1px dashed var(--ink);
      background: var(--panel2);
      padding: 12px;
      border-radius: 14px;
      min-height: 160px;
      max-height: 360px;
      overflow: auto;
    }

    .statusline { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
    .dot.ok { background: var(--ok); }
    .dot.warn { background: var(--warn); }
    .dot.bad { background: var(--danger); }

    .footer-note { color: var(--muted); font-size: 12px; margin-top: 10px; }
    a { color: var(--ink); }

    body.print-preview {
      background: #ffffff;
      color: #1f2234;
    }
    body.print-preview header {
      position: static;
      backdrop-filter: none;
      background: #ffffff;
    }
    body.print-preview .controls,
    body.print-preview button,
    body.print-preview .inlineForm,
    body.print-preview .del {
      display: none !important;
    }
    body.print-preview button.print-exit {
      display: inline-flex !important;
    }
    body.print-preview input,
    body.print-preview textarea,
    body.print-preview select {
      border: none;
      background: transparent;
      padding: 0;
      color: #1f2234;
      box-shadow: none;
    }
    body.print-preview .card {
      box-shadow: none;
    }

    .print-exit {
      position: fixed;
      top: 14px;
      right: 18px;
      z-index: 60;
      display: none;
    }
    body.print-preview .print-exit { display: inline-flex; }

    @media print {
      header,
      .controls,
      button,
      .inlineForm,
      .del {
        display: none !important;
      }
      .print-exit {
        display: none !important;
      }
      body {
        background: #ffffff;
        color: #1f2234;
      }
      .card {
        box-shadow: none;
      }
    }

    /* Toast */
    .toast {
      position: fixed;
      right: 16px;
      bottom: 16px;
      z-index: 50;
      background: var(--panel);
      border: 1px solid var(--line);
      box-shadow: none;
      padding: 10px 12px;
      border-radius: 14px;
      font-size: 12px;
      color: var(--text);
      opacity: 0;
      transform: translateY(6px);
      pointer-events: none;
      transition: opacity .18s ease, transform .18s ease;
    }
    .toast.show { opacity: 1; transform: translateY(0px); }

    /* Inline form */
    .inlineForm {
      border: 1px solid var(--line);
      background: var(--panel2);
      border-radius: 14px;
      padding: 10px;
      margin-top: 10px;
      display: none;
    }
    .inlineForm.show { display: block; }
    .inlineForm .cols { margin-top: 6px; }

    /* Forest */
    .span2 { grid-column: 1 / -1; } /* full-width card within the grid row */

    .forestWrap {
      border: 1px solid var(--line);
      background: var(--panel2);
      border-radius: 14px;
      padding: 10px;
      margin-top: 10px;
      overflow: hidden;
    }
    canvas#forestCanvas {
      width: 100%;
      height: 900px; /* taller to show mycelium network beneath labels */
      display: block;
      border-radius: 12px;
      background: var(--panel);
    }
    .forestLegend {
      margin-top: 10px;
      border: 1px solid var(--line);
      background: var(--panel2);
      border-radius: 14px;
      padding: 10px;
      font-size: 12px;
      color: var(--muted);
      display: none;
    }
    .forestLegend.show { display: block; }
    .forestLegend b { color: var(--ink); }
    .forestLegend code { font-family: var(--mono); font-size: 11px; color: var(--ink); }

    /* Concept graph */
    #conceptGraphCanvas {
      width: 100%;
      height: 320px;
      display: block;
      border-radius: 12px;
      background: var(--panel);
      border: 1px solid var(--line);
    }
    @media (max-width: 980px) {
      .card.expanded { inset: 72px 12px 12px; }
    }
    .graphHint { font-size: 12px; color: var(--muted); margin-top: 8px; }

    .apiKeyInput {
      min-width: 220px;
    }
  </style>
</head>

<body>
<button class="btn-secondary print-exit" id="btnExitPrintPreview">Exit print preview</button>
<header>
  <div class="wrap topbar">
    <div>
      <h1>WILL HALLETT EES/GCAS SPRING 2026</h1>
      <div class="subtitle">
        Default posture: <span class="pill">9–5 = material-building</span> • evenings/weekends = deliverables.
        Everything auto-saves locally.
      </div>
    </div>
    <div class="controls">
      <label class="chip tight theme-switch">
        <span>Theme</span>
        <select id="themeSelect" aria-label="Theme mode">
          <option value="soft">Soft</option>
          <option value="bright">Bright</option>
          <option value="dark">Dark</option>
        </select>
      </label>
      <button class="btn-secondary" id="btnResetDay">Reset “Day”</button>
      <button class="btn-secondary" id="btnPrintPreview">Print preview</button>
      <details>
        <summary>Utilities</summary>
        <div class="utility-actions">
          <button class="btn-secondary" id="btnResetWeek">Weekly reset</button>
          <button class="btn-secondary" id="btnBackup">Export JSON backup</button>
          <button class="btn-danger" id="btnHardReset">Hard reset (wipe local)</button>
        </div>
      </details>
    </div>
  </div>
</header>

<main class="wrap">
  <!-- Week Summary FULL WIDTH -->
  <div class="grid" style="margin-top:14px;">
    <section class="card span2">
      <div class="section-title">
        <h2>Week Summary</h2>
        <div class="hint">Stability readout + forest (no extra data entry)</div>
      </div>

      <div id="weekSummary" class="mini"></div>

      <div class="forestWrap" aria-label="Weekly forest visualization">
        <div class="row" style="margin-bottom:10px;">
          <button class="btn-secondary" id="btnToggleLegend" title="Toggle legend">Legend</button>
          <button class="btn-secondary" id="btnExportPNG" title="Download forest as JPG">Export JPG</button>
          <button class="btn-secondary" id="btnExportSVG" title="Download forest as SVG">Export SVG</button>
          <button class="btn-secondary" id="btnClearGhost" title="Clear last-week ghost overlay">Clear ghost</button>
          <label class="chip tight" style="padding:6px 10px;">
            <input type="checkbox" id="toggleFullGhost" />
            Full ghost
          </label>
          <label class="chip tight" style="padding:6px 10px;">
            <input type="checkbox" id="toggleHiResPng" />
            Hi-res JPG
          </label>
        </div>

        <canvas id="forestCanvas"></canvas>

        <div id="forestLegend" class="forestLegend"></div>
      </div>

      <div class="footer-note">
        This is computed from tasks + course statuses + your writing. It grows during the week (max-growth memory for writing/task completion), and overlays last week as a faint trace. Stress and daily-mode checkboxes remain dynamic.
      </div>
    </section>
  </div>

  <div class="grid">
    <!-- Left column: core structure -->
    <section class="card">
      <div class="section-title">
        <h2>Core Rhythm</h2>
        <div class="hint">Set the rules of engagement</div>
      </div>

      <label>Semester intent (1–2 sentences)</label>
      <input type="text" id="intent" placeholder="e.g., Build real understanding; avoid backlog; weekend slay sessions bounded." />

      <div class="cols" style="margin-top:10px;">
        <div>
          <label>Weekday core window</label>
          <input type="text" id="coreWindow" placeholder="e.g., 9:00–17:00" />
          <div class="mini">Used in the markdown export header.</div>
        </div>
        <div>
          <label>Weekend posture</label>
          <input type="text" id="weekendPosture" placeholder="e.g., deliverables + exam review + downtime" />
          <div class="mini">Keep bounded so it doesn’t become spillover.</div>
        </div>
        <div>
          <label>Weekly rebalance day</label>
          <select id="rebalanceDay">
            <option>Friday</option><option>Saturday</option><option>Sunday</option><option>Monday</option>
          </select>
          <div class="mini">20 minutes to re-allocate blocks.</div>
        </div>
      </div>

      <label style="margin-top:12px;">Modes checklist (daily + weekly anchors)</label>
      <div class="row inlineForm show" id="modeEditor" style="margin-bottom:8px;">
        <input type="text" id="newModeLabel" placeholder="Add mode label" />
        <select id="newModeScope">
          <option value="daily">daily</option>
          <option value="weekly" selected>weekly</option>
        </select>
        <button class="btn-secondary tight" id="btnAddMode">Add</button>
      </div>
      <div class="chips" id="modeChips"></div>

      <div class="footer-note">
        Tip: keep one protected “absorption block” each weekday (no new inputs; only consolidation).
      </div>
    </section>

    <!-- Right column: today planner -->
    <section class="card">
      <div class="section-title">
        <h2>Today — Focus & Blocks</h2>
        <div class="hint">Plan lightly; execute steadily</div>
      </div>

      <div class="cols">
        <div>
          <label>Keystone course today</label>
          <select id="keystoneToday"></select>
          <div class="mini">If this is stable, the day is stable.</div>
        </div>
        <div>
          <label>Absorption block (60–90 min)</label>
          <input type="text" id="absorption" placeholder="e.g., AOIC: re-derive key mechanisms + quiz-style Qs" />
        </div>
        <div>
          <label>Workout (quick note)</label>
          <input type="text" id="workout" placeholder="e.g., 35 min run + mobility" />
        </div>
      </div>

      <label style="margin-top:12px;">Quick capture (what matters / what’s fuzzy)</label>
      <textarea id="todayNotes" placeholder="2–6 bullet points: what landed, what’s confusing, what to ask ChatGPT / prof."></textarea>

      <div class="row" style="margin-top:10px;">
        <button id="btnAddTodayTask">+ Add Today Task</button>
        <button class="btn-secondary" id="btnClearTodayDone">Clear completed</button>
      </div>

      <div id="todayTasks" style="margin-top:10px;"></div>
    </section>
  </div>

  <div class="grid" style="margin-top:14px;">
    <!-- Courses -->
    <section class="card">
      <div class="section-title">
        <h2>Courses — Modes + Notes</h2>
        <div class="hint">Keep each course bounded</div>
      </div>

      <div class="row">
        <div>
          <label>Courses (editable)</label>
          <input type="text" id="courseList" placeholder="AOIC; Neurobiology; Biological Modeling; Calc II; Probability/Prereqs; GCAS Writing" />
          <div class="mini">Separate with semicolons.</div>
        </div>
        <div class="tight">
          <label>&nbsp;</label>
          <button class="btn-secondary" id="btnApplyCourses">Apply</button>
        </div>
      </div>

      <div id="courseCards" style="margin-top:12px;"></div>
    </section>

    <div class="stack-col">
      <!-- Writing sessions -->
      <section class="card focus-card">
        <div class="section-title">
          <h2>GCAS Writing</h2>
          <div class="hint">Light, consistent, non-sprawling</div>
        </div>

        <div class="cols" style="margin-top:10px;">
          <div>
            <label>GCAS schedule</label>
            <input type="text" id="writingSchedule" placeholder="e.g., Tue/Thu afternoons" />
          </div>
          <div>
            <label>Current writing thread</label>
            <input type="text" id="writingThread" placeholder="e.g., Neural Set; Saussure/Lacan; modeling epistemology" />
          </div>
          <div>
            <label>GCAS targets</label>
            <input type="text" id="writingTargets" placeholder="e.g., 300 words target; Badiou set theory; Freud neurobiology" />
          </div>
        </div>
        <label style="margin-top:12px;">GCAS notes</label>
        <textarea id="writingNotes" placeholder="Short synthesis, questions, or conceptual bridges to keep."></textarea>
        <div class="footer-note">Keep cadence and conceptual targets lightweight but explicit.</div>
      </section>

      <!-- Prose writing -->
      <section class="card focus-card">
        <div class="section-title">
          <h2>Prose Writing</h2>
          <div class="hint">Drafts, reflections, and narrative output</div>
        </div>

        <div class="cols" style="margin-top:10px;">
          <div>
            <label>Prose schedule</label>
            <input type="text" id="proseSchedule" placeholder="e.g., Wed/Fri afternoons" />
          </div>
          <div>
            <label>Current prose project</label>
            <input type="text" id="proseProject" placeholder="e.g., Semester reflection essay; narrative recap" />
          </div>
          <div>
            <label>Prose targets</label>
            <input type="text" id="proseTargets" placeholder="e.g., 300 words; draft scene; revision focus" />
          </div>
        </div>

        <label style="margin-top:12px;">Prose notes</label>
        <textarea id="proseNotes" placeholder="Short notes, tone cues, or narrative beats to keep." ></textarea>

        <div class="footer-note">Separate from GCAS; keep prose constraints visible.</div>
      </section>
    </div>
  </div>

  <div class="grid" style="margin-top:14px;">
    <!-- Weekend deliverables -->
    <section class="card">
      <div class="section-title">
        <h2>Weekend Deliverables</h2>
        <div class="hint">Slay sessions with edges</div>
      </div>

      <div class="row">
        <button id="btnAddWeekendTask">+ Add deliverable</button>
        <button class="btn-secondary" id="btnClearWeekendDone">Clear completed</button>
      </div>

      <div id="weekendTasks" style="margin-top:10px;"></div>

      <label style="margin-top:12px;">Downtime boundary (write it like a rule)</label>
      <input type="text" id="downtimeRule" placeholder="e.g., Sat night off; Sun morning slow; no work after 8pm." />
    </section>

    <!-- Markdown export -->
    <section class="card">
      <div class="section-title">
        <h2>.md Export (Obsidian)</h2>
        <div class="hint">Generate, copy, download</div>
      </div>

      <div class="row">
        <button id="btnGenerateMd">Generate Markdown</button>
        <input type="password" id="openaiKey" class="apiKeyInput" placeholder="OpenAI API key" />
        <button class="btn-secondary" id="btnCopyMd">Copy</button>
        <button class="btn-secondary" id="btnDownloadMd">Download .md</button>
        <button class="btn-secondary" id="btnClearMd">Clear Markdown</button>
        <button class="btn-secondary" id="btnArchiveBundle">Archive bundle</button>
      </div>

      <label style="margin-top:12px;">Markdown preview</label>
      <div id="mdPreview" class="mdbox"></div>

      <div class="statusline" style="margin-top:10px;">
        <span class="dot ok"></span><span class="mini">Saved locally</span>
        <span class="dot warn"></span><span class="mini">Reset week = clears writing + tasks + mode checks</span>
        <span class="dot bad"></span><span class="mini">Hard reset wipes everything</span>
      </div>
    </section>
  </div>

  <div class="grid" style="margin-top:14px;">
    <!-- Concept graph -->
    <section class="card span2">
      <div class="section-title">
        <h2>Concept Graph (3D)</h2>
        <div class="hint">Major concepts and linkages across writing</div>
      </div>
      <canvas id="conceptGraphCanvas" aria-label="3D concept linkage graph"></canvas>
      <div class="row" style="margin-top:10px;">
        <button class="btn-secondary" id="btnRegenGraph">Regenerate graph</button>
        <label class="chip tight" style="padding:6px 10px;">
          <span style="margin-right:6px;">Spacing</span>
          <input type="range" id="graphSpacing" min="0.8" max="4.5" step="0.1" value="4.5" />
        </label>
      </div>
      <div class="graphHint">Drag to rotate; scroll to zoom. Nodes are inferred from all writing artifacts.</div>
    </section>
  </div>
</main>

<div id="toast" class="toast" role="status" aria-live="polite"></div>

<script>
  // ---------- Version + migration ----------
  const STORAGE_KEY = "semester_dashboard_v1";
  const CURRENT_VERSION = 10; // add theme preference

  const DEFAULT = {
    version: CURRENT_VERSION,

    intent: "",
    coreWindow: "9:00–17:00",
    weekendPosture: "Deliverables + exam review + downtime",
    rebalanceDay: "Sunday",

    // Daily vs weekly semantics
    modeScope: {
      "Attend sync lecture/recitation": "weekly",
      "Watch async lecture(s)": "weekly",
      "Reading upkeep": "daily",
      "Absorption block (no new inputs)": "daily",
      "Prereq / review": "weekly",
      "Light writing (GCAS / synthesis)": "weekly",
      "Admin / grants (small churn)": "weekly",
      "Exercise": "daily",
    },

    modeChecks: {
      "Attend sync lecture/recitation": false,
      "Watch async lecture(s)": false,
      "Reading upkeep": false,
      "Absorption block (no new inputs)": false,
      "Prereq / review": false,
      "Light writing (GCAS / synthesis)": false,
      "Admin / grants (small churn)": false,
      "Exercise": false,
    },

    courses: ["AOIC", "Neurobiology", "Biological Modeling", "Calc II", "Probability/Prereqs", "GCAS Writing"],
    courseNotes: {},

    keystoneToday: "AOIC",
    absorption: "",
    workout: "",
    todayNotes: "",
    todayTasks: [],
    weekendTasks: [],

    writingSchedule: "Tue/Thu afternoons",
    writingThread: "",
    writingTargets: "300 words target; Badiou set theory; Freud neurobiology",
    writingNotes: "",

    proseSchedule: "Wed/Fri afternoons",
    proseProject: "",
    proseTargets: "300 words; draft scene; revision focus",
    proseNotes: "",

    env: null,

    downtimeRule: "",
    mdCache: "",
    lastExport: null,
    printPreview: false,
    theme: "soft",
    llmKey: "",
    llmNoteAnalyses: {},
    llmConferenceResponse: "",

    // Forest
    forest: {
      legendOn: false,
      weekId: "",
      perCourseMax: {},   // max-memory for writing volume / syntax / cohesion / completed tasks
      hiResPng: false,
      showFullGhost: false,
      weekly: { weekId: "", courses: {} },
    }
  };

  function structuredDefault() {
    return (typeof structuredClone === "function")
      ? structuredClone(DEFAULT)
      : JSON.parse(JSON.stringify(DEFAULT));
  }

  function migrateState(s) {
    const v = s?.version || 1;
    if (v < 2) {
      s.modeScope = s.modeScope || structuredDefault().modeScope;
      s.version = 2;
    }
    if (v < 3) {
      s.forest = s.forest || structuredDefault().forest;
      s.version = 3;
    }
    if (v < 4) {
      // v4: remove maxStress storage if present; keep only the intended max-memory metrics
      if (s.forest?.perCourseMax) {
        for (const k of Object.keys(s.forest.perCourseMax)) {
          if ("maxStress" in s.forest.perCourseMax[k]) delete s.forest.perCourseMax[k].maxStress;
        }
      }
      s.version = 4;
    }
    if (v < 5) {
      s.proseProject = s.proseProject ?? "";
      s.proseNotes = s.proseNotes ?? "";
      s.version = 5;
    }
    if (v < 6) {
      s.lastExport = s.lastExport ?? null;
      s.printPreview = s.printPreview ?? false;
      s.forest = s.forest || structuredDefault().forest;
      s.forest.hiResPng = s.forest.hiResPng ?? false;
      s.version = 6;
    }
    if (v < 7) {
      s.writingSchedule = s.writingSchedule ?? structuredDefault().writingSchedule;
      s.writingTargets = s.writingTargets ?? structuredDefault().writingTargets;
      s.writingNotes = s.writingNotes ?? "";
      s.proseSchedule = s.proseSchedule ?? structuredDefault().proseSchedule;
      s.proseTargets = s.proseTargets ?? structuredDefault().proseTargets;
      s.env = s.env ?? null;
      s.version = 7;
    }
    if (v < 8) {
      s.forest = s.forest || structuredDefault().forest;
      s.forest.weekly = s.forest.weekly || structuredDefault().forest.weekly;
      s.version = 8;
    }
    if (v < 9) {
      s.llmKey = s.llmKey ?? "";
      s.llmNoteAnalyses = s.llmNoteAnalyses ?? {};
      s.llmConferenceResponse = s.llmConferenceResponse ?? "";
      s.forest = s.forest || structuredDefault().forest;
      s.forest.showFullGhost = s.forest.showFullGhost ?? false;
      s.version = 9;
    }
    if (v < 10) {
      s.theme = s.theme ?? "soft";
      s.version = 10;
    }
    return s;
  }

  function loadState() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return structuredDefault();
      const parsed = migrateState(JSON.parse(raw));
      const def = structuredDefault();
      return {
        ...def,
        ...parsed,
        version: CURRENT_VERSION,
        modeChecks: { ...def.modeChecks, ...(parsed.modeChecks||{}) },
        modeScope:  { ...def.modeScope,  ...(parsed.modeScope||{})  },
        forest:     { ...def.forest,     ...(parsed.forest||{})     },
      };
    } catch {
      return structuredDefault();
    }
  }

  let state = loadState();

  function saveState() {
    state.version = CURRENT_VERSION;
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  }

  function uid() {
    return Math.random().toString(16).slice(2) + Date.now().toString(16);
  }

  // ---------- Toast ----------
  let toastTimer = null;
  function toast(msg) {
    const t = document.getElementById("toast");
    t.textContent = msg;
    t.classList.add("show");
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => t.classList.remove("show"), 1200);
  }

  // ---------- Elements ----------
  const el = (id) => document.getElementById(id);

  const intentEl = el("intent");
  const coreWindowEl = el("coreWindow");
  const weekendPostureEl = el("weekendPosture");
  const rebalanceDayEl = el("rebalanceDay");
  const themeSelectEl = el("themeSelect");
  const modeChipsEl = el("modeChips");
  const modeEditorEl = el("modeEditor");
  const newModeLabelEl = el("newModeLabel");
  const newModeScopeEl = el("newModeScope");

  const keystoneTodayEl = el("keystoneToday");
  const absorptionEl = el("absorption");
  const workoutEl = el("workout");
  const todayNotesEl = el("todayNotes");
  const todayTasksEl = el("todayTasks");

  const weekSummaryEl = el("weekSummary");

  const courseListEl = el("courseList");
  const courseCardsEl = el("courseCards");

  const writingScheduleEl = el("writingSchedule");
  const writingThreadEl = el("writingThread");
  const writingTargetsEl = el("writingTargets");
  const writingNotesEl = el("writingNotes");

  const proseScheduleEl = el("proseSchedule");
  const proseProjectEl = el("proseProject");
  const proseTargetsEl = el("proseTargets");
  const proseNotesEl = el("proseNotes");
  const conceptGraphCanvas = el("conceptGraphCanvas");
  const btnRegenGraph = el("btnRegenGraph");
  const graphSpacingEl = el("graphSpacing");

  const weekendTasksEl = el("weekendTasks");
  const downtimeRuleEl = el("downtimeRule");

  const mdPreviewEl = el("mdPreview");
  const openaiKeyEl = el("openaiKey");

  // Forest elements
  const forestCanvas = el("forestCanvas");
  const forestLegendEl = el("forestLegend");
  const toggleHiResPngEl = el("toggleHiResPng");
  const toggleFullGhostEl = el("toggleFullGhost");

  // ---------- Utilities ----------
  function escapeHtml(s) {
    return (s || "").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
  }

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function getCSSVar(name){
    return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
  }

  function hexToRgb(hex) {
    const h = String(hex || "").replace("#", "");
    if (h.length === 3) {
      return {
        r: parseInt(h[0] + h[0], 16),
        g: parseInt(h[1] + h[1], 16),
        b: parseInt(h[2] + h[2], 16)
      };
    }
    return {
      r: parseInt(h.slice(0, 2), 16),
      g: parseInt(h.slice(2, 4), 16),
      b: parseInt(h.slice(4, 6), 16)
    };
  }

  function mixHex(a, b, t) {
    const c1 = hexToRgb(a);
    const c2 = hexToRgb(b);
    const mix = (v1, v2) => Math.round(v1 + (v2 - v1) * t);
    const r = mix(c1.r, c2.r).toString(16).padStart(2, "0");
    const g = mix(c1.g, c2.g).toString(16).padStart(2, "0");
    const bch = mix(c1.b, c2.b).toString(16).padStart(2, "0");
    return `#${r}${g}${bch}`;
  }

  function debounce(fn, ms){
    let t = null;
    return (...args) => {
      clearTimeout(t);
      t = setTimeout(() => fn(...args), ms);
    };
  }

  function applyTheme(theme) {
    const next = ["bright", "soft", "dark"].includes(theme) ? theme : "soft";
    document.body.dataset.theme = next;
    if (state) {
      state.theme = next;
      saveState();
    }
    if (themeSelectEl) themeSelectEl.value = next;
  }

  // ISO week id: YYYY-Www
  function isoWeekId(date = new Date()) {
    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    const dayNum = d.getUTCDay() || 7; // Mon=1..Sun=7
    d.setUTCDate(d.getUTCDate() + 4 - dayNum);
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    const y = d.getUTCFullYear();
    const w = String(weekNo).padStart(2, "0");
    return `${y}-W${w}`;
  }

  function prevIsoWeekId(currentId){
    const [yPart, wPart] = currentId.split("-W");
    const y = Number(yPart);
    const w = Number(wPart);
    const jan4 = new Date(Date.UTC(y, 0, 4));
    const dayNum = jan4.getUTCDay() || 7;
    const mondayWeek1 = new Date(jan4);
    mondayWeek1.setUTCDate(jan4.getUTCDate() - (dayNum - 1));
    const mondayTarget = new Date(mondayWeek1);
    mondayTarget.setUTCDate(mondayWeek1.getUTCDate() + (w - 1) * 7);
    mondayTarget.setUTCDate(mondayTarget.getUTCDate() - 7);
    return isoWeekId(new Date(mondayTarget.getUTCFullYear(), mondayTarget.getUTCMonth(), mondayTarget.getUTCDate()));
  }

  function getETParts(date = new Date()) {
    const fmt = new Intl.DateTimeFormat("en-US", {
      timeZone: "America/New_York",
      weekday: "short",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      hour12: false
    });
    const parts = fmt.formatToParts(date);
    const out = {};
    parts.forEach((p) => { out[p.type] = p.value; });
    return {
      weekday: out.weekday || "",
      year: out.year || "1970",
      month: out.month || "01",
      day: out.day || "01",
      hour: Number(out.hour || 0)
    };
  }

  function etDateKey(date = new Date()) {
    const p = getETParts(date);
    return `${p.year}-${p.month}-${p.day}`;
  }

  function isMondayAfterNoonET(date = new Date()) {
    const p = getETParts(date);
    return p.weekday === "Mon" && p.hour >= 12;
  }

  // ---------- Render helpers ----------
  function renderModeChips() {
    modeChipsEl.innerHTML = "";
    const labels = Object.keys(state.modeChecks);

    labels.forEach((label) => {
      const chip = document.createElement("label");
      chip.className = "chip";

      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.checked = !!state.modeChecks[label];
      cb.addEventListener("change", () => {
        state.modeChecks[label] = cb.checked;
        saveState();
        renderWeekSummary();
        debouncedForest(); // dynamic response to daily checkbox changes
      });

      const span = document.createElement("span");
      span.textContent = label;

      const scope = document.createElement("span");
      scope.className = "pill";
      scope.textContent = (state.modeScope?.[label] || "weekly").toUpperCase();

      const del = document.createElement("button");
      del.className = "del";
      del.textContent = "×";
      del.title = "Delete mode";
      del.addEventListener("click", (e) => {
        e.preventDefault();
        delete state.modeChecks[label];
        delete state.modeScope[label];
        saveState();
        renderModeChips();
        renderWeekSummary();
        debouncedForest();
      });

      chip.appendChild(cb);
      chip.appendChild(span);
      chip.appendChild(scope);
      chip.appendChild(del);
      modeChipsEl.appendChild(chip);
    });
  }

  function renderKeystoneDropdown() {
    keystoneTodayEl.innerHTML = "";
    state.courses.forEach((c) => {
      const opt = document.createElement("option");
      opt.value = c;
      opt.textContent = c;
      keystoneTodayEl.appendChild(opt);
    });
    keystoneTodayEl.value = state.keystoneToday || state.courses[0] || "";
  }

  function renderCourseCards() {
    courseCardsEl.innerHTML = "";
    state.courses.forEach((course) => {
      if (!state.courseNotes[course]) {
        state.courseNotes[course] = { status: "steady", focus: "", budget: "", notes: "" };
      }
      const data = state.courseNotes[course];

      const card = document.createElement("div");
      card.className = "card course-card";
      card.style.marginBottom = "10px";

      const title = document.createElement("div");
      title.className = "section-title";
      title.innerHTML = `<h2>${escapeHtml(course)}</h2><div class="hint">bounded notes + focus modes</div>`;
      card.appendChild(title);

      const row = document.createElement("div");
      row.className = "cols";

      const col1 = document.createElement("div");
      col1.innerHTML = `<label>Status</label>`;
      const status = document.createElement("select");
      ["steady","watch","hot","danger"].forEach(s => {
        const opt = document.createElement("option");
        opt.value = s;
        opt.textContent = s;
        status.appendChild(opt);
      });
      status.value = data.status || "steady";
      status.addEventListener("change", () => {
        state.courseNotes[course].status = status.value;
        saveState();
        renderWeekSummary();
        debouncedForest(); // dynamic response to stress changes
      });
      col1.appendChild(status);

      const col2 = document.createElement("div");
      col2.innerHTML = `<label>Focus (this week)</label>`;
      const focus = document.createElement("input");
      focus.type = "text";
      focus.placeholder = "e.g., AOIC quiz prep; Neuro: lecture map; Modeling: tools + first HW";
      focus.value = data.focus || "";
      focus.addEventListener("input", () => {
        state.courseNotes[course].focus = focus.value;
        saveState();
        debouncedGraph();
      });
      col2.appendChild(focus);

      const col3 = document.createElement("div");
      col3.innerHTML = `<label>Block budget</label>`;
      const budget = document.createElement("input");
      budget.type = "text";
      budget.placeholder = "e.g., 1 deep block + 2 light blocks";
      budget.value = data.budget || "";
      budget.addEventListener("input", () => {
        state.courseNotes[course].budget = budget.value;
        saveState();
        debouncedGraph();
      });
      col3.appendChild(budget);

      row.appendChild(col1); row.appendChild(col2); row.appendChild(col3);
      card.appendChild(row);

      const notesLabel = document.createElement("label");
      notesLabel.style.marginTop = "10px";
      notesLabel.textContent = "Notes (what landed / what’s fuzzy / next question)";
      card.appendChild(notesLabel);

      const weeklyBadge = document.createElement("div");
      weeklyBadge.className = "mini";
      weeklyBadge.style.marginTop = "6px";
      card.appendChild(weeklyBadge);

      const notes = document.createElement("textarea");
      notes.value = data.notes || "";
      notes.placeholder = "Keep it short. Capture confusion early.";
      notes.addEventListener("input", () => {
        state.courseNotes[course].notes = notes.value;
        updateWeeklySession(course, notes.value);
        saveState();
        const weekId = isoWeekId(new Date());
        const weekly = weeklyScoreForCourse(course, weekId);
        const todayKey = etDateKey();
        const dayScore = (state.forest.weekly?.courses?.[course]?.days?.[todayKey] || 0);
        weeklyBadge.textContent = `Weekly sessions: ${weekly.sessions}/6 • Today: ${(dayScore * 100).toFixed(0)}%`;
        debouncedForest(); // update forest as you write
        debouncedGraph();
      });
      card.appendChild(notes);

      const weekId = isoWeekId(new Date());
      const weekly = weeklyScoreForCourse(course, weekId);
      const todayKey = etDateKey();
      const dayScore = (state.forest.weekly?.courses?.[course]?.days?.[todayKey] || 0);
      weeklyBadge.textContent = `Weekly sessions: ${weekly.sessions}/6 • Today: ${(dayScore * 100).toFixed(0)}%`;

    courseCardsEl.appendChild(card);
  });
  saveState();
  renderWeekSummary();
  setupCardToggles();
}

  function taskRow(task, listName) {
    const row = document.createElement("div");
    row.className = "task" + (task.done ? " done" : "");

    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.checked = !!task.done;
    cb.addEventListener("change", () => {
      task.done = cb.checked;
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest(); // dynamic response to task completion changes
    });

    const title = document.createElement("input");
    title.type = "text";
    title.className = "title";
    title.value = task.title || "";
    title.placeholder = "Task (bounded, concrete)";
    title.addEventListener("input", () => {
      task.title = title.value;
      saveState();
      debouncedForest();
    });

    title.addEventListener("blur", () => {
      if (!String(task.title || "").trim()) toast("Task title is empty (export will mark as untitled).");
    });

    const course = document.createElement("select");
    state.courses.forEach((c) => {
      const opt = document.createElement("option");
      opt.value = c;
      opt.textContent = c;
      course.appendChild(opt);
    });
    course.value = task.course || state.courses[0];
    course.addEventListener("change", () => {
      task.course = course.value;
      saveState();
      renderWeekSummary();
      debouncedForest();
    });

    const mode = document.createElement("select");
    const modes = Object.keys(state.modeChecks);
    ["(mode)", ...modes].forEach((m) => {
      const opt = document.createElement("option");
      opt.value = m;
      opt.textContent = m;
      mode.appendChild(opt);
    });
    mode.value = task.mode || "(mode)";
    mode.addEventListener("change", () => {
      task.mode = mode.value;
      saveState();
      debouncedForest();
    });

    const del = document.createElement("button");
    del.className = "del";
    del.textContent = "×";
    del.title = "Delete";
    del.addEventListener("click", () => {
      state[listName] = state[listName].filter((t) => t.id !== task.id);
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
    });

    row.appendChild(cb);
    row.appendChild(title);
    row.appendChild(course);
    row.appendChild(mode);
    row.appendChild(del);
    return row;
  }

  function renderTasks() {
    todayTasksEl.innerHTML = "";
    state.todayTasks.forEach((t) => todayTasksEl.appendChild(taskRow(t, "todayTasks")));

    weekendTasksEl.innerHTML = "";
    state.weekendTasks.forEach((t) => weekendTasksEl.appendChild(taskRow(t, "weekendTasks")));
  }

  // ---------- Card focus ----------
  let expandedCard = null;

  function setCardFocus(card, active) {
    const cards = Array.from(document.querySelectorAll(".card"));
    const containerCard = card?.parentElement?.closest(".card");
    if (active) {
      expandedCard = card;
      document.body.classList.add("card-focus");
      cards.forEach((c) => {
        const keepClear = c === card || c === containerCard;
        c.classList.toggle("expanded", c === card);
        c.classList.toggle("dimmed", !keepClear);
      });
      const btn = card.querySelector(".card-toggle");
      if (btn) btn.textContent = "Collapse";
    } else {
      expandedCard = null;
      document.body.classList.remove("card-focus");
      cards.forEach((c) => c.classList.remove("expanded", "dimmed"));
      cards.forEach((c) => {
        const btn = c.querySelector(".card-toggle");
        if (btn) btn.textContent = "Focus";
      });
    }
  }

  function setupCardToggles() {
    const cards = document.querySelectorAll(".card");
    cards.forEach((card) => {
      if (card.querySelector(".card-toggle")) return;
      const btn = document.createElement("button");
      btn.className = "card-toggle";
      btn.type = "button";
      btn.textContent = "Focus";
      btn.addEventListener("click", (e) => {
        e.preventDefault();
        const isActive = card.classList.contains("expanded");
        setCardFocus(card, !isActive);
      });
      card.appendChild(btn);
    });
  }

  // ---------- Concept graph ----------
  let graphState = null;
  let graphSpacing = 4.5;

  function collectWritingCorpus() {
    const parts = [];
    if (state.todayNotes) parts.push(state.todayNotes);
    state.courses.forEach((course) => {
      const c = state.courseNotes[course] || {};
      if (c.focus) parts.push(c.focus);
      if (c.budget) parts.push(c.budget);
      if (c.notes) parts.push(c.notes);
    });
    if (state.writingSchedule) parts.push(state.writingSchedule);
    if (state.writingThread) parts.push(state.writingThread);
    if (state.writingTargets) parts.push(state.writingTargets);
    if (state.writingNotes) parts.push(state.writingNotes);
    if (state.proseSchedule) parts.push(state.proseSchedule);
    if (state.proseProject) parts.push(state.proseProject);
    if (state.proseTargets) parts.push(state.proseTargets);
    if (state.proseNotes) parts.push(state.proseNotes);
    return normalizeText(parts.join(" "));
  }

  function computeConceptGraph() {
    const corpus = collectWritingCorpus();
    if (!corpus) return { nodes: [], edges: [] };
    const keywords = topNWords(corpus, 16).map(x => x.w);
    const nodes = keywords.map((w) => ({
      id: w,
      label: w,
      x: (Math.random() - 0.5) * graphSpacing,
      y: (Math.random() - 0.5) * graphSpacing,
      z: (Math.random() - 0.5) * graphSpacing,
      size: 2
    }));
    const edges = [];
    const sentences = splitSentences(corpus);
    const keywordSet = new Set(keywords);
    const edgeMap = new Map();

    sentences.forEach((sentence) => {
      const words = contentWords(sentence);
      const present = Array.from(new Set(words.filter((w) => keywordSet.has(w))));
      for (let i = 0; i < present.length; i++) {
        for (let j = i + 1; j < present.length; j++) {
          const key = [present[i], present[j]].sort().join("|");
          edgeMap.set(key, (edgeMap.get(key) || 0) + 1);
        }
      }
    });

    const degree = new Map();
    for (const [pair, weight] of edgeMap.entries()) {
      const [a, b] = pair.split("|");
      edges.push({ a, b, weight });
      degree.set(a, (degree.get(a) || 0) + weight);
      degree.set(b, (degree.get(b) || 0) + weight);
    }

    nodes.forEach((node) => {
      node.size = 2;
    });

    return { nodes, edges };
  }

  function projectPoint(node, rotX, rotY, zoom, w, h) {
    let { x, y, z } = node;
    const cosY = Math.cos(rotY);
    const sinY = Math.sin(rotY);
    const cosX = Math.cos(rotX);
    const sinX = Math.sin(rotX);

    const dx = x * cosY - z * sinY;
    const dz = x * sinY + z * cosY;
    const dy = y * cosX - dz * sinX;
    const dz2 = y * sinX + dz * cosX;

    const perspective = zoom / (zoom + dz2 + 2.2);
    return {
      x: w / 2 + dx * w * 0.25 * perspective,
      y: h / 2 + dy * h * 0.25 * perspective,
      scale: perspective
    };
  }

  function renderConceptGraph() {
    if (!conceptGraphCanvas) return;
    if (!graphState) {
      graphState = {
        data: computeConceptGraph(),
        rotX: -0.25,
        rotY: 0.25,
        zoom: 2.4,
        dragging: false,
        lastX: 0,
        lastY: 0
      };
      attachGraphHandlers();
      requestAnimationFrame(drawConceptGraph);
    } else {
      graphState.data = computeConceptGraph();
    }
  }

  function drawConceptGraphFrame() {
    if (!conceptGraphCanvas || !graphState) return;
    const { ctx, w, h } = initCanvasHiDPI(conceptGraphCanvas);
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = getCSSVar("--panel");
    ctx.fillRect(0, 0, w, h);

    const { nodes, edges } = graphState.data;
    if (!nodes.length) {
      ctx.fillStyle = "#8b8c9b";
      ctx.font = "12px " + getCSSVar("--sans");
      ctx.textAlign = "center";
      ctx.fillText("No writing data yet to generate concepts.", w / 2, h / 2);
      return;
    }

    const projections = new Map();
    nodes.forEach((node) => {
      projections.set(node.id, projectPoint(node, graphState.rotX, graphState.rotY, graphState.zoom, w, h));
    });

    ctx.strokeStyle = "rgba(58,61,94,0.25)";
    edges.forEach((edge) => {
      const a = projections.get(edge.a);
      const b = projections.get(edge.b);
      if (!a || !b) return;
      ctx.lineWidth = Math.max(0.6, edge.weight * 0.6);
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();
    });

    nodes.forEach((node) => {
      const p = projections.get(node.id);
      if (!p) return;
      const radius = node.size * p.scale;
      ctx.fillStyle = "#111111";
      ctx.beginPath();
      ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#111111";
      ctx.font = `${Math.max(9, 10 * p.scale)}px ${getCSSVar("--sans")}`;
      ctx.textAlign = "center";
      ctx.fillText(node.label, p.x, p.y - radius - 4);
    });
  }

  function attachGraphHandlers() {
    conceptGraphCanvas.addEventListener("mousedown", (e) => {
      graphState.dragging = true;
      graphState.lastX = e.clientX;
      graphState.lastY = e.clientY;
    });
    window.addEventListener("mouseup", () => {
      if (graphState) graphState.dragging = false;
    });
    window.addEventListener("mousemove", (e) => {
      if (!graphState?.dragging) return;
      const dx = e.clientX - graphState.lastX;
      const dy = e.clientY - graphState.lastY;
      graphState.rotY += dx * 0.005;
      graphState.rotX += dy * 0.005;
      graphState.lastX = e.clientX;
      graphState.lastY = e.clientY;
    });
    conceptGraphCanvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      graphState.zoom = clamp(graphState.zoom + e.deltaY * 0.004, 1.0, 10);
    }, { passive: false });
    btnRegenGraph?.addEventListener("click", () => {
      graphState.data = computeConceptGraph();
      toast("Regenerated concept graph");
    });
    graphSpacingEl?.addEventListener("input", () => {
      graphSpacing = Number(graphSpacingEl.value) || 1.6;
      graphState.data = computeConceptGraph();
    });
  }

  function drawConceptGraph() {
    if (!conceptGraphCanvas || !graphState) return;
    drawConceptGraphFrame();
    graphState.rotY += 0.0015;
    requestAnimationFrame(drawConceptGraph);
  }

  // ---------- Week summary ----------
  function renderWeekSummary() {
    const openToday = state.todayTasks.filter(t => !t.done).length;
    const openWeekend = state.weekendTasks.filter(t => !t.done).length;
    const doneToday = state.todayTasks.filter(t => t.done).length;
    const doneWeekend = state.weekendTasks.filter(t => t.done).length;

    const flagged = state.courses
      .map(c => ({ course: c, status: (state.courseNotes[c] || {}).status || "steady" }))
      .filter(x => x.status === "hot" || x.status === "danger");

    const keystone = state.keystoneToday || "";
    const keystoneOpen = state.todayTasks.filter(t => !t.done && t.course === keystone).length;

    const dailyTotal = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="daily").length || 1;
    const weeklyTotal = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="weekly").length || 1;

    const dailyChecked = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="daily" && state.modeChecks[k]).length;
    const weeklyChecked = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="weekly" && state.modeChecks[k]).length;

    const lines = [];
    lines.push(`Open tasks: <b>${openToday + openWeekend}</b> (Today ${openToday}, Weekend ${openWeekend})`);
    lines.push(`Completed tasks: ${doneToday + doneWeekend} (Today ${doneToday}, Weekend ${doneWeekend})`);
    lines.push(`Keystone: <b>${escapeHtml(keystone)}</b> — open today tasks in keystone: <b>${keystoneOpen}</b>`);
    lines.push(`Modes checked: daily ${dailyChecked}/${dailyTotal} • weekly ${weeklyChecked}/${weeklyTotal}`);

    if (flagged.length) {
      const list = flagged.map(x => `${escapeHtml(x.course)}: <code>${escapeHtml(x.status)}</code>`).join(" • ");
      lines.push(`Flagged courses: <b>${flagged.length}</b> — ${list}`);
    } else {
      lines.push(`Flagged courses: 0`);
    }

    weekSummaryEl.innerHTML = `<div style="display:grid;gap:6px;">${lines.map(x => `<div>${x}</div>`).join("")}</div>`;
    debouncedForest();
  }

  // ---------- Markdown generation ----------
  function mdCheckbox(label, checked) {
    return `- [${checked ? "x" : " "}] ${label}`;
  }

  function obsidianLink(name) {
    const safe = String(name || "").replaceAll("]","\\]");
    return `[[${safe}]]`;
  }

  function slugTag(word) {
    return String(word || "")
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/^-+|-+$/g, "");
  }

  const KEYWORD_SKIP = new Set([
    "make","made","making","made","need","needs","needed","want","wants","wanted",
    "good","better","best","bad","worse","worst","thing","things","stuff","like",
    "use","used","using","get","got","getting","should","could","would","might"
  ]);

  function titleCase(word) {
    const s = String(word || "");
    return s ? s[0].toUpperCase() + s.slice(1) : "";
  }

  function keyPhrases(text, n = 6) {
    const sentences = splitSentences(text);
    const freq = new Map();
    sentences.forEach((sentence) => {
      const words = contentWords(sentence);
      for (let i = 0; i < words.length; i++) {
        for (let size = 2; size <= 4; size++) {
          const slice = words.slice(i, i + size);
          if (slice.length < size) continue;
          const phrase = slice.join(" ");
          if (KEYWORD_SKIP.has(phrase)) continue;
          freq.set(phrase, (freq.get(phrase) || 0) + 1);
        }
      }
    });
    return Array.from(freq.entries())
      .sort((a, b) => b[1] - a[1])
      .map(([phrase]) => phrase)
      .slice(0, n);
  }

  function extractAcademicAnchors(text) {
    const anchors = [
      "1900s",
      "20th century",
      "continental philosophy",
      "structuralist mathematics",
      "theoretical biology",
      "set theory",
      "computation theory",
      "neurophysiology",
      "neuroecology",
      "systems theory",
      "phenomenology",
      "network epistemology",
      "cybernetics",
      "semiotics",
      "complex systems",
      "systems neuroscience",
      "information theory"
    ];
    const lower = String(text || "").toLowerCase();
    const hits = anchors.filter(a => lower.includes(a));
    return hits.map((t) => `#${slugTag(t)}`);
  }

  function tokenizeWords(text) {
    const norm = normalizeText(text);
    if (!norm) return [];
    return norm.split(/\s+/).filter(Boolean).filter(w => !STOP.has(w));
  }

  function extractSentences(text) {
    return splitSentences(text);
  }

  function sentenceScore(sentence, keywords) {
    const words = contentWords(sentence);
    if (!words.length) return 0;
    const lenScore = clamp(words.length / 20, 0, 1);
    let keyHits = 0;
    const lower = sentence.toLowerCase();
    keywords.forEach((k) => { if (lower.includes(k.toLowerCase())) keyHits += 1; });
    const keyScore = keywords.length ? clamp(keyHits / keywords.length, 0, 1) : 0;
    const structureScore = /[;:]/.test(sentence) ? 0.15 : 0;
    return lenScore + keyScore + structureScore;
  }

  function extractConceptSentences(text, n = 3) {
    const sentences = extractSentences(text);
    if (!sentences.length) return [];
    const keywords = topNWords(normalizeText(text), 8).map(x => x.w);
    const scored = sentences.map(s => ({ s, score: sentenceScore(s, keywords) }));
    return scored.sort((a, b) => b.score - a.score).map(x => x.s).slice(0, n);
  }

  function titleFromSentence(sentence) {
    const words = contentWords(sentence).slice(0, 6).map(titleCase);
    return words.length ? words.join(" ") : "Untitled Note";
  }

  function buildNoteAnalysis(noteText) {
    const concepts = extractConceptSentences(noteText, 3).map((s) => {
      const trimmed = s.trim();
      return trimmed.length > 160 ? `${trimmed.slice(0, 157)}…` : trimmed;
    });
    const title = concepts.length ? titleFromSentence(concepts[0]) : "Untitled Note";
    const anchors = [
      ...new Set([
        ...formatProperNounTags(noteText),
        ...extractAcademicAnchors(noteText)
      ])
    ];
    return { title, concepts, anchors };
  }

  function noteKeywords(text, n = 6) {
    return keyPhrases(text, n);
  }

  function titleCasePhrase(phrase) {
    return phrase.split(" ").map(titleCase).join(" ");
  }

  function noteTitleFromKeywords(keywords) {
    if (!keywords.length) return "Untitled Note";
    return keywords.slice(0, 2).map(titleCasePhrase).join(" · ");
  }

  function extractProperNouns(text, n = 6) {
    const raw = String(text || "");
    const matches = raw.match(/\b(?:[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\b/g) || [];
    const extras = raw.match(/\b\d{1,2}(?:st|nd|rd|th)\s+century\b/gi) || [];
    const seen = new Set();
    const out = [];
    [...matches, ...extras].forEach((m) => {
      const cleaned = m.trim();
      if (!cleaned || cleaned.length < 3) return;
      if (STOP.has(cleaned.toLowerCase())) return;
      const key = cleaned.toLowerCase();
      if (!seen.has(key)) {
        seen.add(key);
        out.push(cleaned);
      }
    });
    return out.slice(0, n);
  }

  function formatProperNounTags(text) {
    return extractProperNouns(text, 8)
      .map((name) => slugTag(name))
      .filter(Boolean)
      .map((tag) => `#${tag}`);
  }

  function percent(n) {
    return `${Math.round(n * 100)}%`;
  }

  function forestPngDataUrl(scale = 1, mime = "image/jpeg", quality = 0.92) {
    try {
      renderForest();
      const src = forestCanvas;
      if (!src) return "";
      const rect = src.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width));
      const h = Math.max(1, Math.floor(rect.height));
      const tmp = document.createElement("canvas");
      tmp.width = Math.floor(w * scale);
      tmp.height = Math.floor(h * scale);
      const tctx = tmp.getContext("2d");
      tctx.fillStyle = "#ffffff";
      tctx.fillRect(0, 0, tmp.width, tmp.height);
      tctx.drawImage(src, 0, 0, w, h, 0, 0, tmp.width, tmp.height);
      return mime === "image/png" ? tmp.toDataURL(mime) : tmp.toDataURL(mime, quality);
    } catch {
      return "";
    }
  }

  function conceptGraphPngDataUrl(scale = 1, mime = "image/jpeg", quality = 0.92) {
    try {
      if (!conceptGraphCanvas) return "";
      renderConceptGraph();
      if (graphState) drawConceptGraphFrame();
      const src = conceptGraphCanvas;
      const rect = src.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width));
      const h = Math.max(1, Math.floor(rect.height));
      const tmp = document.createElement("canvas");
      tmp.width = Math.floor(w * scale);
      tmp.height = Math.floor(h * scale);
      const tctx = tmp.getContext("2d");
      tctx.fillStyle = "#ffffff";
      tctx.fillRect(0, 0, tmp.width, tmp.height);
      tctx.drawImage(src, 0, 0, w, h, 0, 0, tmp.width, tmp.height);
      return mime === "image/png" ? tmp.toDataURL(mime) : tmp.toDataURL(mime, quality);
    } catch {
      return "";
    }
  }

  function wrapTextLines(ctx, text, maxWidth) {
    const words = String(text || "").split(/\s+/);
    const lines = [];
    let line = "";
    words.forEach((word) => {
      const next = line ? `${line} ${word}` : word;
      if (ctx.measureText(next).width > maxWidth && line) {
        lines.push(line);
        line = word;
      } else {
        line = next;
      }
    });
    if (line) lines.push(line);
    return lines;
  }

  function buildLegendGridRows(perCourse, courses, weekId) {
    return courses.map((course) => {
      const m = perCourse[course] || {};
      const notes = state.courseNotes?.[course]?.notes || "";
      const words = wordCount(notes);
      const punctCount = (notes.match(/[.,;:!?]/g) || []).length;
      const sentences = splitSentences(notes);
      const syntax = words ? Math.min(1, (punctCount / words) * 8) : 0;
      const cohesionHits = (notes.match(/\b(and|but|because|however|therefore|thus|so)\b/gi) || []).length;
      const cohesion = sentences.length ? Math.min(1, cohesionHits / Math.max(1, sentences.length)) : 0;
      const avgSentenceLen = sentences.length ? (words / sentences.length) : 0;
      const noteWords = contentWords(notes);
      const uniqueRatio = noteWords.length ? (new Set(noteWords)).size / noteWords.length : 0;
      const diversityN = clamp(uniqueRatio, 0, 1);
      const keywordCount = courseKeywords(course).size;
      const phraseCount = keyPhrases(notes, 8).length;
      const conceptN = clamp((keywordCount / 12 + phraseCount / 6 + cohesion) / 3, 0, 1);
      const properCount = extractProperNouns(notes, 50).length;
      const punctuationPerWord = words ? (punctCount / words) : 0;
      const stress = m.stress || 0;
      const tasks = m.tasks || 0;
      const weekly = weeklyScoreForCourse(course, weekId);
      const status = (state.courseNotes?.[course]?.status || "steady");
      return {
        title: `${course} (${status})`,
        lines: [
          `Words ${words} • SentLen ${avgSentenceLen.toFixed(1)} • Punct ${(punctuationPerWord * 100).toFixed(1)}%`,
          `Syntax ${(syntax * 100).toFixed(1)}% • Cohesion ${(cohesion * 100).toFixed(1)}% • Diversity ${(diversityN * 100).toFixed(1)}%`,
          `Concepts ${keywordCount} • Phrases ${phraseCount} • Proper ${properCount}`,
          `Tasks ${tasks} • Stress ${(stress * 100).toFixed(1)}% • Linkage ${(conceptN * 100).toFixed(1)}%`,
          `Weekly ${weekly.sessions}/6 • Score ${(weekly.score * 100).toFixed(1)}%`
        ]
      };
    });
  }

  function forestCardDataUrl(mime = "image/jpeg", quality = 0.92, scale = 1) {
    try {
      renderForest();
      const src = forestCanvas;
      if (!src) return "";
      const rect = src.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width));
      const h = Math.max(1, Math.floor(rect.height));
      const { perCourse, weekId } = computeForestMetrics();
      const rows = buildLegendGridRows(perCourse, state.courses || [], weekId);
      const cols = w > 960 ? 3 : (w > 640 ? 2 : 1);
      const cellW = Math.floor(w / cols);
      const lineH = 14;
      const cellPad = 10;
      const cellHeight = 6 * lineH + 20;
      const legendRows = Math.max(1, Math.ceil(rows.length / cols));
      const legendHeight = legendRows * cellHeight + cellPad;
      const totalH = h + legendHeight;

      const tmp = document.createElement("canvas");
      tmp.width = Math.max(1, Math.floor(w * scale));
      tmp.height = Math.max(1, Math.floor(totalH * scale));
      const ctx = tmp.getContext("2d");
      ctx.scale(scale, scale);
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, w, totalH);
      ctx.drawImage(src, 0, 0, w, h, 0, 0, w, h);

      ctx.fillStyle = "#111111";
      ctx.font = `12px ${getCSSVar("--sans")}`;
      const startY = h + cellPad;
      const maxTextWidth = (cellW - cellPad * 2) * scale;
      rows.forEach((row, idx) => {
        const col = idx % cols;
        const r = Math.floor(idx / cols);
        const x = col * cellW + cellPad;
        const y = startY + r * cellHeight;
        ctx.font = `12px ${getCSSVar("--sans")}`;
        ctx.fillText(row.title, x, y + 12);
        ctx.font = `11px ${getCSSVar("--sans")}`;
        row.lines.forEach((line, i) => {
          const lines = wrapTextLines(ctx, line, maxTextWidth);
          lines.forEach((l, li) => {
            const yy = y + 28 + (i * lineH) + (li * lineH);
            if (yy < y + cellHeight - 4) ctx.fillText(l, x, yy);
          });
        });
      });
      return mime === "image/png" ? tmp.toDataURL(mime) : tmp.toDataURL(mime, quality);
    } catch {
      return "";
    }
  }

  function formatDelta(delta) {
    const pct = Math.round(delta * 100);
    if (!pct) return "0%";
    return `${pct > 0 ? "+" : ""}${pct}%`;
  }

  function crc32(buf) {
    const table = crc32.table || (crc32.table = (() => {
      const t = new Uint32Array(256);
      for (let i = 0; i < 256; i++) {
        let c = i;
        for (let k = 0; k < 8; k++) {
          c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
        }
        t[i] = c >>> 0;
      }
      return t;
    })());
    let crc = 0xFFFFFFFF;
    for (let i = 0; i < buf.length; i++) {
      crc = table[(crc ^ buf[i]) & 0xFF] ^ (crc >>> 8);
    }
    return (crc ^ 0xFFFFFFFF) >>> 0;
  }

  function textToUint8(text) {
    return new TextEncoder().encode(text);
  }

  function dataUrlToUint8(dataUrl) {
    const [meta, data] = dataUrl.split(",");
    const isBase64 = meta.includes(";base64");
    if (!isBase64) return textToUint8(decodeURIComponent(data));
    const bin = atob(data);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
    return arr;
  }

  function zipFiles(files) {
    const records = [];
    let offset = 0;

    files.forEach((file) => {
      const nameBytes = textToUint8(file.name);
      const data = file.data;
      const crc = crc32(data);
      const localHeader = new Uint8Array(30 + nameBytes.length);
      const view = new DataView(localHeader.buffer);
      view.setUint32(0, 0x04034b50, true);
      view.setUint16(4, 20, true);
      view.setUint16(6, 0, true);
      view.setUint16(8, 0, true);
      view.setUint16(10, 0, true);
      view.setUint16(12, 0, true);
      view.setUint32(14, crc, true);
      view.setUint32(18, data.length, true);
      view.setUint32(22, data.length, true);
      view.setUint16(26, nameBytes.length, true);
      view.setUint16(28, 0, true);
      localHeader.set(nameBytes, 30);

      const centralHeader = new Uint8Array(46 + nameBytes.length);
      const cview = new DataView(centralHeader.buffer);
      cview.setUint32(0, 0x02014b50, true);
      cview.setUint16(4, 20, true);
      cview.setUint16(6, 20, true);
      cview.setUint16(8, 0, true);
      cview.setUint16(10, 0, true);
      cview.setUint16(12, 0, true);
      cview.setUint16(14, 0, true);
      cview.setUint32(16, crc, true);
      cview.setUint32(20, data.length, true);
      cview.setUint32(24, data.length, true);
      cview.setUint16(28, nameBytes.length, true);
      cview.setUint16(30, 0, true);
      cview.setUint16(32, 0, true);
      cview.setUint16(34, 0, true);
      cview.setUint16(36, 0, true);
      cview.setUint32(38, 0, true);
      cview.setUint32(42, offset, true);
      centralHeader.set(nameBytes, 46);

      records.push({ localHeader, data, centralHeader });
      offset += localHeader.length + data.length;
    });

    const centralSize = records.reduce((sum, r) => sum + r.centralHeader.length, 0);
    const end = new Uint8Array(22);
    const endView = new DataView(end.buffer);
    endView.setUint32(0, 0x06054b50, true);
    endView.setUint16(4, 0, true);
    endView.setUint16(6, 0, true);
    endView.setUint16(8, records.length, true);
    endView.setUint16(10, records.length, true);
    endView.setUint32(12, centralSize, true);
    endView.setUint32(16, offset, true);
    endView.setUint16(20, 0, true);

    const totalSize = offset + centralSize + end.length;
    const out = new Uint8Array(totalSize);
    let ptr = 0;
    records.forEach((r) => {
      out.set(r.localHeader, ptr);
      ptr += r.localHeader.length;
      out.set(r.data, ptr);
      ptr += r.data.length;
    });
    records.forEach((r) => {
      out.set(r.centralHeader, ptr);
      ptr += r.centralHeader.length;
    });
    out.set(end, ptr);
    return out;
  }

  function downloadBlob(filename, blob) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function downloadText(filename, text, mime = "text/plain") {
    const blob = new Blob([text], { type: mime });
    downloadBlob(filename, blob);
  }

  function downloadDataUrl(filename, dataUrl) {
    const a = document.createElement("a");
    a.href = dataUrl;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  function forestToSVG(geom) {
    if (!geom) return "";
    const w = Math.max(1, Math.round(geom.width || 1));
    const h = Math.max(1, Math.round(geom.height || 1));
    const parts = [
      `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">`,
      `<rect width="100%" height="100%" fill="white"/>`
    ];

    geom.trees.forEach((tree) => {
      tree.paths.forEach((p) => {
        if (p.type === "circle") {
          const stroke = p.stroke || "#3a3d5e";
          const sw = p.sw || 1;
          const fill = p.fill || "none";
          const alpha = p.alpha ?? 1;
          parts.push(
            `<circle cx="${p.cx}" cy="${p.cy}" r="${p.r}" stroke="${stroke}" stroke-width="${sw}" fill="${fill}" opacity="${alpha}"/>`
          );
        } else if (p.d) {
          const stroke = p.stroke || "#3a3d5e";
          const sw = p.sw || 1;
          const alpha = p.alpha ?? 1;
          parts.push(
            `<path d="${p.d}" stroke="${stroke}" stroke-width="${sw}" fill="none" opacity="${alpha}"/>`
          );
        } else if (typeof p.x1 === "number") {
          const stroke = p.stroke || "#3a3d5e";
          const sw = p.sw || 1;
          const alpha = p.alpha ?? 1;
          parts.push(
            `<line x1="${p.x1}" y1="${p.y1}" x2="${p.x2}" y2="${p.y2}" stroke="${stroke}" stroke-width="${sw}" opacity="${alpha}"/>`
          );
        }
      });
    });

    parts.push("</svg>");
    return parts.join("");
  }

  function wordCount(text) {
    return String(text || "").trim().split(/\s+/).filter(Boolean).length;
  }

  function enforceWordCount(text, target) {
    let words = String(text || "").trim().split(/\s+/).filter(Boolean);
    const filler = [
      "The argument would benefit from clearer operational definitions and a sharper distinction between descriptive claims and interpretive stakes.",
      "Methodologically, a tighter articulation of evidence warrants would strengthen the transition from observation to inference.",
      "The conceptual framing aligns with literature on knowledge-building communities and warrants further triangulation with empirical traces.",
      "I encourage foregrounding how the analytic lens translates into concrete revision decisions for the next iteration."
    ];
    let i = 0;
    while (words.length < target) {
      words = words.concat(filler[i % filler.length].split(/\s+/));
      i += 1;
    }
    if (words.length > target) words = words.slice(0, target);
    return words.join(" ");
  }

  const RESPONDENT_CANON = [
    "Alain Badiou", "Joan Copjec", "Slavoj Zizek", "Alexander Galloway",
    "Sarah Pourciau", "Anil Bawa Cavvia", "Leif Weatherby", "Reza Negarestani",
    "Luciana Parisi", "Gualtieri Piccinini", "Katherine Hayles", "Mary Tiles",
    "Jose Ferreiros", "Denise Ferreira da Silva", "Fermin Fulda",
    "Stewart A. Newman", "Michael Heinrich", "Bruce Fink", "Bracha Ettinger"
  ];

  function bestSentenceFromText(text) {
    const sentences = extractConceptSentences(text, 1);
    return sentences[0] || "";
  }

  function summaryCorpusFromState() {
    const parts = [];
    if (state.todayNotes) parts.push(`Today notes: ${state.todayNotes}`);
    state.courses.forEach((course) => {
      const c = state.courseNotes?.[course] || {};
      if (c.focus) parts.push(`${course} focus: ${c.focus}`);
      if (c.notes) parts.push(`${course} notes: ${c.notes}`);
    });
    if (state.writingThread) parts.push(`GCAS thread: ${state.writingThread}`);
    if (state.writingNotes) parts.push(`GCAS notes: ${state.writingNotes}`);
    if (state.proseProject) parts.push(`Prose project: ${state.proseProject}`);
    if (state.proseNotes) parts.push(`Prose notes: ${state.proseNotes}`);
    return parts.join("\n");
  }

  async function callOpenAI(messages, temperature = 0.5) {
    const key = (state.llmKey || "").trim();
    if (!key) throw new Error("Missing OpenAI API key");
    const res = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${key}`
      },
      body: JSON.stringify({
        model: "gpt-4o-mini",
        temperature,
        messages
      })
    });
    if (!res.ok) {
      const err = await res.json().catch(() => ({}));
      throw new Error(err?.error?.message || `OpenAI error ${res.status}`);
    }
    const data = await res.json();
    return (data.choices?.[0]?.message?.content || "").trim();
  }

  async function generateGptConferenceResponse() {
    const corpus = summaryCorpusFromState();
    if (!corpus) return "";
    const prompt = [
      "You are a conference respondent writing in the third person.",
      "Write ~300 words responding to the notes and writing below.",
      "Assess significance, gaps, and improvements; name intellectual origins and contexts.",
      "Keep it rigorous and non-affirmational. Avoid first-person voice.",
      `Audience horizon: ${RESPONDENT_CANON.join(", ")}.`,
      "Fields: Set Theory, Biological Modeling, Computation Theory, Neurophysiology, Neuroecology.",
      "Notes:\n" + corpus
    ].join("\n");
    return callOpenAI([{ role: "user", content: prompt }], 0.55);
  }

  async function analyzeNotesWithGpt(course, noteText) {
    if (!noteText || !noteText.trim()) return null;
    const prompt = [
      "Return strict JSON only (no markdown).",
      "Fields: title (string), key_concepts (array of 3 short sentences), academic_anchors (array of short tags).",
      "Title should be 3-8 words. Concepts should be short sentences.",
      `Course: ${course}`,
      `Notes: ${noteText}`
    ].join("\n");
    const raw = await callOpenAI([{ role: "user", content: prompt }], 0.3);
    try {
      const parsed = JSON.parse(raw);
      return {
        title: String(parsed.title || ""),
        concepts: Array.isArray(parsed.key_concepts) ? parsed.key_concepts.map(String) : [],
        anchors: Array.isArray(parsed.academic_anchors) ? parsed.academic_anchors.map(String) : []
      };
    } catch {
      return null;
    }
  }

  function buildConferenceResponse(context) {
    const keywords = context.keywords.length ? context.keywords.join(", ") : "core concepts";
    const linkage = context.linkages.length ? context.linkages.join("; ") : "the dominant nodes cohere around a small set of recurring ideas";
    const keystone = context.keystone || "the keystone course";
    const sentences = [
      `The archive reads as a coherent semester-long knowledge-building project with ${keystone} functioning as the main organizing axis.`,
      `Across the corpus, the dominant conceptual signals include ${keywords}, which recur in ways that suggest a stable thematic spine rather than a loose topical drift.`,
      `The linkage structure is consistent with a networked-learning model in which local ideas are continuously reactivated and recombined: ${linkage}.`,
      `From the standpoint of cognitive load theory, the alternation between consolidation and expansion is healthy, and the current pattern indicates productive strain rather than overload.`,
      `The forest narrative of complexity is instructive here: ${context.complexityTrend} ${context.distribution}`,
      `In terms of writing studies and genre theory, the project reads like a movement from exploratory synthesis toward a more situated, audience-aware register.`,
      `Conceptual change is visible: the notes do not merely add facts but repeatedly reconfigure explanatory frames.`,
      `If the work is situated within systems thinking and activity theory, the most promising thread is the way methods, concepts, and tasks mutually condition one another rather than sitting in isolation.`,
      `A stronger through-line that names the central problem space and ties new observations back to it would sharpen the interpretive center without constraining generative divergence.`,
      `The prose and GCAS sessions read as complementary modes: one scaffolds analytical precision, the other opens narrative distance that helps integrate learning.`
    ];
    return enforceWordCount(sentences.join(" "), 300);
  }

  function generateMarkdown(opts = {}) {
    const d = new Date();
    const dateISO = d.toISOString().slice(0,10);
    const dateStr = d.toLocaleDateString(undefined, { weekday:"long", year:"numeric", month:"long", day:"numeric" });

    const { perCourse, mode, weekId } = computeForestMetrics();
    const courseList = state.courses || [];
    const doneToday = state.todayTasks.filter(t => t.done).length;
    const doneWeekend = state.weekendTasks.filter(t => t.done).length;
    const totalToday = state.todayTasks.length;
    const totalWeekend = state.weekendTasks.length;
    const totalTasks = totalToday + totalWeekend;
    const doneTotal = doneToday + doneWeekend;
    const completionRate = totalTasks ? (doneTotal / totalTasks) : 0;
    const writingText = normalizeText([state.writingSchedule, state.writingThread, state.writingTargets, state.writingNotes].filter(Boolean).join(" "));
    const proseText = normalizeText([state.proseSchedule, state.proseProject, state.proseTargets, state.proseNotes].filter(Boolean).join(" "));

    const perCourseMax = state.forest.perCourseMax || {};
    const averages = courseList.length
      ? courseList.reduce((acc, course) => {
        const cur = perCourse[course] || {};
        const max = perCourseMax[course] || {};
        acc.words += cur.words || 0;
        acc.syntax += cur.syntax || 0;
        acc.cohesion += cur.cohesion || 0;
        acc.tasks += cur.tasks || 0;
        acc.maxWords += max.words || 0;
        acc.maxSyntax += max.syntax || 0;
        acc.maxCohesion += max.cohesion || 0;
        acc.maxTasks += max.tasks || 0;
        return acc;
      }, { words: 0, syntax: 0, cohesion: 0, tasks: 0, maxWords: 0, maxSyntax: 0, maxCohesion: 0, maxTasks: 0 })
      : { words: 0, syntax: 0, cohesion: 0, tasks: 0, maxWords: 0, maxSyntax: 0, maxCohesion: 0, maxTasks: 0 };

    const avgWords = courseList.length ? averages.words / courseList.length : 0;
    const avgSyntax = courseList.length ? averages.syntax / courseList.length : 0;
    const avgCohesion = courseList.length ? averages.cohesion / courseList.length : 0;

    const avgMaxWords = courseList.length ? averages.maxWords / courseList.length : 0;
    const avgMaxSyntax = courseList.length ? averages.maxSyntax / courseList.length : 0;
    const avgMaxCohesion = courseList.length ? averages.maxCohesion / courseList.length : 0;

    const complexityTrend = avgMaxWords + avgMaxSyntax + avgMaxCohesion
      ? formatDelta(((avgWords + avgSyntax + avgCohesion) - (avgMaxWords + avgMaxSyntax + avgMaxCohesion)) / ((avgMaxWords + avgMaxSyntax + avgMaxCohesion) || 1))
      : "0%";

    const distribution = courseList.length
      ? (() => {
        const high = courseList.filter(c => (perCourse[c]?.stress || 0) >= 0.66).length;
        const low = courseList.filter(c => (perCourse[c]?.stress || 0) <= 0.33).length;
        const mid = courseList.length - high - low;
        return `Stress distribution: ${high} hot / ${mid} warm / ${low} steady.`;
      })()
      : "Stress distribution: 0 hot / 0 warm / 0 steady.";

    const keywords = topNWords(writingText, 6).map(x => titleCase(x.w));
    const linkages = keyPhrases(writingText, 6).map(titleCasePhrase);
    const confResponse = state.llmConferenceResponse || buildConferenceResponse({
      keywords,
      linkages,
      keystone: state.keystoneToday || "",
      complexityTrend,
      distribution
    });

    const forestFilename = opts.forestFilename || "forest.jpg";
    const graphFilename = opts.graphFilename || "concept_graph.jpg";

    const header = [
      `# Semester Dashboard — ${dateStr}`,
      ``,
      `**Intent:** ${state.intent || "—"}`,
      `**Core window:** ${state.coreWindow || "—"} | **Weekend posture:** ${state.weekendPosture || "—"} | **Rebalance:** ${state.rebalanceDay || "—"}`
    ].join("\n");

    const modes = Object.keys(state.modeChecks).map(label => {
      return mdCheckbox(label + ` (${(state.modeScope?.[label] || "weekly").toUpperCase()})`, !!state.modeChecks[label]);
    }).join("\n");

    const courseNotes = state.courses.map(course => {
      const c = state.courseNotes[course] || {};
      const t = [];
      t.push(`- ${obsidianLink(course)} — status: **${c.status || "steady"}**`);
      if (c.focus) t.push(`  - Focus: ${c.focus}`);
      if (c.budget) t.push(`  - Block budget: ${c.budget}`);
      const noteText = c.notes || "";
      const gptAnalysis = noteText.trim() ? (state.llmNoteAnalyses?.[course] || null) : null;
      const analysis = gptAnalysis && (gptAnalysis.title || gptAnalysis.concepts)
        ? {
          title: gptAnalysis.title || "Untitled Note",
          concepts: Array.isArray(gptAnalysis.concepts) ? gptAnalysis.concepts : [],
          anchors: Array.isArray(gptAnalysis.anchors) ? gptAnalysis.anchors : []
        }
        : buildNoteAnalysis(noteText);
      const noteBullets = analysis.concepts.map(p => `    - ${p || "—"}`).join("\n");
      const noteAnchors = (analysis.anchors || []).map((a) => a.startsWith("#") ? a : `#${slugTag(a)}`);
      t.push(`  - Note title: ${analysis.title}`);
      t.push(`  - Key concepts:`);
      t.push(noteBullets || "    - —");
      t.push(`  - Academic anchors: ${noteAnchors.join(" ") || "—"}`);
      if (noteText) t.push(`  - Notes: ${noteText}`);
      return t.join("\n");
    }).join("\n");

    const taskList = (title, list) => {
      if (!list.length) return `### ${title}\n- (none)`;
      return `### ${title}\n` + list.map(t => {
        const status = t.done ? "x" : " ";
        const course = t.course ? ` (${t.course})` : "";
        const mode = (t.mode && t.mode !== "(mode)") ? ` [${t.mode}]` : "";
        const label = (t.title || "Untitled").replace(/\n/g, " ");
        return `- [${status}] ${label}${course}${mode}`;
      }).join("\n");
    };

    const writing = [
      `### GCAS Writing`,
      `- Schedule: ${state.writingSchedule || "—"}`,
      `- Thread: ${state.writingThread || "—"}`,
      `- Targets: ${state.writingTargets || "—"}`,
      `- Notes: ${state.writingNotes || "—"}`
    ].join("\n");

    const prose = [
      `### Prose Writing`,
      `- Schedule: ${state.proseSchedule || "—"}`,
      `- Project: ${state.proseProject || "—"}`,
      `- Targets: ${state.proseTargets || "—"}`,
      `- Notes: ${state.proseNotes || "—"}`
    ].join("\n");

    const forestFile = forestFilename;
    const graphFile = graphFilename;

    const out = [
      header,
      ``,
      `## Modes`,
      modes,
      ``,
      `## Courses`,
      courseNotes,
      ``,
      taskList("Today Tasks", state.todayTasks),
      ``,
      taskList("Weekend Deliverables", state.weekendTasks),
      ``,
      writing,
      ``,
      prose,
      ``,
      `## Conference Response (auto-generated)`,
      confResponse,
      ``,
      `## Forest Snapshot`,
      `- Week: ${weekId}`,
      `- Avg words: ${avgWords.toFixed(1)} (max ${avgMaxWords.toFixed(1)})`,
      `- Avg syntax: ${avgSyntax.toFixed(2)} (max ${avgMaxSyntax.toFixed(2)})`,
      `- Avg cohesion: ${avgCohesion.toFixed(2)} (max ${avgMaxCohesion.toFixed(2)})`,
      `- Completion rate: ${percent(completionRate)}`,
      `- Forest image: ${forestFile ? `![[${forestFile}]]` : "N/A"}`,
      `- Concept graph image: ${graphFile ? `![[${graphFile}]]` : "N/A"}`
    ].join("\n");

    return out;
  }

  function setMdPreview(md) {
    state.mdCache = md;
    saveState();
    mdPreviewEl.textContent = md;
  }

  // ---------- Basic NLP helpers ----------
  const STOP = new Set([
    "the","a","an","and","or","but","if","then","else","when","where","why","how","what","which",
    "of","to","in","on","for","from","by","with","about","as","at","into","over","after","before","between","through",
    "is","are","was","were","be","been","being","it","its","this","that","these","those","i","you","he","she","they",
    "we","me","my","our","your","their","them","his","her","not","no","yes","so","do","did","does","doing","can","will",
    "just","than","too","very","more","most","less","least","up","down","out","off","again","new","old","also","still"
  ]);

  function normalizeText(s){
    return String(s || "")
      .replace(/\n/g, " ")
      .replace(/[^a-zA-Z0-9\s]/g, " ")
      .replace(/\s+/g, " ")
      .trim()
      .toLowerCase();
  }

  function splitSentences(text){
    if (!text) return [];
    return text.split(/[\.\?\!\n]/).map(s => s.trim()).filter(Boolean);
  }

  function contentWords(text){
    return String(text || "")
      .toLowerCase()
      .replace(/[^a-z0-9\s]/g, " ")
      .split(/\s+/)
      .filter(Boolean)
      .filter(w => !STOP.has(w))
      .filter(w => w.length > 2);
  }

  function topNWords(text, n=8){
    const freq = new Map();
    contentWords(text).forEach(w => freq.set(w, (freq.get(w)||0)+1));
    return Array.from(freq.entries())
      .sort((a,b)=>b[1]-a[1])
      .slice(0,n)
      .map(([w,count])=>({w,count}));
  }

  // ---------- Forest visualization ----------
  let lastForestGeom = null;

  function getWeeklyStore(weekId) {
    state.forest.weekly = state.forest.weekly || { weekId: "", courses: {} };
    if (state.forest.weekly.weekId !== weekId) {
      state.forest.weekly = { weekId, courses: {} };
    }
    return state.forest.weekly;
  }

  function noteSessionScore(notes) {
    const words = wordCount(notes);
    if (words < 10) return 0;
    const punctCount = (notes.match(/[.,;:!?]/g) || []).length;
    const sentences = splitSentences(notes);
    const syntax = words ? Math.min(1, (punctCount / words) * 8) : 0;
    const cohesionHits = (notes.match(/\b(and|but|because|however|therefore|thus|so)\b/gi) || []).length;
    const cohesion = sentences.length ? Math.min(1, cohesionHits / Math.max(1, sentences.length)) : 0;
    const noteWords = contentWords(notes);
    const uniqueRatio = noteWords.length ? (new Set(noteWords)).size / noteWords.length : 0;
    const diversity = clamp(uniqueRatio, 0, 1);

    const lengthTarget = 180;
    const lengthFactor = clamp(Math.sqrt(words) / Math.sqrt(lengthTarget), 0, 1);
    const complexity = clamp(0.4 * syntax + 0.4 * cohesion + 0.2 * diversity, 0, 1);
    return clamp(0.35 * lengthFactor + 0.65 * complexity, 0, 1);
  }

  function updateWeeklySession(course, notes) {
    const weekId = isoWeekId(new Date());
    const store = getWeeklyStore(weekId);
    const dayKey = etDateKey();
    store.courses[course] = store.courses[course] || { days: {}, total: 0 };
    const score = noteSessionScore(notes);
    if (score <= 0) return;
    const prev = store.courses[course].days[dayKey] || 0;
    if (score > prev) {
      store.courses[course].days[dayKey] = score;
      const total = Object.values(store.courses[course].days).reduce((sum, v) => sum + v, 0);
      store.courses[course].total = total;
      saveState();
    }
  }

  function weeklyScoreForCourse(course, weekId) {
    const store = getWeeklyStore(weekId);
    const c = store.courses[course];
    if (!c) return { score: 0, sessions: 0 };
    const scores = Object.values(c.days || {});
    const sessions = scores.filter(s => s >= 0.2).length;
    const score = clamp(scores.reduce((sum, s) => sum + s, 0) / 5, 0, 1);
    return { score, sessions };
  }

  function computeForestMetrics() {
    const courses = state.courses || [];
    const perCourse = {};
    let total = 0;

    courses.forEach((course) => {
      const notes = (state.courseNotes[course]?.notes || "");
      const words = wordCount(notes);
      const punctCount = (notes.match(/[.,;:!?]/g) || []).length;
      const sentences = splitSentences(notes);
      const syntax = words ? Math.min(1, (punctCount / words) * 8) : 0;
      const cohesionHits = (notes.match(/\b(and|but|because|however|therefore|thus|so)\b/gi) || []).length;
      const cohesion = sentences.length ? Math.min(1, cohesionHits / Math.max(1, sentences.length)) : 0;
      const tasks = state.todayTasks.filter(t => t.course === course && t.done).length
        + state.weekendTasks.filter(t => t.course === course && t.done).length;

      const status = state.courseNotes[course]?.status || "steady";
      const stress = status === "danger" ? 1 : status === "hot" ? 0.75 : status === "watch" ? 0.45 : 0.2;

      perCourse[course] = { words, syntax, cohesion, tasks, stress };
      total += words + tasks * 20;
    });

    // Mode completion ratio
    const dailyTotal = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="daily").length || 1;
    const weeklyTotal = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="weekly").length || 1;
    const dailyChecked = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="daily" && state.modeChecks[k]).length;
    const weeklyChecked = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="weekly" && state.modeChecks[k]).length;

    const mode = {
      dailyRatio: dailyChecked / dailyTotal,
      weeklyRatio: weeklyChecked / weeklyTotal,
      dailyChecked,
      weeklyChecked
    };

    const weekId = isoWeekId(new Date());
    return { perCourse, total, mode, weekId };
  }

  function hashString(str) {
    let h = 2166136261;
    for (let i = 0; i < str.length; i++) {
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h >>> 0;
  }

  function makeRng(seed) {
    let s = hashString(String(seed)) || 1;
    return () => {
      s = (s * 1664525 + 1013904223) >>> 0;
      return (s >>> 8) / 16777216;
    };
  }

  function seededRandom(key, salt = "") {
    const h = hashString(`${key}::${salt}`);
    return (h % 100000) / 100000;
  }

  function courseKeywords(course) {
    const raw = state.courseNotes?.[course]?.notes || "";
    const norm = normalizeText(raw);
    const words = topNWords(norm, 8).map(x => x.w);
    const phrases = keyPhrases(raw, 6).map(p => p.replace(/[^a-z0-9\s]/gi, "").trim()).filter(Boolean);
    return new Set([...words, ...phrases].filter(Boolean));
  }

  function courseComplexity(metrics) {
    const words = clamp((metrics.words || 0) / 220, 0, 1);
    const syntax = clamp((metrics.syntax || 0) / 1.2, 0, 1);
    const cohesion = clamp((metrics.cohesion || 0) / 1.2, 0, 1);
    const tasks = clamp((metrics.tasks || 0) / 6, 0, 1);
    return clamp(0.4 * words + 0.25 * syntax + 0.25 * cohesion + 0.1 * tasks, 0, 1);
  }

  function computeMyceliumGraph(courses, perCourse, baseY, w, h, weekId, simulateWeeklyScore = null) {
    const spacing = w / (Math.max(1, courses.length) + 1);
    const nodes = courses.map((course, idx) => {
      const metrics = perCourse[course] || { words: 0, syntax: 0, cohesion: 0, tasks: 0 };
      const complexity = courseComplexity(metrics);
      const activity = clamp((metrics.words || 0) / 140 + (metrics.tasks || 0) / 6 + (metrics.syntax || 0), 0, 2);
      const depth = 30 + 110 * (0.35 + 0.65 * complexity);
      const x = spacing * (idx + 1);
      const y = clamp(baseY + depth, baseY + 8, h - 10);
      const weekly = weeklyScoreForCourse(course, weekId);
      const noteText = state.courseNotes?.[course]?.notes || "";
      const noteWords = contentWords(noteText);
      const uniqueRatio = noteWords.length ? (new Set(noteWords)).size / noteWords.length : 0;
      const diversityN = clamp(uniqueRatio, 0, 1);
      const keywordCount = courseKeywords(course).size;
      const phraseCount = keyPhrases(noteText, 8).length;
      const cohesionHits = (noteText.match(/\b(and|but|because|however|therefore|thus|so)\b/gi) || []).length;
      const sentences = splitSentences(noteText);
      const cohesionN = sentences.length ? Math.min(1, cohesionHits / Math.max(1, sentences.length)) : 0;
      const conceptN = clamp((keywordCount / 12 + phraseCount / 6 + cohesionN) / 3, 0, 1);
      return {
        id: course,
        course,
        x,
        y,
        complexity,
        activity,
        keywords: courseKeywords(course),
        jitter: seededRandom(course, weekId),
        weeklyScore: (simulateWeeklyScore === null) ? weekly.score : simulateWeeklyScore,
        conceptScore: conceptN,
        diversityN
      };
    });

    const edges = [];
    for (let i = 0; i < nodes.length; i++) {
      for (let j = i + 1; j < nodes.length; j++) {
        const a = nodes[i];
        const b = nodes[j];
        const aSet = a.keywords;
        const bSet = b.keywords;
        let shared = 0;
        aSet.forEach((k) => { if (bSet.has(k)) shared += 1; });
        const denom = Math.max(1, Math.min(aSet.size, bSet.size));
        const similarity = shared / denom;
        const avgComplexity = (a.complexity + b.complexity) / 2;
        const activityBoost = clamp((a.activity + b.activity) / 3, 0, 1);
        const weight = similarity * (0.55 + 0.45 * avgComplexity) + 0.08 * activityBoost;
        if (shared >= 1 || weight >= 0.06) {
          edges.push({
            a,
            b,
            shared,
            weight,
            avgComplexity,
            key: `${a.id}|${b.id}|${weekId}`
          });
        }
      }
    }
    const weeklyByCourse = {};
    const conceptByCourse = {};
    nodes.forEach((n) => {
      weeklyByCourse[n.course] = n.weeklyScore || 0;
      conceptByCourse[n.course] = n.conceptScore || 0;
    });
    return { nodes, edges, weeklyByCourse, conceptByCourse };
  }

  function drawMycelium(ctx, graph, baseY, w, h) {
    if (!graph || !graph.nodes.length) return;
    const ink = "#000000";
    ctx.save();
    ctx.globalCompositeOperation = "source-over";
    ctx.strokeStyle = ink;
    ctx.lineWidth = 0.5;
    ctx.globalAlpha = 1;

    // Space colonization mycelium
    const nutrients = [];
    graph.edges.forEach((edge, idx) => {
      const { a, b, weight } = edge;
      const count = Math.max(6, Math.round(8 + weight * 18));
      for (let i = 0; i < count; i++) {
        const t = (i + 1) / (count + 1);
        const nx = a.x + (b.x - a.x) * t;
        const ny = a.y + (b.y - a.y) * t;
        const jx = (seededRandom(edge.key, `jx${i}`) - 0.5) * 24;
        const jy = (seededRandom(edge.key, `jy${i}`) - 0.1) * 30;
        nutrients.push({ x: nx + jx, y: Math.min(h - 6, Math.max(baseY + 8, ny + jy)) });
      }
    });
    if (!nutrients.length) {
      graph.nodes.forEach((node) => {
        const count = 10;
        for (let i = 0; i < count; i++) {
          const t = (i + 1) / (count + 1);
          const ang = (Math.PI * 2 * t);
          const r = 22 + seededRandom(node.id, `n${i}`) * 26;
          nutrients.push({
            x: node.x + Math.cos(ang) * r,
            y: Math.min(h - 6, baseY + 12 + Math.sin(ang) * r)
          });
        }
      });
    }

    const tips = graph.nodes.map((node) => ({
      x: node.x,
      y: baseY + 2,
      dirX: 0,
      dirY: 1,
      course: node.course
    }));
    // Debug: show nutrient points and tips if network appears empty
    const debug = false;
    if (debug) {
      ctx.fillStyle = "#000000";
      nutrients.forEach((n) => {
        ctx.fillRect(n.x - 1, n.y - 1, 2, 2);
      });
      tips.forEach((t) => {
        ctx.fillRect(t.x - 1, t.y - 1, 2, 2);
      });
    }

    const weeklyAvg = graph.nodes.length
      ? graph.nodes.reduce((sum, n) => sum + (n.weeklyScore || 0), 0) / graph.nodes.length
      : 0;
    const influence = 140 + 70 * weeklyAvg;
    const kill = 1;
    const step = 8;
    const iterations = Math.round(240 + 120 * weeklyAvg);

    // Contact with trunks
    graph.nodes.forEach((node) => {
      ctx.beginPath();
      ctx.moveTo(node.x, baseY);
      ctx.lineTo(node.x, baseY + 6);
      ctx.stroke();
    });

    for (let iter = 0; iter < iterations && nutrients.length; iter++) {
      const growth = new Array(tips.length).fill(0).map(() => ({ x: 0, y: 0, count: 0 }));

      for (let n = nutrients.length - 1; n >= 0; n--) {
        const nutrient = nutrients[n];
        let bestIdx = -1;
        let bestDist = Infinity;
        for (let i = 0; i < tips.length; i++) {
          const dx = nutrient.x - tips[i].x;
          const dy = nutrient.y - tips[i].y;
          const d = Math.hypot(dx, dy);
          if (d < kill) {
            nutrients.splice(n, 1);
            bestIdx = -2;
            break;
          }
          if (d < bestDist && d < influence) {
            bestDist = d;
            bestIdx = i;
          }
        }
        if (bestIdx >= 0) {
          const dx = nutrient.x - tips[bestIdx].x;
          const dy = nutrient.y - tips[bestIdx].y;
          const d = Math.hypot(dx, dy) || 1;
          growth[bestIdx].x += dx / d;
          growth[bestIdx].y += dy / d;
          growth[bestIdx].count += 1;
        }
      }

      const newTips = [];
      for (let i = 0; i < tips.length; i++) {
        const g = growth[i];
        if (!g.count) {
          if (iter % 2 === 0) {
            const nx = tips[i].x;
            const ny = tips[i].y + step * 0.6;
            ctx.beginPath();
            ctx.moveTo(tips[i].x, tips[i].y);
            ctx.lineTo(nx, ny);
            ctx.stroke();
            newTips.push({ x: nx, y: ny, dirX: 0, dirY: 1 });
          }
          continue;
        }
        const dx = g.x / g.count;
        const dy = g.y / g.count;
        const d = Math.hypot(dx, dy) || 1;
        const nx = tips[i].x + (dx / d) * step;
        const ny = tips[i].y + (dy / d) * step;
        ctx.beginPath();
        ctx.moveTo(tips[i].x, tips[i].y);
        ctx.lineTo(nx, ny);
        ctx.stroke();
        newTips.push({ x: nx, y: ny, dirX: dx / d, dirY: dy / d });
      }
      tips.push(...newTips);
    }

    // Fuse nearby tips to create web-like connections
    for (let i = 0; i < tips.length; i++) {
        const weeklyI = graph.weeklyByCourse?.[tips[i].course] || 0;
        const linkMax = 46 + 28 * weeklyI + 24 * weeklyAvg;
      for (let j = i + 1; j < tips.length; j++) {
        const weeklyJ = graph.weeklyByCourse?.[tips[j].course] || 0;
        const conceptI = graph.conceptByCourse?.[tips[i].course] || 0;
        const conceptJ = graph.conceptByCourse?.[tips[j].course] || 0;
        const conceptAvg = (conceptI + conceptJ) / 2;
        const maxDist = linkMax + 40 * conceptAvg;
        const dx = tips[i].x - tips[j].x;
        const dy = tips[i].y - tips[j].y;
        const d = Math.hypot(dx, dy);
        if (d > 4 && d < maxDist) {
          ctx.beginPath();
          ctx.moveTo(tips[i].x, tips[i].y);
          ctx.lineTo(tips[j].x, tips[j].y);
          ctx.stroke();
        }
      }
    }

    ctx.restore();
  }

  function updateForestMax(perCourse) {
    const maxStore = state.forest.perCourseMax || {};
    Object.entries(perCourse).forEach(([course, metrics]) => {
      if (!maxStore[course]) {
        maxStore[course] = { words: metrics.words, syntax: metrics.syntax, cohesion: metrics.cohesion, tasks: metrics.tasks };
      } else {
        maxStore[course].words = Math.max(maxStore[course].words, metrics.words || 0);
        maxStore[course].syntax = Math.max(maxStore[course].syntax, metrics.syntax || 0);
        maxStore[course].cohesion = Math.max(maxStore[course].cohesion, metrics.cohesion || 0);
        maxStore[course].tasks = Math.max(maxStore[course].tasks, metrics.tasks || 0);
      }
    });
    state.forest.perCourseMax = maxStore;
    saveState();
  }

  function initCanvasHiDPI(canvas) {
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.scale(dpr, dpr);
    return { ctx, w: rect.width, h: rect.height };
  }

  function renderForestLegend(perCourse, courseList) {
    if (!forestLegendEl) return;
    const weekId = isoWeekId(new Date());
    const rows = courseList.map((course) => {
      const m = perCourse[course] || {};
      const notes = state.courseNotes?.[course]?.notes || "";
      const words = wordCount(notes);
      const punctCount = (notes.match(/[.,;:!?]/g) || []).length;
      const sentences = splitSentences(notes);
      const syntax = words ? Math.min(1, (punctCount / words) * 8) : 0;
      const cohesionHits = (notes.match(/\b(and|but|because|however|therefore|thus|so)\b/gi) || []).length;
      const cohesion = sentences.length ? Math.min(1, cohesionHits / Math.max(1, sentences.length)) : 0;
      const avgSentenceLen = sentences.length ? (words / sentences.length) : 0;
      const noteWords = contentWords(notes);
      const uniqueRatio = noteWords.length ? (new Set(noteWords)).size / noteWords.length : 0;
      const diversityN = clamp(uniqueRatio, 0, 1);
      const keywordCount = courseKeywords(course).size;
      const phraseCount = keyPhrases(notes, 8).length;
      const conceptN = clamp((keywordCount / 12 + phraseCount / 6 + cohesion) / 3, 0, 1);
      const properCount = extractProperNouns(notes, 50).length;
      const punctuationPerWord = words ? (punctCount / words) : 0;
      const stress = m.stress || 0;
      const tasks = m.tasks || 0;
      const weekly = weeklyScoreForCourse(course, weekId);
      const status = (state.courseNotes?.[course]?.status || "steady");
      return `
        <div style="display:grid;gap:4px;padding:8px;border:1px solid var(--line);border-radius:10px;background:var(--panel2);color:var(--text);">
          <div><b>${escapeHtml(course)}</b> <span class="pill">${status}</span></div>
          <div>Words ${words} • SentLen ${avgSentenceLen.toFixed(1)} • Punct ${(punctuationPerWord * 100).toFixed(1)}%</div>
          <div>Syntax ${(syntax * 100).toFixed(1)}% • Cohesion ${(cohesion * 100).toFixed(1)}% • Diversity ${(diversityN * 100).toFixed(1)}%</div>
          <div>Concepts ${keywordCount} • Phrases ${phraseCount} • Proper ${properCount}</div>
          <div>Tasks ${tasks} • Stress ${(stress * 100).toFixed(1)}% • Linkage ${(conceptN * 100).toFixed(1)}%</div>
          <div>Weekly sessions ${weekly.sessions}/6 • Weekly score ${(weekly.score * 100).toFixed(1)}%</div>
        </div>
      `;
    }).join("");

    forestLegendEl.innerHTML = `
      <div style="display:grid;gap:8px;">
        <div><b>Tree Analysis Legend</b> — per-course signals driving structure</div>
        <div style="display:grid;gap:10px;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));">
          ${rows || "<div>No courses yet.</div>"}
        </div>
      </div>
    `;
  }

  function renderForest() {
    if (!forestCanvas) return;
    const { perCourse, mode, weekId } = computeForestMetrics();
    updateForestMax(perCourse);

    const { ctx, w, h } = initCanvasHiDPI(forestCanvas);
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = getCSSVar("--panel");
    ctx.fillRect(0, 0, w, h);

    const courses = state.courses || [];
    renderForestLegend(perCourse, courses);
    const count = Math.max(1, courses.length);
    const spacing = w / (count + 1);
    const baseY = h - 200;
    const padL = 18;
    const padR = 18;
    const padT = 18;

    lastForestGeom = { width: w, height: h, trees: [] };

    // ghost overlay
    const fullGhost = state.forest.showFullGhost
      ? buildFullGhost(w, h, padL, padR, padT, baseY, perCourse, mode, weekId)
      : null;
    drawGhostForest(ctx, w, h, padL, padR, baseY, fullGhost);

    courses.forEach((course, idx) => {
      const x0 = spacing * (idx + 1);
      const metrics = perCourse[course] || { words: 0, syntax: 0, cohesion: 0, tasks: 0, stress: 0 };
      const currentMax = {
        words: Math.max(1, ...Object.values(perCourse).map(m => m.words || 0)),
        syntax: Math.max(0.1, ...Object.values(perCourse).map(m => m.syntax || 0)),
        cohesion: Math.max(0.1, ...Object.values(perCourse).map(m => m.cohesion || 0)),
        tasks: Math.max(1, ...Object.values(perCourse).map(m => m.tasks || 0))
      };

      // Normalized values
      const wordsN = clamp((metrics.words || 0) / currentMax.words, 0, 1);
      const syntaxN = clamp((metrics.syntax || 0) / currentMax.syntax, 0, 1);
      const cohesionN = clamp((metrics.cohesion || 0) / currentMax.cohesion, 0, 1);
      const tasksN = clamp((metrics.tasks || 0) / currentMax.tasks, 0, 1);

      const stress = clamp(metrics.stress || 0, 0, 1);
      const noteText = state.courseNotes?.[course]?.notes || "";
      const noteWords = contentWords(noteText);
      const uniqueRatio = noteWords.length ? (new Set(noteWords)).size / noteWords.length : 0;
      const diversityN = clamp(uniqueRatio, 0, 1);
      const keywordCount = courseKeywords(course).size;
      const phraseCount = keyPhrases(noteText, 8).length;
      const conceptN = clamp((keywordCount / 12 + phraseCount / 6 + cohesionN) / 3, 0, 1);
      const weekly = weeklyScoreForCourse(course, weekId);
      const weeklyScoreN = weekly.score;
      const isGcas = /gcas/i.test(course);
      const heightScale = isGcas ? 1 : 0.7;
      const canopyBoost = isGcas ? 1 : 1.2;
      const gcasBoost = 1;
      const allTasks = state.todayTasks.concat(state.weekendTasks).filter(t => t.course === course);
      const totalTasks = allTasks.length;
      const doneTasks = allTasks.filter(t => t.done).length;
      const taskScoreN = totalTasks ? clamp(doneTasks / totalTasks, 0, 1) : 0;
      const maxHeight = Math.max(40, baseY - padT - 70);
      const height = Math.min(
        maxHeight * 0.6 * heightScale,
        (12 + 40 * weeklyScoreN + 16 * (wordsN * weeklyScoreN) + 10 * (tasksN * weeklyScoreN)) * heightScale
      );
      const trunkW = 0.5;

      const complexityN = clamp((wordsN + syntaxN + cohesionN + tasksN + weeklyScoreN) / 5, 0, 1);
      const branchiness = clamp(0.3 + 0.7 * syntaxN * weeklyScoreN * gcasBoost + 0.25 * tasksN * weeklyScoreN, 0.2, 1.6);
      const leaves = taskScoreN > 0
        ? clamp(0.4 + 1.6 * taskScoreN * canopyBoost + 0.9 * cohesionN * weeklyScoreN * gcasBoost + 0.4 * mode.weeklyRatio * weeklyScoreN, 0.3, 3.2)
        : 0;
      const crownSpread = clamp(1.0 + 1.6 * taskScoreN * canopyBoost + 0.6 * syntaxN * gcasBoost, 1.0, 4.0);

      const dayLight = clamp(0.45 + 0.7 * mode.dailyRatio, 0.3, 1.1);

      drawTree(ctx, {
        x0,
        baseY,
        height,
        trunkW,
        branchiness,
        leaves,
        crownSpread,
        stress,
        padT,
        padL,
        padR,
        w,
        dayLight,
        cohesionN,
        syntaxN,
        tasksN,
        diversityN,
        wordsN,
        conceptN,
        weeklyScoreN,
        weekendScoreN: taskScoreN,
        noteText,
        syntax: metrics.syntax || 0,
        cohesion: metrics.cohesion || 0,
        complexityN,
        seedKey: `${weekId}|${course}|${metrics.words}|${metrics.tasks}|${metrics.syntax}|${metrics.cohesion}|${weeklyScoreN}`,
        course,
        mode
      }, lastForestGeom);
    });

    applyOrderedDither(ctx, w, h);

    // save snapshot for this week so it becomes next week's ghost
    saveGhostSnapshot(weekId);
  }

  let ditherWarned = false;
  function applyOrderedDither(ctx, w, h) {
    try {
      const iw = Math.max(1, Math.floor(w));
      const ih = Math.max(1, Math.floor(h));
      const img = ctx.getImageData(0, 0, iw, ih);
      const data = img.data;
      const bayer8 = [
        [0, 32, 8, 40, 2, 34, 10, 42],
        [48, 16, 56, 24, 50, 18, 58, 26],
        [12, 44, 4, 36, 14, 46, 6, 38],
        [60, 28, 52, 20, 62, 30, 54, 22],
        [3, 35, 11, 43, 1, 33, 9, 41],
        [51, 19, 59, 27, 49, 17, 57, 25],
        [15, 47, 7, 39, 13, 45, 5, 37],
        [63, 31, 55, 23, 61, 29, 53, 21]
      ];
      const strength = 120;
      const levels = 2;
      for (let y = 0; y < ih; y++) {
        for (let x = 0; x < iw; x++) {
          const i = (y * iw + x) * 4;
          const threshold = (bayer8[y % 8][x % 8] / 64) - 0.5;
          const r = clamp(data[i] + threshold * strength, 0, 255);
          const g = clamp(data[i + 1] + threshold * strength, 0, 255);
          const b = clamp(data[i + 2] + threshold * strength, 0, 255);
          data[i] = Math.round((r / 255) * levels) * (255 / levels);
          data[i + 1] = Math.round((g / 255) * levels) * (255 / levels);
          data[i + 2] = Math.round((b / 255) * levels) * (255 / levels);
        }
      }
      ctx.putImageData(img, 0, 0);
    } catch (err) {
      if (!ditherWarned) {
        console.warn("Dither disabled (canvas not readable).", err);
        ditherWarned = true;
      }
    }
  }

  function buildFullGhost(w, h, padL, padR, padT, baseY, perCourse, mode, weekId) {
    const courses = state.courses || [];
    const count = Math.max(1, courses.length);
    const spacing = w / (count + 1);
    const currentMax = {
      words: Math.max(1, ...Object.values(perCourse).map(m => m.words || 0)),
      syntax: Math.max(0.1, ...Object.values(perCourse).map(m => m.syntax || 0)),
      cohesion: Math.max(0.1, ...Object.values(perCourse).map(m => m.cohesion || 0)),
      tasks: Math.max(1, ...Object.values(perCourse).map(m => m.tasks || 0))
    };
    const dummyCanvas = document.createElement("canvas");
    dummyCanvas.width = w;
    dummyCanvas.height = h;
    const ctx = dummyCanvas.getContext("2d");
    const ghostGeom = { width: w, height: h, trees: [] };
    courses.forEach((course, idx) => {
      const x0 = spacing * (idx + 1);
      const metrics = perCourse[course] || { words: 0, syntax: 0, cohesion: 0, tasks: 0, stress: 0 };
      const wordsN = clamp((metrics.words || 0) / currentMax.words, 0, 1);
      const syntaxN = clamp((metrics.syntax || 0) / currentMax.syntax, 0, 1);
      const cohesionN = clamp((metrics.cohesion || 0) / currentMax.cohesion, 0, 1);
      const tasksN = clamp((metrics.tasks || 0) / currentMax.tasks, 0, 1);
      const stress = clamp(metrics.stress || 0, 0, 1);
      const noteText = state.courseNotes?.[course]?.notes || "";
      const noteWords = contentWords(noteText);
      const uniqueRatio = noteWords.length ? (new Set(noteWords)).size / noteWords.length : 0;
      const diversityN = clamp(uniqueRatio, 0, 1);
      const keywordCount = courseKeywords(course).size;
      const phraseCount = keyPhrases(noteText, 8).length;
      const conceptN = clamp((keywordCount / 12 + phraseCount / 6 + cohesionN) / 3, 0, 1);
      const weeklyScoreN = 1;
      const taskScoreN = 1;
      const isGcas = /gcas/i.test(course);
      const heightScale = isGcas ? 1 : 0.7;
      const canopyBoost = isGcas ? 1 : 1.2;
      const maxHeight = Math.max(40, baseY - padT - 70);
      const height = Math.min(
        maxHeight * 0.6 * heightScale,
        (12 + 40 * weeklyScoreN + 16 * (wordsN * weeklyScoreN) + 10 * (tasksN * weeklyScoreN)) * heightScale
      );
      const complexityN = clamp((wordsN + syntaxN + cohesionN + tasksN + weeklyScoreN) / 5, 0, 1);
      const branchiness = clamp(0.3 + 0.7 * syntaxN * weeklyScoreN + 0.25 * tasksN * weeklyScoreN, 0.2, 1.6);
      const leaves = clamp(0.4 + 1.6 * taskScoreN * canopyBoost + 0.9 * cohesionN * weeklyScoreN + 0.4 * mode.weeklyRatio * weeklyScoreN, 0.3, 3.2);
      const crownSpread = clamp(1.0 + 1.6 * taskScoreN * canopyBoost + 0.6 * syntaxN, 1.0, 4.0);
      const dayLight = clamp(0.45 + 0.7 * mode.dailyRatio, 0.3, 1.1);
      drawTree(ctx, {
        x0,
        baseY,
        height,
        trunkW: 0.5,
        branchiness,
        leaves,
        crownSpread,
        stress,
        padT,
        padL,
        padR,
        w,
        dayLight,
        cohesionN,
        syntaxN,
        tasksN,
        diversityN,
        wordsN,
        conceptN,
        weeklyScoreN,
        weekendScoreN: taskScoreN,
        noteText,
        syntax: metrics.syntax || 0,
        cohesion: metrics.cohesion || 0,
        complexityN,
        seedKey: `${weekId}|${course}|full`,
        course,
        mode
      }, ghostGeom);
    });
    return ghostGeom;
  }

  function drawGhostForest(ctx, w, h, padL, padR, baseY, overrideGhost = null) {
    if (!overrideGhost && isMondayAfterNoonET()) return;
    const current = isoWeekId(new Date());
    const prev = prevIsoWeekId(current);
    const ghost = overrideGhost || loadGhostSnapshot(prev);
    if (!ghost) return;

    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.strokeStyle = "#000000";
    ctx.lineWidth = 0.5;

    ghost.trees.forEach((tree) => {
      tree.paths.forEach((p) => {
        if (p.type === "circle") {
          ctx.beginPath();
          ctx.arc(p.cx, p.cy, p.r, 0, Math.PI * 2);
          ctx.stroke();
        } else if (p.d) {
          ctx.beginPath();
          const path = new Path2D(p.d);
          ctx.stroke(path);
        } else {
          ctx.beginPath();
          ctx.strokeStyle = "#000000";
          ctx.lineWidth = 0.5;
          ctx.moveTo(p.x1, p.y1);
          ctx.lineTo(p.x2, p.y2);
          ctx.stroke();
        }
      });
    });

    ctx.restore();
  }

  function saveGhostSnapshot(weekId) {
    if (!lastForestGeom) return;
    try {
      const data = {
        weekId,
        trees: lastForestGeom.trees.map(tree => ({
          course: tree.course,
          paths: tree.paths.map(p => ({ ...p }))
        }))
      };
      localStorage.setItem(`${STORAGE_KEY}_ghost_${weekId}`, JSON.stringify(data));
    } catch {}
  }

  function loadGhostSnapshot(weekId) {
    try {
      const raw = localStorage.getItem(`${STORAGE_KEY}_ghost_${weekId}`);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch {
      return null;
    }
  }

  function clearGhostSnapshot(weekId) {
    try { localStorage.removeItem(`${STORAGE_KEY}_ghost_${weekId}`); } catch {}
  }

  function buildLSystemParams(features, height, maxRise, signature) {
    const syntaxN = features.syntaxN || 0;
    const cohesionN = features.cohesionN || 0;
    const tasksN = features.tasksN || 0;
    const stressN = features.stressN || 0;
    const diversityN = features.diversityN || 0;
    const wordsN = features.wordsN || 0;
    const conceptN = features.conceptN || 0;

    const baseHash = hashString(String(signature || ""));
    const isGcas = /gcas/i.test(signature || "");
    const sigJitter = ((baseHash % 23) - 11) * 0.7 + (isGcas ? -1.2 : 0);
    const angleDeg = clamp(
      26 + 30 * (1 - cohesionN) + 12 * diversityN + 14 * stressN + sigJitter,
      18,
      70
    );
    const iterations = Math.max(2, Math.round(18 - stressN * 16));
    let step = clamp(8 + height * (0.05 + 0.03 * cohesionN), 6, 16);
    step += 8 + 4 * tasksN;
    const stepScale = 0.85 + ((baseHash % 31) / 100) + (isGcas ? 0.06 : 0); // deterministic per-course variation
    step *= stepScale;
    if (maxRise) {
      const stepCap = Math.max(3, maxRise / (iterations * 2.6));
      step = Math.min(step, stepCap);
    }

    const grammarSet = [
      { "F": "F[+F]F[-F]F" },
      { "F": "FF[-F]F[+F]" },
      { "F": "F[+F]F" },
      { "F": "F[-F]F[+F]FF" },
      { "F": "F[+F]F[+F]F" },
      { "F": "F[-F]FF" },
      { "F": "FF[+F]F[-F]" },
      { "F": "F[+F][-F]F" },
      { "F": "F[+F]F[+F][-F]F" },
      { "F": "F[+F]FF[-F]F" },
      { "F": "F[+F]F[+F]FF[-F]F" },
      { "F": "FF[+F][-F]FF" }
    ];
    const key = [
      Math.round(syntaxN * 10),
      Math.round(cohesionN * 10),
      Math.round(diversityN * 10),
      Math.round(tasksN * 10),
      Math.round(wordsN * 10),
      baseHash
    ].join("|");
    const rules = grammarSet[hashString(key) % grammarSet.length];

    return {
      axiom: "F",
      rules,
      iterations,
      angle: angleDeg * (Math.PI / 180),
      step,
      sigHash: baseHash
    };
  }

  function expandLSystem(axiom, rules, iterations, maxLen = 9000, maxRun = 2200) {
    let str = axiom;
    for (let i = 0; i < iterations; i++) {
      let next = "";
      for (let j = 0; j < str.length; j++) {
        const ch = str[j];
        next += rules[ch] || ch;
        if (next.length > maxLen) break;
      }
      str = next.slice(0, maxLen);
    }
    return str.slice(0, maxRun);
  }

  function drawLSystem(ctx, start, angle, spec, leafPoints, ink, geom, minY, runScale = 1) {
    const stack = [];
    let x = start.x;
    let y = start.y;
    let dir = angle;
    const step = spec.step;
    const maxRun = Math.max(200, Math.round(5000 * clamp(runScale, 0.1, 1)));
    const seq = expandLSystem(spec.axiom, spec.rules, spec.iterations, 20000, maxRun);
    ctx.save();
    ctx.strokeStyle = ink;
    ctx.globalAlpha = 1;
    ctx.lineWidth = 0.5;
    for (let i = 0; i < seq.length; i++) {
      const ch = seq[i];
      if (ch === "F") {
        if (typeof minY === "number" && y < minY + 12) {
          dir += 0.25;
        }
        let nx = x + Math.cos(dir) * step;
        let ny = y + Math.sin(dir) * step;
        if (typeof minY === "number" && ny < minY) {
          dir = Math.PI / 2;
          nx = x + Math.cos(dir) * step;
          ny = y + Math.sin(dir) * step;
        }
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(nx, ny);
        ctx.stroke();
        if (geom) {
          geom.paths.push({
            x1: x, y1: y, x2: nx, y2: ny,
            stroke: ink,
            sw: 0.5,
            alpha: 1
          });
        }
        x = nx; y = ny;
        const phase = (i % 16);
        const sign = ((Math.floor(i / 16) + (spec.sigHash % 7)) % 2 === 0) ? 1 : -1;
        const drift = (phase < 6) ? -spec.angle * 0.12 : spec.angle * 0.16;
        dir += drift * sign;
      } else if (ch === "+") {
        dir += spec.angle;
      } else if (ch === "-") {
        dir -= spec.angle;
      } else if (ch === "[") {
        stack.push({ x, y, dir });
      } else if (ch === "]") {
        if (stack.length) {
          const s = stack.pop();
          x = s.x; y = s.y; dir = s.dir;
          leafPoints.push({ x, y });
        }
      }
    }
    leafPoints.push({ x, y });
    ctx.restore();
  }

  function drawTree(ctx, opts, forestGeom) {
    const {
      x0, baseY, height, trunkW, branchiness, leaves, crownSpread,
      stress, padT, padL, padR, w, dayLight, cohesionN, syntaxN, tasksN, diversityN, wordsN, conceptN, weeklyScoreN, weekendScoreN, noteText, syntax, cohesion,
      complexityN,
      seedKey, course, mode
    } = opts;

    const ink = "#000000";
    const geom = {
      course,
      paths: []
    };
    forestGeom.trees.push(geom);

    // No per-tree background fill to keep forest minimal

      // Draw trunk
      ctx.save();
      ctx.strokeStyle = ink;
      ctx.globalAlpha = 1;
      ctx.lineWidth = 0.5;
      ctx.setLineDash([]);

      const leafPoints = [];
      const maxRise = Math.min(220, Math.max(60, baseY - padT - 20));
      const lsys = buildLSystemParams({
        syntaxN,
        cohesionN,
        tasksN,
        stressN: stress,
        diversityN,
        wordsN
      }, height, maxRise, `${course}|${noteText}|${tasksN}|${conceptN}`);
      const growthN = Math.max(0.06, clamp(weeklyScoreN, 0, 1));
      const runScale = 0.1 + 0.9 * growthN;
      const fitScale = clamp((baseY - padT - 20) / Math.max(1, height * 1.6), 0.4, 1);
      const stepJitter = 0.9 + (seededRandom(seedKey, "step") - 0.5) * 0.18;
      lsys.step *= runScale * fitScale * stepJitter;
      const heightScale = clamp(1 - (lsys.iterations - 2) * 0.12, 0.55, 1);
      const trunkLen = height * dayLight * heightScale;
      const angleBias = 0.28 + 0.45 * (1 - weeklyScoreN);
      const angleSign = (tasksN - 0.5) >= 0 ? 1 : -1;
      const angleJitter = (seededRandom(seedKey, "angle") - 0.5) * 0.4;
      const trunkAngle = -Math.PI / 2 + angleSign * angleBias + angleJitter;
      const trunkJitter = (seededRandom(seedKey, "trunk") - 0.5) * 12;
      const trunkBaseX = clamp(x0 + trunkJitter, padL + 4, w - padR - 4);
      const trunkTop = {
        x: trunkBaseX + Math.cos(trunkAngle) * trunkLen,
        y: baseY + Math.sin(trunkAngle) * trunkLen
      };
      trunkTop.y = Math.max(trunkTop.y, padT + 8);

      ctx.beginPath();
      ctx.moveTo(trunkBaseX, baseY);
      ctx.lineTo(trunkTop.x, trunkTop.y);
      ctx.stroke();
      ctx.restore();

      geom.paths.push({
        d: `M ${trunkBaseX} ${baseY} L ${trunkTop.x} ${trunkTop.y}`,
        stroke: ink,
        sw: trunkW,
        alpha: (0.33 + 0.22*stress),
        fill: "none"
      });
      const lean = clamp((tasksN - 0.5) * 0.12 + (stress - 0.5) * 0.08 + (syntaxN - 0.5) * 0.05 + angleJitter * 0.35, -0.25, 0.25);
      if (growthN > 0.05) {
        drawLSystem(ctx, trunkTop, -Math.PI / 2 + lean, lsys, leafPoints, ink, geom, padT + 8, runScale * fitScale);
      }

      // Leaves
      const leafCount = leaves > 0 ? Math.min(
        1400,
        Math.round(leaves * (26 + 32 * cohesionN + 26 * (complexityN || 0) + 32 * (weekendScoreN || 0)) * (1.0 + 0.35 * mode.dailyRatio))
      ) : 0;
      const autumnPalette = [
        "#3a2c1b", "#5a3a1c", "#7a3d1a", "#9b4a1f",
        "#b8572a", "#d26a3a", "#e07f3f", "#f29c38",
        "#c6423a", "#a8332b", "#7f2b2b", "#612727",
        "#8d6a3c", "#a07c43"
      ];
      const richness = clamp((syntax + cohesion) / 6 + (complexityN || 0) * 0.35, 0, 1);
      const paletteCount = Math.max(3, Math.round(3 + richness * (autumnPalette.length - 5)));
      const stressMix = clamp(stress, 0, 1) * 0.5;
      const palette = autumnPalette.slice(0, paletteCount).map((c) => mixHex(c, "#2a2a2a", stressMix));
      if (leafCount > 0 && leafPoints.length) {
        ctx.save();
        ctx.strokeStyle = ink;
        ctx.fillStyle = palette[0];
        ctx.globalAlpha = 1;

        const points = (leafPoints.length ? leafPoints : [
          { x: trunkTop.x, y: trunkTop.y },
          { x: trunkBaseX, y: baseY - (height * 0.3) },
          { x: trunkBaseX, y: baseY - (height * 0.6) }
        ]).slice().sort((a, b) => a.y - b.y);
        const topCount = Math.max(6, Math.round(points.length * 0.65));
        const upperPoints = points.slice(0, topCount);
        const lowerPoints = points.slice(topCount);
        const dropCount = Math.round(leafCount * 0.2);
        for (let k=0;k<leafCount;k++){
          let px = 0;
          let py = 0;
          if (k < dropCount) {
            const pick = points[k % points.length] || trunkTop;
            const fall = (k / Math.max(1, dropCount)) * (40 + 80 * (1 - cohesionN));
            px = pick.x + ((k % 7) - 3) * 2;
            py = pick.y + fall;
          } else {
            const pick = (k % 3 === 0) ? points[k % points.length]
              : (k % 7 === 0 && lowerPoints.length ? lowerPoints[k % lowerPoints.length]
                : upperPoints[k % upperPoints.length]);
            const spread = 30 + 60 * (1 - cohesionN);
            const t = (k * 0.6180339887) % 1;
            const theta = t * Math.PI * 2;
            px = pick.x + Math.cos(theta) * spread * (0.35 + 0.65 * t);
            py = Math.max(padT + 6, pick.y + Math.sin(theta) * spread * (0.35 + 0.65 * t));
          }

          const rad = 1.1 + 1.4 * ((k % 11) / 10);
          const stretch = 1.2 + 0.9 * ((k % 7) / 6);
          const angle = (k % 9) * (Math.PI / 8);
          ctx.fillStyle = palette[k % palette.length];
          ctx.save();
          ctx.translate(px, py);
          ctx.rotate(angle);
          ctx.beginPath();
          ctx.ellipse(0, 0, rad * stretch, rad, 0, 0, Math.PI * 2);
          ctx.fill();
          if ((k % 5) === 0) { ctx.globalAlpha = 1; ctx.stroke(); }
          ctx.restore();

          geom.paths.push({
            type: "circle",
            cx: px, cy: py, r: rad,
            stroke: ink, sw: 0.8,
            alpha: 0.15,
            fill: "rgba(58,61,94,0.10)",
            fillAlpha: 1
          });
        }
        ctx.restore();
      }

      // Course labels (horizontal below sprout)
      ctx.save();
      ctx.fillStyle = ink;
      ctx.globalAlpha = 1;
      ctx.font = "600 12px " + getCSSVar("--sans");
      const labelX = clamp(x0, padL + 4, w - padR - 4);
      const labelY = Math.min(baseY + 16, baseY + 26);
      ctx.textAlign = "center";
      ctx.fillText(course, labelX, labelY);
      ctx.restore();
    }

  // Debounced forest updates while typing
  const debouncedForest = debounce(() => {
    try { renderForest(); } catch {}
  }, 180);

  const debouncedGraph = debounce(() => {
    try { renderConceptGraph(); } catch {}
  }, 220);

  // ---------- Hydration ----------
  function setPrintPreview(enabled) {
    state.printPreview = !!enabled;
    saveState();
    document.body.classList.toggle("print-preview", state.printPreview);
    toast(state.printPreview ? "Print preview on" : "Print preview off");
  }

  function hydrateInputs() {
    intentEl.value = state.intent || "";
    coreWindowEl.value = state.coreWindow || "";
    weekendPostureEl.value = state.weekendPosture || "";
    rebalanceDayEl.value = state.rebalanceDay || "Sunday";
    if (themeSelectEl) themeSelectEl.value = state.theme || "soft";
    applyTheme(state.theme || "soft");

    absorptionEl.value = state.absorption || "";
    workoutEl.value = state.workout || "";
    todayNotesEl.value = state.todayNotes || "";

    courseListEl.value = state.courses.join("; ");

    writingScheduleEl.value = state.writingSchedule || "";
    writingThreadEl.value = state.writingThread || "";
    writingTargetsEl.value = state.writingTargets || "";
    writingNotesEl.value = state.writingNotes || "";

    proseScheduleEl.value = state.proseSchedule || "";
    proseProjectEl.value = state.proseProject || "";
    proseTargetsEl.value = state.proseTargets || "";
    proseNotesEl.value = state.proseNotes || "";
    if (graphSpacingEl) graphSpacingEl.value = String(graphSpacing);

    if (openaiKeyEl) openaiKeyEl.value = state.llmKey || "";
    downtimeRuleEl.value = state.downtimeRule || "";

    renderModeChips();
    renderKeystoneDropdown();
    renderCourseCards();
    renderTasks();
    renderWeekSummary();
    renderConceptGraph();
    setupCardToggles();

    if (state.mdCache) mdPreviewEl.textContent = state.mdCache;

    forestLegendEl.classList.toggle("show", !!state.forest.legendOn);
    toggleHiResPngEl.checked = !!state.forest.hiResPng;
    if (toggleFullGhostEl) toggleFullGhostEl.checked = !!state.forest.showFullGhost;
    document.body.classList.toggle("print-preview", !!state.printPreview);
    debouncedForest();
  }

  // ---------- Wire up ----------
    // ---------- Wire up ----------
    intentEl.addEventListener("input", () => { state.intent = intentEl.value; saveState(); });
  coreWindowEl.addEventListener("input", () => { state.coreWindow = coreWindowEl.value; saveState(); });
  weekendPostureEl.addEventListener("input", () => { state.weekendPosture = weekendPostureEl.value; saveState(); });
  rebalanceDayEl.addEventListener("change", () => { state.rebalanceDay = rebalanceDayEl.value; saveState(); });
  themeSelectEl?.addEventListener("change", () => { applyTheme(themeSelectEl.value); });

  keystoneTodayEl.addEventListener("change", () => {
    state.keystoneToday = keystoneTodayEl.value;
    saveState();
    renderWeekSummary();
    debouncedForest();
  });

  absorptionEl.addEventListener("input", () => {
    state.absorption = absorptionEl.value;
    saveState();
  });

  workoutEl.addEventListener("input", () => {
    state.workout = workoutEl.value;
    saveState();
  });

  todayNotesEl.addEventListener("input", () => {
    state.todayNotes = todayNotesEl.value;
    saveState();
    debouncedForest();
    debouncedGraph();
  });

  courseListEl.addEventListener("keydown", (e) => {
    if (e.key === "Enter") { e.preventDefault(); el("btnApplyCourses").click(); }
  });

  writingScheduleEl.addEventListener("input", () => { state.writingSchedule = writingScheduleEl.value; saveState(); debouncedGraph(); });
  writingThreadEl.addEventListener("input", () => { state.writingThread = writingThreadEl.value; saveState(); debouncedGraph(); });
  writingTargetsEl.addEventListener("input", () => { state.writingTargets = writingTargetsEl.value; saveState(); debouncedGraph(); });
  writingNotesEl.addEventListener("input", () => { state.writingNotes = writingNotesEl.value; saveState(); debouncedGraph(); });

  proseScheduleEl.addEventListener("input", () => { state.proseSchedule = proseScheduleEl.value; saveState(); debouncedGraph(); });
  proseProjectEl.addEventListener("input", () => { state.proseProject = proseProjectEl.value; saveState(); debouncedGraph(); });
  proseTargetsEl.addEventListener("input", () => { state.proseTargets = proseTargetsEl.value; saveState(); debouncedGraph(); });
  proseNotesEl.addEventListener("input", () => { state.proseNotes = proseNotesEl.value; saveState(); debouncedGraph(); });

  downtimeRuleEl.addEventListener("input", () => { state.downtimeRule = downtimeRuleEl.value; saveState(); });

  if (openaiKeyEl) {
    openaiKeyEl.addEventListener("input", () => {
      state.llmKey = openaiKeyEl.value;
      saveState();
    });
  }

  // Mode editor
  el("btnAddMode").addEventListener("click", () => {
    const label = String(newModeLabelEl.value || "").trim();
    if (!label) { toast("Mode label is empty"); return; }
    if (state.modeChecks[label]) { toast("Mode already exists"); return; }
    const scope = newModeScopeEl.value === "daily" ? "daily" : "weekly";
    state.modeChecks[label] = false;
    state.modeScope[label] = scope;
    newModeLabelEl.value = "";
    saveState();
    renderModeChips();
    renderWeekSummary();
    debouncedForest();
  });

  // ---------- Buttons ----------

    // ---------- Buttons ----------
    el("btnAddTodayTask").addEventListener("click", () => {
      state.todayTasks.push({ id: uid(), done: false, title: "", course: state.keystoneToday || state.courses[0], mode: "(mode)" });
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
      toast("Added Today task");
      // focus newest title
      setTimeout(() => {
        const rows = todayTasksEl.querySelectorAll(".task input.title");
        rows[rows.length - 1]?.focus();
      }, 0);
    });

    el("btnClearTodayDone").addEventListener("click", () => {
      state.todayTasks = state.todayTasks.filter(t => !t.done);
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
      toast("Cleared completed Today tasks");
    });

    el("btnAddWeekendTask").addEventListener("click", () => {
      state.weekendTasks.push({ id: uid(), done: false, title: "", course: state.courses[0], mode: "(mode)" });
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
      toast("Added Weekend deliverable");
      setTimeout(() => {
        const rows = weekendTasksEl.querySelectorAll(".task input.title");
        rows[rows.length - 1]?.focus();
      }, 0);
    });

    el("btnClearWeekendDone").addEventListener("click", () => {
      state.weekendTasks = state.weekendTasks.filter(t => !t.done);
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
      toast("Cleared completed Weekend tasks");
    });

    el("btnApplyCourses").addEventListener("click", () => {
      const raw = String(courseListEl.value || "");
      const list = raw.split(";").map(x => x.trim()).filter(Boolean);

      if (!list.length) {
        toast("Course list is empty");
        return;
      }

      // Preserve existing notes where possible
      const old = state.courseNotes || {};
      const nextNotes = {};
      list.forEach(c => { nextNotes[c] = old[c] || { status: "steady", focus: "", budget: "", notes: "" }; });

      // Update tasks that pointed to removed courses -> move to first course
      const fallback = list[0];
      for (const t of [...state.todayTasks, ...state.weekendTasks]) {
        if (!list.includes(t.course)) t.course = fallback;
      }

      state.courses = list;
      state.courseNotes = nextNotes;

      if (!list.includes(state.keystoneToday)) state.keystoneToday = fallback;

      saveState();
      renderKeystoneDropdown();
      renderCourseCards();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
      toast("Applied courses");
    });

    // Markdown export buttons
    el("btnGenerateMd").addEventListener("click", async () => {
      if (openaiKeyEl && openaiKeyEl.value.trim()) {
        state.llmKey = openaiKeyEl.value.trim();
        saveState();
      }
      let usedGpt = false;
      if (state.llmKey) {
        try {
          const analyses = { ...(state.llmNoteAnalyses || {}) };
          for (const course of state.courses || []) {
            const noteText = state.courseNotes?.[course]?.notes || "";
            if (!noteText.trim()) continue;
            const res = await analyzeNotesWithGpt(course, noteText);
            if (res) analyses[course] = res;
          }
          state.llmNoteAnalyses = analyses;
          const response = await generateGptConferenceResponse();
          if (response) state.llmConferenceResponse = response;
          saveState();
          usedGpt = true;
        } catch (err) {
          console.warn("GPT markdown helpers failed", err);
          toast("GPT failed (fallback used)");
        }
      }
      const md = generateMarkdown({ forestFilename: "forest.jpg", graphFilename: "concept_graph.jpg" });
      setMdPreview(md);
      toast(usedGpt ? "Generated markdown (GPT)" : "Generated markdown");
    });

    el("btnCopyMd").addEventListener("click", async () => {
      const md = state.mdCache || generateMarkdown({ forestFilename: "forest.jpg", graphFilename: "concept_graph.jpg" });
      setMdPreview(md);
      try {
        await navigator.clipboard.writeText(md);
        toast("Copied");
      } catch {
        toast("Copy failed (browser blocked)");
      }
    });

    el("btnDownloadMd").addEventListener("click", () => {
      const md = state.mdCache || generateMarkdown({ forestFilename: "forest.jpg", graphFilename: "concept_graph.jpg" });
      setMdPreview(md);
      downloadText("download.md", md, "text/markdown");
      toast("Downloaded .md");
    });

    el("btnClearMd").addEventListener("click", () => {
      state.mdCache = "";
      saveState();
      mdPreviewEl.textContent = "(Generate markdown to preview here.)";
      toast("Cleared markdown");
    });

    el("btnArchiveBundle").addEventListener("click", async () => {
      try {
        const md = state.mdCache || generateMarkdown({ forestFilename: "forest.jpg", graphFilename: "concept_graph.jpg" });
        setMdPreview(md);
        const d = new Date();
        const yyyy = d.getFullYear();
        const mm = String(d.getMonth() + 1).padStart(2, "0");
        const dd = String(d.getDate()).padStart(2, "0");
        const folder = `Dashboard_${mm}/${dd}/${yyyy}`;
        const forestName = `${folder}/forest.jpg`;
        const graphName = `${folder}/concept_graph.jpg`;
        const mdName = `${folder}/download.md`;
        const forestUrl = forestCardDataUrl("image/jpeg", 0.92, state.forest.hiResPng ? 2 : 1);
        const graphUrl = conceptGraphPngDataUrl(1, "image/jpeg", 0.92);
        const mdBytes = textToUint8(md);
        const forestBytes = forestUrl ? dataUrlToUint8(forestUrl) : new Uint8Array();
        const graphBytes = graphUrl ? dataUrlToUint8(graphUrl) : new Uint8Array();
        const zip = zipFiles([
          { name: mdName, data: mdBytes },
          ...(forestUrl ? [{ name: forestName, data: forestBytes }] : []),
          ...(graphUrl ? [{ name: graphName, data: graphBytes }] : [])
        ]);
        const blob = new Blob([zip], { type: "application/zip" });
        downloadBlob("download.zip", blob);
        toast("Downloaded archive bundle");
      } catch {
        toast("Archive bundle failed");
      }
    });

    // Reset day/week checkboxes
    el("btnResetDay").addEventListener("click", () => {
      for (const k of Object.keys(state.modeChecks)) {
        if ((state.modeScope?.[k] || "weekly") === "daily") state.modeChecks[k] = false;
      }
      saveState();
      renderModeChips();
      renderWeekSummary();
      debouncedForest();
      toast("Reset daily modes");
    });

    el("btnResetWeek").addEventListener("click", () => {
      if (!lastForestGeom) renderForest();
      saveGhostSnapshot(state.forest.weekId || isoWeekId(new Date()));
      state.modeChecks = { ...structuredDefault().modeChecks };
      state.modeScope = { ...structuredDefault().modeScope };
      state.todayTasks = [];
      state.weekendTasks = [];
      state.todayNotes = "";
      state.writingNotes = "";
      state.writingThread = "";
      state.writingTargets = "";
      state.proseNotes = "";
      state.proseProject = "";
      state.proseTargets = "";
      Object.keys(state.courseNotes || {}).forEach((course) => {
        state.courseNotes[course].notes = "";
        state.courseNotes[course].status = "steady";
      });
      state.llmNoteAnalyses = {};
      state.llmConferenceResponse = "";
      state.forest.perCourseMax = {};
      state.forest.weekId = isoWeekId(new Date());
      state.forest.weekly = { weekId: state.forest.weekId, courses: {} };
      saveState();
      renderModeChips();
      renderTasks();
      renderCourseCards();
      renderWeekSummary();
      debouncedForest();
      toast("Reset week");
    });

    // Backup / reset
    el("btnBackup").addEventListener("click", () => {
      try {
        const dateISO = new Date().toISOString().slice(0,10);
        downloadText(`semester-dashboard_backup_${dateISO}.json`, JSON.stringify(state, null, 2), "application/json");
        toast("Exported JSON");
      } catch {
        toast("Export failed");
      }
    });

    el("btnHardReset").addEventListener("click", () => {
      const ok = confirm("Hard reset will wipe all locally saved dashboard data. Continue?");
      if (!ok) return;
      try { localStorage.removeItem(STORAGE_KEY); } catch {}
      state = structuredDefault();
      saveState();
      hydrateInputs();
      toast("Wiped local data");
    });

    el("btnPrintPreview").addEventListener("click", () => {
      setPrintPreview(!state.printPreview);
    });

    el("btnExitPrintPreview").addEventListener("click", () => {
      setPrintPreview(false);
    });

    // Forest controls
    el("btnToggleLegend").addEventListener("click", () => {
      state.forest.legendOn = !state.forest.legendOn;
      saveState();
      forestLegendEl.classList.toggle("show", !!state.forest.legendOn);
      toast(state.forest.legendOn ? "Legend on" : "Legend off");
    });

    toggleHiResPngEl.addEventListener("change", () => {
      state.forest.hiResPng = !!toggleHiResPngEl.checked;
      saveState();
      toast(state.forest.hiResPng ? "Hi-res JPG on" : "Hi-res JPG off");
    });

    if (toggleFullGhostEl) {
      toggleFullGhostEl.addEventListener("change", () => {
        state.forest.showFullGhost = !!toggleFullGhostEl.checked;
        saveState();
        debouncedForest();
        toast(state.forest.showFullGhost ? "Full ghost on" : "Full ghost off");
      });
    }

    el("btnExportPNG").addEventListener("click", () => {
      try {
        const dateISO = new Date().toISOString().slice(0,10);
        const url = forestCardDataUrl("image/jpeg", 0.92, state.forest.hiResPng ? 2 : 1);
        downloadDataUrl(`forest_${dateISO}.jpg`, url);
        toast("Exported JPG");
      } catch {
        toast("JPG export failed");
      }
    });

    el("btnExportSVG").addEventListener("click", () => {
      try {
        if (!lastForestGeom) renderForest();
        const dateISO = new Date().toISOString().slice(0,10);
        const svg = forestToSVG(lastForestGeom);
        downloadText(`forest_${dateISO}.svg`, svg, "image/svg+xml");
        toast("Exported SVG");
      } catch {
        toast("SVG export failed");
      }
    });

    el("btnClearGhost").addEventListener("click", () => {
      const current = isoWeekId(new Date());
      const prev = prevIsoWeekId(current);
      clearGhostSnapshot(prev);
      debouncedForest();
      toast("Cleared last-week ghost");
    });

    document.addEventListener("click", (e) => {
      if (!expandedCard) return;
      if (expandedCard.contains(e.target)) return;
      if (e.target.closest(".card-toggle")) return;
      setCardFocus(expandedCard, false);
    });

    // ---------- Responsive: rerender canvas on resize ----------
    window.addEventListener("resize", debounce(() => {
      debouncedForest();
    }, 120));

  async function fetchMaineEnvironment() {
    try {
      const url = "https://api.open-meteo.com/v1/forecast?latitude=43.6591&longitude=-70.2568&current_weather=true&hourly=relativehumidity_2m,cloudcover&timezone=America%2FNew_York";
      const res = await fetch(url);
      if (!res.ok) throw new Error("weather fetch failed");
      const data = await res.json();
      const current = data.current_weather || {};
      const hourly = data.hourly || {};
      const timeIndex = hourly.time ? hourly.time.indexOf(current.time) : -1;
      const humidity = timeIndex >= 0 ? hourly.relativehumidity_2m?.[timeIndex] : null;
      const cloudCover = timeIndex >= 0 ? hourly.cloudcover?.[timeIndex] : null;
      state.env = {
        temperature: current.temperature ?? 12,
        windSpeed: current.windspeed ?? 6,
        humidity: humidity ?? 65,
        cloudCover: cloudCover ?? 40,
        updated: current.time || new Date().toISOString()
      };
      saveState();
      debouncedForest();
    } catch {
      state.env = state.env || { temperature: 12, windSpeed: 6, humidity: 65, cloudCover: 40, updated: new Date().toISOString() };
      saveState();
    }
  }

  // ---------- Init ----------
  // Ensure weekId is set early to support ghost logic without flicker
  if (!state.forest.weekId) state.forest.weekId = isoWeekId(new Date());
  hydrateInputs();
  fetchMaineEnvironment();

    // If first load has no md cache, show empty but ready
    if (!state.mdCache) mdPreviewEl.textContent = "(Generate markdown to preview here.)";

  </script>
</body>
</html>
