<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Semester Dashboard — Modes + .md Export</title>
  <style>
    :root {
      --bg: #ffffff;
      --panel: #ffffff;
      --panel2: #ffffff;
      --text: #5a5a5a;
      --muted: #a7a8b6;
      --line: #dbdbdb;
      --accent: #f5f5ff;
      --chip: #cacbd1bf;
      --danger: #ff5c7a;
      --ok: #5cffc4;
      --warn: #ffd15c;
      --radius: 16px;
      --shadow: 0 10px 30px rgba(144, 144, 144, 0.35);
      --shadowSoft: 0 6px 18px rgba(144, 144, 144, 0.22);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --ink: #3a3d5e;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: var(--sans);
      background: radial-gradient(1200px 900px at 20% 0%, #ffffff 0%, var(--bg) 55%);
      color: var(--text);
    }
    :focus-visible { outline: 2px solid var(--ink); outline-offset: 2px; border-radius: 10px; }

    header {
      position: sticky;
      top: 0;
      z-index: 10;
      backdrop-filter: blur(10px);
      background: rgba(255, 255, 255, 0.7);
      border-bottom: 1px solid var(--line);
    }
    .wrap { max-width: 1180px; margin: 0 auto; padding: 18px 18px 48px; }
    .topbar {
      display: grid;
      grid-template-columns: 1.4fr 1fr;
      gap: 14px;
      align-items: start;
    }
    h1 { margin: 4px 0 2px; font-size: 18px; letter-spacing: .2px; }
    .subtitle { color: var(--muted); font-size: 13px; line-height: 1.4; }
    .controls {
      display: flex; gap: 10px; justify-content: flex-end; flex-wrap: wrap;
    }
    button, .btn {
      border: 1px solid var(--line);
      background: linear-gradient(180deg, #ffffff, #e6e6e6);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      cursor: pointer;
      box-shadow: var(--shadowSoft);
      font-weight: 600;
      font-size: 13px;
    }
    button:hover { border-color: var(--ink); }
    button:active { transform: translateY(1px); }
    .btn-secondary { background: linear-gradient(180deg, #ffffff, #d0d0d0); box-shadow: none; }
    .btn-danger { border-color: rgba(255,92,122,.35); }
    .btn-danger:hover { border-color: rgba(255,92,122,.65); }

    main { padding-top: 18px; }
    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 980px) {
      .topbar { grid-template-columns: 1fr; }
      .controls { justify-content: flex-start; }
      .grid { grid-template-columns: 1fr; }
    }

    .card {
      background: linear-gradient(180deg, rgb(255, 255, 255), rgb(255, 255, 255));
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 14px;
      box-shadow: var(--shadow);
    }
    .card h2 {
      margin: 0 0 10px;
      font-size: 14px;
      letter-spacing: .25px;
    }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .row > * { flex: 1; }
    .row .tight { flex: 0 0 auto; }
    label { font-size: 12px; color: var(--muted); display: block; margin: 8px 0 6px; }
    input[type="text"], input[type="number"], textarea, select {
      width: 100%;
      border: 1px solid var(--line);
      background: rgba(255, 255, 255, 0.65);
      color: var(--text);
      padding: 10px 10px;
      border-radius: 12px;
      outline: none;
      font-size: 13px;
    }
    textarea { min-height: 92px; resize: vertical; }
    .mini { font-size: 12px; color: var(--muted); margin-top: 8px; }

    .chips { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 6px; }
    .chip {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      background: var(--chip);
      border: 1px solid var(--line);
      padding: 8px 10px;
      border-radius: 999px;
      font-size: 12px;
      color: var(--text);
      user-select: none;
    }
    .chip input { transform: translateY(1px); }
    .pill {
      font-family: var(--mono);
      padding: 5px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.25);
      color: var(--muted);
      font-size: 11px;
      white-space: nowrap;
    }
    .pill.ink { color: var(--ink); border-color: rgba(58,61,94,.25); }

    .section-title {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      align-items: baseline;
      margin-bottom: 8px;
    }
    .section-title .hint { color: var(--muted); font-size: 12px; }

    .task {
      display: grid;
      grid-template-columns: 24px 1fr 110px 110px 34px;
      gap: 10px;
      align-items: center;
      padding: 9px 10px;
      border: 1px solid var(--line);
      background: rgba(255, 255, 255, 0.55);
      border-radius: 14px;
      margin-bottom: 8px;
    }
    .task input[type="checkbox"] { width: 18px; height: 18px; }
    .task input[type="text"] { padding: 9px 9px; }
    .task select { padding: 9px 9px; }
    .task .del {
      width: 34px; height: 34px; border-radius: 12px;
      background: rgba(255,92,122,.08);
      border: 1px solid rgba(255,92,122,.25);
      color: var(--text); cursor: pointer;
      box-shadow: none;
      font-weight: 900;
    }
    .task .del:hover { border-color: rgba(255,92,122,.55); }
    .task.done { opacity: .7; }
    .task.done .title { text-decoration: line-through; color: var(--muted); }

    .cols {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
    }
    @media (max-width: 980px) { .cols { grid-template-columns: 1fr; } }

    .mdbox {
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.45;
      white-space: pre-wrap;
      border: 1px dashed var(--ink);
      background: rgba(255, 255, 255, 0.25);
      padding: 12px;
      border-radius: 14px;
      min-height: 160px;
      max-height: 360px;
      overflow: auto;
    }

    .statusline { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
    .dot.ok { background: var(--ok); }
    .dot.warn { background: var(--warn); }
    .dot.bad { background: var(--danger); }

    .footer-note { color: var(--muted); font-size: 12px; margin-top: 10px; }
    a { color: var(--ink); }

    body.print-preview {
      background: #ffffff;
      color: #1f2234;
    }
    body.print-preview header {
      position: static;
      backdrop-filter: none;
      background: #ffffff;
    }
    body.print-preview .controls,
    body.print-preview button,
    body.print-preview .inlineForm,
    body.print-preview .del {
      display: none !important;
    }
    body.print-preview input,
    body.print-preview textarea,
    body.print-preview select {
      border: none;
      background: transparent;
      padding: 0;
      color: #1f2234;
      box-shadow: none;
    }
    body.print-preview .card {
      box-shadow: none;
    }

    @media print {
      header,
      .controls,
      button,
      .inlineForm,
      .del {
        display: none !important;
      }
      body {
        background: #ffffff;
        color: #1f2234;
      }
      .card {
        box-shadow: none;
      }
    }

    /* Toast */
    .toast {
      position: fixed;
      right: 16px;
      bottom: 16px;
      z-index: 50;
      background: rgba(255,255,255,.92);
      border: 1px solid var(--line);
      box-shadow: var(--shadowSoft);
      padding: 10px 12px;
      border-radius: 14px;
      font-size: 12px;
      color: var(--text);
      opacity: 0;
      transform: translateY(6px);
      pointer-events: none;
      transition: opacity .18s ease, transform .18s ease;
    }
    .toast.show { opacity: 1; transform: translateY(0px); }

    /* Inline form */
    .inlineForm {
      border: 1px solid var(--line);
      background: rgba(255,255,255,0.55);
      border-radius: 14px;
      padding: 10px;
      margin-top: 10px;
      display: none;
    }
    .inlineForm.show { display: block; }
    .inlineForm .cols { margin-top: 6px; }

    /* Forest */
    .span2 { grid-column: 1 / -1; } /* full-width card within the grid row */

    .forestWrap {
      border: 1px solid var(--line);
      background: rgba(255,255,255,0.55);
      border-radius: 14px;
      padding: 10px;
      margin-top: 10px;
      overflow: hidden;
    }
    canvas#forestCanvas {
      width: 100%;
      height: 680px; /* taller to show mycelium network beneath labels */
      display: block;
      border-radius: 12px;
      background: rgba(255,255,255,0.35);
    }
    .forestLegend {
      margin-top: 10px;
      border: 1px dashed rgba(58,61,94,.35);
      background: rgba(255,255,255,0.35);
      border-radius: 14px;
      padding: 10px;
      font-size: 12px;
      color: var(--muted);
      display: none;
    }
    .forestLegend.show { display: block; }
    .forestLegend b { color: var(--ink); }
    .forestLegend code { font-family: var(--mono); font-size: 11px; color: var(--ink); }

    /* Concept graph */
    #conceptGraphCanvas {
      width: 100%;
      height: 320px;
      display: block;
      border-radius: 12px;
      background: rgba(255,255,255,0.45);
      border: 1px dashed rgba(58,61,94,.2);
    }
    .graphHint { font-size: 12px; color: var(--muted); margin-top: 8px; }
  </style>
</head>

<body>
<header>
  <div class="wrap topbar">
    <div>
      <h1>Semester Dashboard — Courses, Modes, Writing + Obsidian Export</h1>
      <div class="subtitle">
        Default posture: <span class="pill">9–5 = material-building</span> • evenings/weekends = deliverables.
        Everything auto-saves locally.
        <span class="pill ink">Shortcuts:</span>
        <span class="pill">n = new Today task</span>
        <span class="pill">w = new Weekend deliverable</span>
        <span class="pill">g then m = generate .md</span>
        <span class="pill">Ctrl/⌘+S = save</span>
      </div>
    </div>
    <div class="controls">
      <button class="btn-secondary" id="btnResetDay">Reset “Day” checkboxes</button>
      <button class="btn-secondary" id="btnResetWeek">Reset “Week” checkboxes</button>
      <button class="btn-secondary" id="btnBackup">Export JSON backup</button>
      <button class="btn-secondary" id="btnPrintPreview">Print preview</button>
      <button class="btn-danger" id="btnHardReset">Hard reset (wipe local)</button>
    </div>
  </div>
</header>

<main class="wrap">
  <div class="grid">
    <!-- Left column: core structure -->
    <section class="card">
      <div class="section-title">
        <h2>Core Rhythm</h2>
        <div class="hint">Set the rules of engagement</div>
      </div>

      <label>Semester intent (1–2 sentences)</label>
      <input type="text" id="intent" placeholder="e.g., Build real understanding; avoid backlog; weekend slay sessions bounded." />

      <div class="cols" style="margin-top:10px;">
        <div>
          <label>Weekday core window</label>
          <input type="text" id="coreWindow" placeholder="e.g., 9:00–17:00" />
          <div class="mini">Used in the markdown export header.</div>
        </div>
        <div>
          <label>Weekend posture</label>
          <input type="text" id="weekendPosture" placeholder="e.g., deliverables + exam review + downtime" />
          <div class="mini">Keep bounded so it doesn’t become spillover.</div>
        </div>
        <div>
          <label>Weekly rebalance day</label>
          <select id="rebalanceDay">
            <option>Friday</option><option>Saturday</option><option>Sunday</option><option>Monday</option>
          </select>
          <div class="mini">20 minutes to re-allocate blocks.</div>
        </div>
      </div>

      <label style="margin-top:12px;">Modes checklist (daily + weekly anchors)</label>
      <div class="chips" id="modeChips"></div>

      <div class="footer-note">
        Tip: keep one protected “absorption block” each weekday (no new inputs; only consolidation).
      </div>
    </section>

    <!-- Right column: today planner -->
    <section class="card">
      <div class="section-title">
        <h2>Today — Focus & Blocks</h2>
        <div class="hint">Plan lightly; execute steadily</div>
      </div>

      <div class="cols">
        <div>
          <label>Keystone course today</label>
          <select id="keystoneToday"></select>
          <div class="mini">If this is stable, the day is stable.</div>
        </div>
        <div>
          <label>Absorption block (60–90 min)</label>
          <input type="text" id="absorption" placeholder="e.g., AOIC: re-derive key mechanisms + quiz-style Qs" />
        </div>
        <div>
          <label>Workout (quick note)</label>
          <input type="text" id="workout" placeholder="e.g., 35 min run + mobility" />
        </div>
      </div>

      <label style="margin-top:12px;">Quick capture (what matters / what’s fuzzy)</label>
      <textarea id="todayNotes" placeholder="2–6 bullet points: what landed, what’s confusing, what to ask ChatGPT / prof."></textarea>

      <div class="row" style="margin-top:10px;">
        <button id="btnAddTodayTask">+ Add Today Task</button>
        <button class="btn-secondary" id="btnClearTodayDone">Clear completed</button>
      </div>

      <div id="todayTasks" style="margin-top:10px;"></div>
    </section>
  </div>

  <!-- Week Summary FULL WIDTH -->
  <div class="grid" style="margin-top:14px;">
    <section class="card span2">
      <div class="section-title">
        <h2>Week Summary</h2>
        <div class="hint">Stability readout + forest (no extra data entry)</div>
      </div>

      <div id="weekSummary" class="mini"></div>

      <div class="forestWrap" aria-label="Weekly forest visualization">
        <div class="row" style="margin-bottom:10px;">
          <button class="btn-secondary" id="btnToggleLegend" title="Toggle legend">Legend</button>
          <button class="btn-secondary" id="btnExportPNG" title="Download forest as PNG">Export PNG</button>
          <button class="btn-secondary" id="btnExportSVG" title="Download forest as SVG">Export SVG</button>
          <button class="btn-secondary" id="btnClearGhost" title="Clear last-week ghost overlay">Clear ghost</button>
          <label class="chip tight" style="padding:6px 10px;">
            <input type="checkbox" id="toggleHiResPng" />
            Hi-res PNG
          </label>
        </div>

        <canvas id="forestCanvas"></canvas>

        <div id="forestLegend" class="forestLegend"></div>
      </div>

      <div class="footer-note">
        This is computed from tasks + course statuses + your writing. It grows during the week (max-growth memory for writing/task completion), and overlays last week as a faint trace. Stress and daily-mode checkboxes remain dynamic.
      </div>
    </section>
  </div>

  <div class="grid" style="margin-top:14px;">
    <!-- Courses -->
    <section class="card">
      <div class="section-title">
        <h2>Courses — Modes + Notes</h2>
        <div class="hint">Keep each course bounded</div>
      </div>

      <div class="row">
        <div>
          <label>Courses (editable)</label>
          <input type="text" id="courseList" placeholder="AOIC; Neurobiology; Biological Modeling; Calc II; Probability/Prereqs; GCAS Writing" />
          <div class="mini">Separate with semicolons.</div>
        </div>
        <div class="tight">
          <label>&nbsp;</label>
          <button class="btn-secondary" id="btnApplyCourses">Apply</button>
        </div>
      </div>

      <div id="courseCards" style="margin-top:12px;"></div>
    </section>

    <!-- Writing sessions -->
    <section class="card">
      <div class="section-title">
        <h2>GCAS Writing</h2>
        <div class="hint">Light, consistent, non-sprawling</div>
      </div>

      <div class="cols" style="margin-top:10px;">
        <div>
          <label>GCAS schedule</label>
          <input type="text" id="writingSchedule" placeholder="e.g., Tue/Thu afternoons" />
        </div>
        <div>
          <label>Current writing thread</label>
          <input type="text" id="writingThread" placeholder="e.g., Neural Set; Saussure/Lacan; modeling epistemology" />
        </div>
        <div>
          <label>GCAS targets</label>
          <input type="text" id="writingTargets" placeholder="e.g., 300 words target; Badiou set theory; Freud neurobiology" />
        </div>
      </div>
      <label style="margin-top:12px;">GCAS notes</label>
      <textarea id="writingNotes" placeholder="Short synthesis, questions, or conceptual bridges to keep."></textarea>
      <div class="footer-note">Keep cadence and conceptual targets lightweight but explicit.</div>
    </section>

    <!-- Concept graph -->
    <section class="card" style="grid-column: 1 / 2;">
      <div class="section-title">
        <h2>Concept Graph (3D)</h2>
        <div class="hint">Major concepts and linkages across writing</div>
      </div>
      <canvas id="conceptGraphCanvas" aria-label="3D concept linkage graph"></canvas>
      <div class="row" style="margin-top:10px;">
        <button class="btn-secondary" id="btnRegenGraph">Regenerate graph</button>
      </div>
      <div class="graphHint">Drag to rotate; scroll to zoom. Nodes are inferred from all writing artifacts.</div>
    </section>

    <!-- Prose writing -->
    <section class="card" style="grid-column: 2 / 3;">
      <div class="section-title">
        <h2>Prose Writing</h2>
        <div class="hint">Drafts, reflections, and narrative output</div>
      </div>

      <div class="cols" style="margin-top:10px;">
        <div>
          <label>Prose schedule</label>
          <input type="text" id="proseSchedule" placeholder="e.g., Wed/Fri afternoons" />
        </div>
        <div>
          <label>Current prose project</label>
          <input type="text" id="proseProject" placeholder="e.g., Semester reflection essay; narrative recap" />
        </div>
        <div>
          <label>Prose targets</label>
          <input type="text" id="proseTargets" placeholder="e.g., 300 words; draft scene; revision focus" />
        </div>
      </div>

      <label style="margin-top:12px;">Prose notes</label>
      <textarea id="proseNotes" placeholder="Short notes, tone cues, or narrative beats to keep." ></textarea>

      <div class="footer-note">Separate from GCAS; keep prose constraints visible.</div>
    </section>
  </div>

  <div class="grid" style="margin-top:14px;">
    <!-- Weekend deliverables -->
    <section class="card">
      <div class="section-title">
        <h2>Weekend Deliverables</h2>
        <div class="hint">Slay sessions with edges</div>
      </div>

      <div class="row">
        <button id="btnAddWeekendTask">+ Add deliverable</button>
        <button class="btn-secondary" id="btnClearWeekendDone">Clear completed</button>
      </div>

      <div id="weekendTasks" style="margin-top:10px;"></div>

      <label style="margin-top:12px;">Downtime boundary (write it like a rule)</label>
      <input type="text" id="downtimeRule" placeholder="e.g., Sat night off; Sun morning slow; no work after 8pm." />
    </section>

    <!-- Markdown export -->
    <section class="card">
      <div class="section-title">
        <h2>.md Export (Obsidian)</h2>
        <div class="hint">Generate, copy, download</div>
      </div>

      <div class="row">
        <button id="btnGenerateMd">Generate Markdown</button>
        <button class="btn-secondary" id="btnCopyMd">Copy</button>
        <button class="btn-secondary" id="btnDownloadMd">Download .md</button>
        <button class="btn-secondary" id="btnArchiveBundle">Archive bundle</button>
      </div>

      <label style="margin-top:12px;">Markdown preview</label>
      <div id="mdPreview" class="mdbox"></div>

      <div class="statusline" style="margin-top:10px;">
        <span class="dot ok"></span><span class="mini">Saved locally</span>
        <span class="dot warn"></span><span class="mini">Reset week = clears “weekly” checkboxes only</span>
        <span class="dot bad"></span><span class="mini">Hard reset wipes everything</span>
      </div>
    </section>
  </div>
</main>

<div id="toast" class="toast" role="status" aria-live="polite"></div>

<script>
  // ---------- Version + migration ----------
  const STORAGE_KEY = "semester_dashboard_v1";
  const CURRENT_VERSION = 7; // bumped for concept graph + schedule inputs

  const DEFAULT = {
    version: CURRENT_VERSION,

    intent: "",
    coreWindow: "9:00–17:00",
    weekendPosture: "Deliverables + exam review + downtime",
    rebalanceDay: "Sunday",

    // Daily vs weekly semantics
    modeScope: {
      "Attend sync lecture/recitation": "weekly",
      "Watch async lecture(s)": "weekly",
      "Reading upkeep": "daily",
      "Absorption block (no new inputs)": "daily",
      "Prereq / review": "weekly",
      "Light writing (GCAS / synthesis)": "weekly",
      "Admin / grants (small churn)": "weekly",
      "Exercise": "daily",
    },

    modeChecks: {
      "Attend sync lecture/recitation": false,
      "Watch async lecture(s)": false,
      "Reading upkeep": false,
      "Absorption block (no new inputs)": false,
      "Prereq / review": false,
      "Light writing (GCAS / synthesis)": false,
      "Admin / grants (small churn)": false,
      "Exercise": false,
    },

    courses: ["AOIC", "Neurobiology", "Biological Modeling", "Calc II", "Probability/Prereqs", "GCAS Writing"],
    courseNotes: {},

    keystoneToday: "AOIC",
    absorption: "",
    workout: "",
    todayNotes: "",
    todayTasks: [],
    weekendTasks: [],

    writingSchedule: "Tue/Thu afternoons",
    writingThread: "",
    writingTargets: "300 words target; Badiou set theory; Freud neurobiology",
    writingNotes: "",

    proseSchedule: "Wed/Fri afternoons",
    proseProject: "",
    proseTargets: "300 words; draft scene; revision focus",
    proseNotes: "",

    env: null,

    downtimeRule: "",
    mdCache: "",
    lastExport: null,
    printPreview: false,

    // Forest
    forest: {
      legendOn: false,
      weekId: "",
      perCourseMax: {},   // max-memory for writing volume / syntax / cohesion / completed tasks
      hiResPng: false,
    }
  };

  function structuredDefault() {
    return (typeof structuredClone === "function")
      ? structuredClone(DEFAULT)
      : JSON.parse(JSON.stringify(DEFAULT));
  }

  function migrateState(s) {
    const v = s?.version || 1;
    if (v < 2) {
      s.modeScope = s.modeScope || structuredDefault().modeScope;
      s.version = 2;
    }
    if (v < 3) {
      s.forest = s.forest || structuredDefault().forest;
      s.version = 3;
    }
    if (v < 4) {
      // v4: remove maxStress storage if present; keep only the intended max-memory metrics
      if (s.forest?.perCourseMax) {
        for (const k of Object.keys(s.forest.perCourseMax)) {
          if ("maxStress" in s.forest.perCourseMax[k]) delete s.forest.perCourseMax[k].maxStress;
        }
      }
      s.version = 4;
    }
    if (v < 5) {
      s.proseProject = s.proseProject ?? "";
      s.proseNotes = s.proseNotes ?? "";
      s.version = 5;
    }
    if (v < 6) {
      s.lastExport = s.lastExport ?? null;
      s.printPreview = s.printPreview ?? false;
      s.forest = s.forest || structuredDefault().forest;
      s.forest.hiResPng = s.forest.hiResPng ?? false;
      s.version = 6;
    }
    if (v < 7) {
      s.writingSchedule = s.writingSchedule ?? structuredDefault().writingSchedule;
      s.writingTargets = s.writingTargets ?? structuredDefault().writingTargets;
      s.writingNotes = s.writingNotes ?? "";
      s.proseSchedule = s.proseSchedule ?? structuredDefault().proseSchedule;
      s.proseTargets = s.proseTargets ?? structuredDefault().proseTargets;
      s.env = s.env ?? null;
      s.version = 7;
    }
    return s;
  }

  function loadState() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return structuredDefault();
      const parsed = migrateState(JSON.parse(raw));
      const def = structuredDefault();
      return {
        ...def,
        ...parsed,
        version: CURRENT_VERSION,
        modeChecks: { ...def.modeChecks, ...(parsed.modeChecks||{}) },
        modeScope:  { ...def.modeScope,  ...(parsed.modeScope||{})  },
        forest:     { ...def.forest,     ...(parsed.forest||{})     },
      };
    } catch {
      return structuredDefault();
    }
  }

  let state = loadState();

  function saveState() {
    state.version = CURRENT_VERSION;
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  }

  function uid() {
    return Math.random().toString(16).slice(2) + Date.now().toString(16);
  }

  // ---------- Toast ----------
  let toastTimer = null;
  function toast(msg) {
    const t = document.getElementById("toast");
    t.textContent = msg;
    t.classList.add("show");
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => t.classList.remove("show"), 1200);
  }

  // ---------- Elements ----------
  const el = (id) => document.getElementById(id);

  const intentEl = el("intent");
  const coreWindowEl = el("coreWindow");
  const weekendPostureEl = el("weekendPosture");
  const rebalanceDayEl = el("rebalanceDay");
  const modeChipsEl = el("modeChips");

  const keystoneTodayEl = el("keystoneToday");
  const absorptionEl = el("absorption");
  const workoutEl = el("workout");
  const todayNotesEl = el("todayNotes");
  const todayTasksEl = el("todayTasks");

  const weekSummaryEl = el("weekSummary");

  const courseListEl = el("courseList");
  const courseCardsEl = el("courseCards");

  const writingScheduleEl = el("writingSchedule");
  const writingThreadEl = el("writingThread");
  const writingTargetsEl = el("writingTargets");
  const writingNotesEl = el("writingNotes");

  const proseScheduleEl = el("proseSchedule");
  const proseProjectEl = el("proseProject");
  const proseTargetsEl = el("proseTargets");
  const proseNotesEl = el("proseNotes");
  const conceptGraphCanvas = el("conceptGraphCanvas");
  const btnRegenGraph = el("btnRegenGraph");

  const weekendTasksEl = el("weekendTasks");
  const downtimeRuleEl = el("downtimeRule");

  const mdPreviewEl = el("mdPreview");

  // Forest elements
  const forestCanvas = el("forestCanvas");
  const forestLegendEl = el("forestLegend");
  const toggleHiResPngEl = el("toggleHiResPng");

  // ---------- Utilities ----------
  function escapeHtml(s) {
    return (s || "").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
  }

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function getCSSVar(name){
    return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
  }

  function debounce(fn, ms){
    let t = null;
    return (...args) => {
      clearTimeout(t);
      t = setTimeout(() => fn(...args), ms);
    };
  }

  // ISO week id: YYYY-Www
  function isoWeekId(date = new Date()) {
    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    const dayNum = d.getUTCDay() || 7; // Mon=1..Sun=7
    d.setUTCDate(d.getUTCDate() + 4 - dayNum);
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    const y = d.getUTCFullYear();
    const w = String(weekNo).padStart(2, "0");
    return `${y}-W${w}`;
  }

  function prevIsoWeekId(currentId){
    const [yPart, wPart] = currentId.split("-W");
    const y = Number(yPart);
    const w = Number(wPart);
    const jan4 = new Date(Date.UTC(y, 0, 4));
    const dayNum = jan4.getUTCDay() || 7;
    const mondayWeek1 = new Date(jan4);
    mondayWeek1.setUTCDate(jan4.getUTCDate() - (dayNum - 1));
    const mondayTarget = new Date(mondayWeek1);
    mondayTarget.setUTCDate(mondayWeek1.getUTCDate() + (w - 1) * 7);
    mondayTarget.setUTCDate(mondayTarget.getUTCDate() - 7);
    return isoWeekId(new Date(mondayTarget.getUTCFullYear(), mondayTarget.getUTCMonth(), mondayTarget.getUTCDate()));
  }

  // ---------- Render helpers ----------
  function renderModeChips() {
    modeChipsEl.innerHTML = "";
    const labels = Object.keys(state.modeChecks);

    labels.forEach((label) => {
      const chip = document.createElement("label");
      chip.className = "chip";

      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.checked = !!state.modeChecks[label];
      cb.addEventListener("change", () => {
        state.modeChecks[label] = cb.checked;
        saveState();
        renderWeekSummary();
        debouncedForest(); // dynamic response to daily checkbox changes
      });

      const span = document.createElement("span");
      span.textContent = label;

      const scope = document.createElement("span");
      scope.className = "pill";
      scope.textContent = (state.modeScope?.[label] || "weekly").toUpperCase();

      chip.appendChild(cb);
      chip.appendChild(span);
      chip.appendChild(scope);
      modeChipsEl.appendChild(chip);
    });
  }

  function renderKeystoneDropdown() {
    keystoneTodayEl.innerHTML = "";
    state.courses.forEach((c) => {
      const opt = document.createElement("option");
      opt.value = c;
      opt.textContent = c;
      keystoneTodayEl.appendChild(opt);
    });
    keystoneTodayEl.value = state.keystoneToday || state.courses[0] || "";
  }

  function renderCourseCards() {
    courseCardsEl.innerHTML = "";
    state.courses.forEach((course) => {
      if (!state.courseNotes[course]) {
        state.courseNotes[course] = { status: "steady", focus: "", budget: "", notes: "" };
      }
      const data = state.courseNotes[course];

      const card = document.createElement("div");
      card.className = "card";
      card.style.marginBottom = "10px";

      const title = document.createElement("div");
      title.className = "section-title";
      title.innerHTML = `<h2>${escapeHtml(course)}</h2><div class="hint">bounded notes + focus modes</div>`;
      card.appendChild(title);

      const row = document.createElement("div");
      row.className = "cols";

      const col1 = document.createElement("div");
      col1.innerHTML = `<label>Status</label>`;
      const status = document.createElement("select");
      ["steady","watch","hot","danger"].forEach(s => {
        const opt = document.createElement("option");
        opt.value = s;
        opt.textContent = s;
        status.appendChild(opt);
      });
      status.value = data.status || "steady";
      status.addEventListener("change", () => {
        state.courseNotes[course].status = status.value;
        saveState();
        renderWeekSummary();
        debouncedForest(); // dynamic response to stress changes
      });
      col1.appendChild(status);

      const col2 = document.createElement("div");
      col2.innerHTML = `<label>Focus (this week)</label>`;
      const focus = document.createElement("input");
      focus.type = "text";
      focus.placeholder = "e.g., AOIC quiz prep; Neuro: lecture map; Modeling: tools + first HW";
      focus.value = data.focus || "";
      focus.addEventListener("input", () => {
        state.courseNotes[course].focus = focus.value;
        saveState();
        debouncedGraph();
      });
      col2.appendChild(focus);

      const col3 = document.createElement("div");
      col3.innerHTML = `<label>Block budget</label>`;
      const budget = document.createElement("input");
      budget.type = "text";
      budget.placeholder = "e.g., 1 deep block + 2 light blocks";
      budget.value = data.budget || "";
      budget.addEventListener("input", () => {
        state.courseNotes[course].budget = budget.value;
        saveState();
        debouncedGraph();
      });
      col3.appendChild(budget);

      row.appendChild(col1); row.appendChild(col2); row.appendChild(col3);
      card.appendChild(row);

      const notesLabel = document.createElement("label");
      notesLabel.style.marginTop = "10px";
      notesLabel.textContent = "Notes (what landed / what’s fuzzy / next question)";
      card.appendChild(notesLabel);

      const notes = document.createElement("textarea");
      notes.value = data.notes || "";
      notes.placeholder = "Keep it short. Capture confusion early.";
      notes.addEventListener("input", () => {
        state.courseNotes[course].notes = notes.value;
        saveState();
        debouncedForest(); // update forest as you write
        debouncedGraph();
      });
      card.appendChild(notes);

      courseCardsEl.appendChild(card);
    });

    saveState();
    renderWeekSummary();
  }

  function taskRow(task, listName) {
    const row = document.createElement("div");
    row.className = "task" + (task.done ? " done" : "");

    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.checked = !!task.done;
    cb.addEventListener("change", () => {
      task.done = cb.checked;
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest(); // dynamic response to task completion changes
    });

    const title = document.createElement("input");
    title.type = "text";
    title.className = "title";
    title.value = task.title || "";
    title.placeholder = "Task (bounded, concrete)";
    title.addEventListener("input", () => {
      task.title = title.value;
      saveState();
      debouncedForest();
    });

    title.addEventListener("blur", () => {
      if (!String(task.title || "").trim()) toast("Task title is empty (export will mark as untitled).");
    });

    const course = document.createElement("select");
    state.courses.forEach((c) => {
      const opt = document.createElement("option");
      opt.value = c;
      opt.textContent = c;
      course.appendChild(opt);
    });
    course.value = task.course || state.courses[0];
    course.addEventListener("change", () => {
      task.course = course.value;
      saveState();
      renderWeekSummary();
      debouncedForest();
    });

    const mode = document.createElement("select");
    const modes = Object.keys(state.modeChecks);
    ["(mode)", ...modes].forEach((m) => {
      const opt = document.createElement("option");
      opt.value = m;
      opt.textContent = m;
      mode.appendChild(opt);
    });
    mode.value = task.mode || "(mode)";
    mode.addEventListener("change", () => {
      task.mode = mode.value;
      saveState();
      debouncedForest();
    });

    const del = document.createElement("button");
    del.className = "del";
    del.textContent = "×";
    del.title = "Delete";
    del.addEventListener("click", () => {
      state[listName] = state[listName].filter((t) => t.id !== task.id);
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
    });

    row.appendChild(cb);
    row.appendChild(title);
    row.appendChild(course);
    row.appendChild(mode);
    row.appendChild(del);
    return row;
  }

  function renderTasks() {
    todayTasksEl.innerHTML = "";
    state.todayTasks.forEach((t) => todayTasksEl.appendChild(taskRow(t, "todayTasks")));

    weekendTasksEl.innerHTML = "";
    state.weekendTasks.forEach((t) => weekendTasksEl.appendChild(taskRow(t, "weekendTasks")));
  }

  // ---------- Concept graph ----------
  let graphState = null;

  function collectWritingCorpus() {
    const parts = [];
    if (state.todayNotes) parts.push(state.todayNotes);
    state.courses.forEach((course) => {
      const c = state.courseNotes[course] || {};
      if (c.focus) parts.push(c.focus);
      if (c.budget) parts.push(c.budget);
      if (c.notes) parts.push(c.notes);
    });
    if (state.writingSchedule) parts.push(state.writingSchedule);
    if (state.writingThread) parts.push(state.writingThread);
    if (state.writingTargets) parts.push(state.writingTargets);
    if (state.writingNotes) parts.push(state.writingNotes);
    if (state.proseSchedule) parts.push(state.proseSchedule);
    if (state.proseProject) parts.push(state.proseProject);
    if (state.proseTargets) parts.push(state.proseTargets);
    if (state.proseNotes) parts.push(state.proseNotes);
    return normalizeText(parts.join(" "));
  }

  function computeConceptGraph() {
    const corpus = collectWritingCorpus();
    if (!corpus) return { nodes: [], edges: [] };
    const keywords = topNWords(corpus, 16).map(x => x.w);
    const nodes = keywords.map((w) => ({
      id: w,
      label: w,
      x: (Math.random() - 0.5) * 1.6,
      y: (Math.random() - 0.5) * 1.6,
      z: (Math.random() - 0.5) * 1.6,
      size: 6
    }));
    const edges = [];
    const sentences = splitSentences(corpus);
    const keywordSet = new Set(keywords);
    const edgeMap = new Map();

    sentences.forEach((sentence) => {
      const words = contentWords(sentence);
      const present = Array.from(new Set(words.filter((w) => keywordSet.has(w))));
      for (let i = 0; i < present.length; i++) {
        for (let j = i + 1; j < present.length; j++) {
          const key = [present[i], present[j]].sort().join("|");
          edgeMap.set(key, (edgeMap.get(key) || 0) + 1);
        }
      }
    });

    const degree = new Map();
    for (const [pair, weight] of edgeMap.entries()) {
      const [a, b] = pair.split("|");
      edges.push({ a, b, weight });
      degree.set(a, (degree.get(a) || 0) + weight);
      degree.set(b, (degree.get(b) || 0) + weight);
    }

    nodes.forEach((node) => {
      node.size = 6 + Math.min(10, (degree.get(node.id) || 1) * 0.6);
    });

    return { nodes, edges };
  }

  function projectPoint(node, rotX, rotY, zoom, w, h) {
    let { x, y, z } = node;
    const cosY = Math.cos(rotY);
    const sinY = Math.sin(rotY);
    const cosX = Math.cos(rotX);
    const sinX = Math.sin(rotX);

    const dx = x * cosY - z * sinY;
    const dz = x * sinY + z * cosY;
    const dy = y * cosX - dz * sinX;
    const dz2 = y * sinX + dz * cosX;

    const perspective = zoom / (zoom + dz2 + 2.2);
    return {
      x: w / 2 + dx * w * 0.25 * perspective,
      y: h / 2 + dy * h * 0.25 * perspective,
      scale: perspective
    };
  }

  function renderConceptGraph() {
    if (!conceptGraphCanvas) return;
    if (!graphState) {
      graphState = {
        data: computeConceptGraph(),
        rotX: -0.25,
        rotY: 0.25,
        zoom: 2.4,
        dragging: false,
        lastX: 0,
        lastY: 0
      };
      attachGraphHandlers();
      requestAnimationFrame(drawConceptGraph);
    } else {
      graphState.data = computeConceptGraph();
    }
  }

  function attachGraphHandlers() {
    conceptGraphCanvas.addEventListener("mousedown", (e) => {
      graphState.dragging = true;
      graphState.lastX = e.clientX;
      graphState.lastY = e.clientY;
    });
    window.addEventListener("mouseup", () => {
      if (graphState) graphState.dragging = false;
    });
    window.addEventListener("mousemove", (e) => {
      if (!graphState?.dragging) return;
      const dx = e.clientX - graphState.lastX;
      const dy = e.clientY - graphState.lastY;
      graphState.rotY += dx * 0.005;
      graphState.rotX += dy * 0.005;
      graphState.lastX = e.clientX;
      graphState.lastY = e.clientY;
    });
    conceptGraphCanvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      graphState.zoom = clamp(graphState.zoom + e.deltaY * 0.004, 1.0, 12);
    }, { passive: false });
    btnRegenGraph?.addEventListener("click", () => {
      graphState.data = computeConceptGraph();
      toast("Regenerated concept graph");
    });
  }

  function drawConceptGraph() {
    if (!conceptGraphCanvas || !graphState) return;
    const { ctx, w, h } = initCanvasHiDPI(conceptGraphCanvas);
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = "rgba(255,255,255,0.4)";
    ctx.fillRect(0, 0, w, h);

    const { nodes, edges } = graphState.data;
    if (!nodes.length) {
      ctx.fillStyle = "#8b8c9b";
      ctx.font = "12px " + getCSSVar("--sans");
      ctx.textAlign = "center";
      ctx.fillText("No writing data yet to generate concepts.", w / 2, h / 2);
      requestAnimationFrame(drawConceptGraph);
      return;
    }

    const projections = new Map();
    nodes.forEach((node) => {
      projections.set(node.id, projectPoint(node, graphState.rotX, graphState.rotY, graphState.zoom, w, h));
    });

    ctx.strokeStyle = "rgba(58,61,94,0.25)";
    edges.forEach((edge) => {
      const a = projections.get(edge.a);
      const b = projections.get(edge.b);
      if (!a || !b) return;
      ctx.lineWidth = Math.max(0.6, edge.weight * 0.6);
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();
    });

    nodes.forEach((node) => {
      const p = projections.get(node.id);
      if (!p) return;
      const radius = node.size * p.scale;
      ctx.fillStyle = "#111111";
      ctx.beginPath();
      ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#111111";
      ctx.font = `${Math.max(9, 10 * p.scale)}px ${getCSSVar("--sans")}`;
      ctx.textAlign = "center";
      ctx.fillText(node.label, p.x, p.y - radius - 4);
    });

    graphState.rotY += 0.0015;
    requestAnimationFrame(drawConceptGraph);
  }

  // ---------- Week summary ----------
  function renderWeekSummary() {
    const openToday = state.todayTasks.filter(t => !t.done).length;
    const openWeekend = state.weekendTasks.filter(t => !t.done).length;
    const doneToday = state.todayTasks.filter(t => t.done).length;
    const doneWeekend = state.weekendTasks.filter(t => t.done).length;

    const flagged = state.courses
      .map(c => ({ course: c, status: (state.courseNotes[c] || {}).status || "steady" }))
      .filter(x => x.status === "hot" || x.status === "danger");

    const keystone = state.keystoneToday || "";
    const keystoneOpen = state.todayTasks.filter(t => !t.done && t.course === keystone).length;

    const dailyTotal = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="daily").length || 1;
    const weeklyTotal = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="weekly").length || 1;

    const dailyChecked = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="daily" && state.modeChecks[k]).length;
    const weeklyChecked = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="weekly" && state.modeChecks[k]).length;

    const lines = [];
    lines.push(`Open tasks: <b>${openToday + openWeekend}</b> (Today ${openToday}, Weekend ${openWeekend})`);
    lines.push(`Completed tasks: ${doneToday + doneWeekend} (Today ${doneToday}, Weekend ${doneWeekend})`);
    lines.push(`Keystone: <b>${escapeHtml(keystone)}</b> — open today tasks in keystone: <b>${keystoneOpen}</b>`);
    lines.push(`Modes checked: daily ${dailyChecked}/${dailyTotal} • weekly ${weeklyChecked}/${weeklyTotal}`);

    if (flagged.length) {
      const list = flagged.map(x => `${escapeHtml(x.course)}: <code>${escapeHtml(x.status)}</code>`).join(" • ");
      lines.push(`Flagged courses: <b>${flagged.length}</b> — ${list}`);
    } else {
      lines.push(`Flagged courses: 0`);
    }

    weekSummaryEl.innerHTML = `<div style="display:grid;gap:6px;">${lines.map(x => `<div>${x}</div>`).join("")}</div>`;
    debouncedForest();
  }

  // ---------- Markdown generation ----------
  function mdCheckbox(label, checked) {
    return `- [${checked ? "x" : " "}] ${label}`;
  }

  function obsidianLink(name) {
    const safe = String(name || "").replaceAll("]","\\]");
    return `[[${safe}]]`;
  }

  function slugTag(word) {
    return String(word || "")
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/^-+|-+$/g, "");
  }

  const KEYWORD_SKIP = new Set([
    "make","made","making","made","need","needs","needed","want","wants","wanted",
    "good","better","best","bad","worse","worst","thing","things","stuff","like",
    "use","used","using","get","got","getting","should","could","would","might"
  ]);

  function titleCase(word) {
    const s = String(word || "");
    return s ? s[0].toUpperCase() + s.slice(1) : "";
  }

  function keyPhrases(text, n = 6) {
    const sentences = splitSentences(text);
    const freq = new Map();
    sentences.forEach((sentence) => {
      const words = contentWords(sentence);
      for (let i = 0; i < words.length; i++) {
        for (let size = 2; size <= 4; size++) {
          const slice = words.slice(i, i + size);
          if (slice.length < size) continue;
          const phrase = slice.join(" ");
          if (KEYWORD_SKIP.has(phrase)) continue;
          freq.set(phrase, (freq.get(phrase) || 0) + 1);
        }
      }
    });
    return Array.from(freq.entries())
      .sort((a, b) => b[1] - a[1])
      .map(([phrase]) => phrase)
      .slice(0, n);
  }

  function noteKeywords(text, n = 6) {
    return keyPhrases(text, n);
  }

  function titleCasePhrase(phrase) {
    return phrase.split(" ").map(titleCase).join(" ");
  }

  function noteTitleFromKeywords(keywords) {
    if (!keywords.length) return "Untitled Note";
    return keywords.slice(0, 2).map(titleCasePhrase).join(" · ");
  }

  function extractProperNouns(text, n = 6) {
    const raw = String(text || "");
    const matches = raw.match(/\b(?:[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\b/g) || [];
    const extras = raw.match(/\b\d{1,2}(?:st|nd|rd|th)\s+century\b/gi) || [];
    const seen = new Set();
    const out = [];
    [...matches, ...extras].forEach((m) => {
      const cleaned = m.trim();
      if (!cleaned || cleaned.length < 3) return;
      if (STOP.has(cleaned.toLowerCase())) return;
      const key = cleaned.toLowerCase();
      if (!seen.has(key)) {
        seen.add(key);
        out.push(cleaned);
      }
    });
    return out.slice(0, n);
  }

  function formatProperNounTags(text) {
    return extractProperNouns(text, 8)
      .map((name) => slugTag(name))
      .filter(Boolean)
      .map((tag) => `#${tag}`);
  }

  function percent(n) {
    return `${Math.round(n * 100)}%`;
  }

  function forestPngDataUrl(scale = 1) {
    renderForest();
    const src = forestCanvas;
    if (scale <= 1) return src.toDataURL("image/png");
    const rect = src.getBoundingClientRect();
    const w = Math.max(1, Math.floor(rect.width));
    const h = Math.max(1, Math.floor(rect.height));
    const tmp = document.createElement("canvas");
    tmp.width = Math.floor(w * scale);
    tmp.height = Math.floor(h * scale);
    const tctx = tmp.getContext("2d");
    tctx.drawImage(src, 0, 0, w, h, 0, 0, tmp.width, tmp.height);
    return tmp.toDataURL("image/png");
  }

  function exportForestPngForMarkdown(dateISO, hiRes) {
    try {
      const filename = `forest_${dateISO}${hiRes ? "_hires" : ""}.png`;
      const url = forestPngDataUrl(hiRes ? 2 : 1);
      downloadDataUrl(filename, url);
      return filename;
    } catch {
      return "";
    }
  }

  function formatDelta(delta) {
    const pct = Math.round(delta * 100);
    if (!pct) return "0%";
    return `${pct > 0 ? "+" : ""}${pct}%`;
  }

  function crc32(buf) {
    const table = crc32.table || (crc32.table = (() => {
      const t = new Uint32Array(256);
      for (let i = 0; i < 256; i++) {
        let c = i;
        for (let k = 0; k < 8; k++) {
          c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
        }
        t[i] = c >>> 0;
      }
      return t;
    })());
    let crc = 0xFFFFFFFF;
    for (let i = 0; i < buf.length; i++) {
      crc = table[(crc ^ buf[i]) & 0xFF] ^ (crc >>> 8);
    }
    return (crc ^ 0xFFFFFFFF) >>> 0;
  }

  function textToUint8(text) {
    return new TextEncoder().encode(text);
  }

  function dataUrlToUint8(dataUrl) {
    const [meta, data] = dataUrl.split(",");
    const isBase64 = meta.includes(";base64");
    if (!isBase64) return textToUint8(decodeURIComponent(data));
    const bin = atob(data);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
    return arr;
  }

  function zipFiles(files) {
    const records = [];
    let offset = 0;

    files.forEach((file) => {
      const nameBytes = textToUint8(file.name);
      const data = file.data;
      const crc = crc32(data);
      const localHeader = new Uint8Array(30 + nameBytes.length);
      const view = new DataView(localHeader.buffer);
      view.setUint32(0, 0x04034b50, true);
      view.setUint16(4, 20, true);
      view.setUint16(6, 0, true);
      view.setUint16(8, 0, true);
      view.setUint16(10, 0, true);
      view.setUint16(12, 0, true);
      view.setUint32(14, crc, true);
      view.setUint32(18, data.length, true);
      view.setUint32(22, data.length, true);
      view.setUint16(26, nameBytes.length, true);
      view.setUint16(28, 0, true);
      localHeader.set(nameBytes, 30);

      const centralHeader = new Uint8Array(46 + nameBytes.length);
      const cview = new DataView(centralHeader.buffer);
      cview.setUint32(0, 0x02014b50, true);
      cview.setUint16(4, 20, true);
      cview.setUint16(6, 20, true);
      cview.setUint16(8, 0, true);
      cview.setUint16(10, 0, true);
      cview.setUint16(12, 0, true);
      cview.setUint16(14, 0, true);
      cview.setUint32(16, crc, true);
      cview.setUint32(20, data.length, true);
      cview.setUint32(24, data.length, true);
      cview.setUint16(28, nameBytes.length, true);
      cview.setUint16(30, 0, true);
      cview.setUint16(32, 0, true);
      cview.setUint16(34, 0, true);
      cview.setUint16(36, 0, true);
      cview.setUint32(38, 0, true);
      cview.setUint32(42, offset, true);
      centralHeader.set(nameBytes, 46);

      records.push({ localHeader, data, centralHeader });
      offset += localHeader.length + data.length;
    });

    const centralSize = records.reduce((sum, r) => sum + r.centralHeader.length, 0);
    const end = new Uint8Array(22);
    const endView = new DataView(end.buffer);
    endView.setUint32(0, 0x06054b50, true);
    endView.setUint16(4, 0, true);
    endView.setUint16(6, 0, true);
    endView.setUint16(8, records.length, true);
    endView.setUint16(10, records.length, true);
    endView.setUint32(12, centralSize, true);
    endView.setUint32(16, offset, true);
    endView.setUint16(20, 0, true);

    const totalSize = offset + centralSize + end.length;
    const out = new Uint8Array(totalSize);
    let ptr = 0;
    records.forEach((r) => {
      out.set(r.localHeader, ptr);
      ptr += r.localHeader.length;
      out.set(r.data, ptr);
      ptr += r.data.length;
    });
    records.forEach((r) => {
      out.set(r.centralHeader, ptr);
      ptr += r.centralHeader.length;
    });
    out.set(end, ptr);
    return out;
  }

  function downloadBlob(filename, blob) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function wordCount(text) {
    return String(text || "").trim().split(/\s+/).filter(Boolean).length;
  }

  function enforceWordCount(text, target) {
    let words = String(text || "").trim().split(/\s+/).filter(Boolean);
    const filler = [
      "The argument would benefit from clearer operational definitions and a sharper distinction between descriptive claims and interpretive stakes.",
      "Methodologically, a tighter articulation of evidence warrants would strengthen the transition from observation to inference.",
      "The conceptual framing aligns with literature on knowledge-building communities and warrants further triangulation with empirical traces.",
      "I encourage foregrounding how the analytic lens translates into concrete revision decisions for the next iteration."
    ];
    let i = 0;
    while (words.length < target) {
      words = words.concat(filler[i % filler.length].split(/\s+/));
      i += 1;
    }
    if (words.length > target) words = words.slice(0, target);
    return words.join(" ");
  }

  function buildConferenceResponse(context) {
    const keywords = context.keywords.length ? context.keywords.join(", ") : "core concepts";
    const linkage = context.linkages.length ? context.linkages.join("; ") : "the dominant nodes cohere around a small set of recurring ideas";
    const keystone = context.keystone || "the keystone course";
    const sentences = [
      `This archive reads as a coherent semester-long knowledge-building project with ${keystone} functioning as the main organizing axis.`,
      `Across the corpus, the dominant conceptual signals include ${keywords}, which recur in ways that suggest a stable thematic spine rather than a loose topical drift.`,
      `The linkage structure is consistent with a networked-learning model in which local ideas are continuously reactivated and recombined: ${linkage}.`,
      `From the standpoint of cognitive load theory, the alternation between consolidation and expansion is healthy, and the current pattern indicates productive strain rather than overload.`,
      `The forest narrative of complexity is instructive here: ${context.complexityTrend} ${context.distribution}`,
      `In terms of writing studies and genre theory, the project reads like a movement from exploratory synthesis toward a more situated, audience-aware register.`,
      `I also hear echoes of conceptual change theory: you are not merely adding facts but reconfiguring explanatory frames as the semester progresses.`,
      `If we locate the work within systems thinking and activity theory, the most promising thread is the way methods, concepts, and tasks mutually condition one another rather than sitting in isolation.`,
      `For the next revision, I would recommend an explicit through-line that names the key problem space and repeatedly ties new observations back to it.`,
      `Doing so will sharpen the interpretive center while still leaving room for the generative divergences that are clearly present in the notes and session outputs.`,
      `Finally, the prose and GCAS sessions read as complementary modes: one scaffolds analytical precision, the other opens narrative or reflective distance that helps integrate learning.`
    ];
    return enforceWordCount(sentences.join(" "), 350);
  }

  function generateMarkdown() {
    const d = new Date();
    const dateISO = d.toISOString().slice(0,10);
    const dateStr = d.toLocaleDateString(undefined, { weekday:"long", year:"numeric", month:"long", day:"numeric" });

    const { perCourse, mode, weekId } = computeForestMetrics();
    const courseList = state.courses || [];
    const doneToday = state.todayTasks.filter(t => t.done).length;
    const doneWeekend = state.weekendTasks.filter(t => t.done).length;
    const totalToday = state.todayTasks.length;
    const totalWeekend = state.weekendTasks.length;
    const totalTasks = totalToday + totalWeekend;
    const doneTotal = doneToday + doneWeekend;
    const completionRate = totalTasks ? (doneTotal / totalTasks) : 0;
    const writingText = normalizeText([state.writingSchedule, state.writingThread, state.writingTargets, state.writingNotes].filter(Boolean).join(" "));
    const proseText = normalizeText([state.proseSchedule, state.proseProject, state.proseTargets, state.proseNotes].filter(Boolean).join(" "));

    const perCourseMax = state.forest.perCourseMax || {};
    const averages = courseList.length
      ? courseList.reduce((acc, course) => {
        const cur = perCourse[course] || {};
        const max = perCourseMax[course] || {};
        acc.words += cur.words || 0;
        acc.syntax += cur.syntax || 0;
        acc.cohesion += cur.cohesion || 0;
        acc.maxWords += max.maxWords || 0;
        acc.maxSyntax += max.maxSyntax || 0;
        acc.maxCohesion += max.maxCohesion || 0;
        return acc;
      }, { words:0, syntax:0, cohesion:0, maxWords:0, maxSyntax:0, maxCohesion:0 })
      : { words:0, syntax:0, cohesion:0, maxWords:0, maxSyntax:0, maxCohesion:0 };

    const avgWords = courseList.length ? (averages.words / courseList.length) : 0;
    const avgSyntax = courseList.length ? (averages.syntax / courseList.length) : 0;
    const avgCohesion = courseList.length ? (averages.cohesion / courseList.length) : 0;
    const peakSyntax = courseList.length ? (averages.maxSyntax / courseList.length) : 0;
    const peakCohesion = courseList.length ? (averages.maxCohesion / courseList.length) : 0;
    const complexityNow = avgSyntax + avgCohesion;
    const complexityPeak = peakSyntax + peakCohesion;
    const complexityRatio = complexityPeak ? (complexityNow / complexityPeak) : 0;

    const complexityTrend = complexityRatio > 0.85
      ? "Complexity is cresting for the week, signaling dense conceptual layering."
      : complexityRatio > 0.6
        ? "Complexity is building steadily with consistent connective tissue."
        : "Complexity is in a reset/absorption phase with simpler conceptual strata.";

    const variance = (() => {
      if (!courseList.length) return 0;
      const mean = avgSyntax;
      const diffs = courseList.map(course => {
        const val = perCourse[course]?.syntax || 0;
        return Math.pow(val - mean, 2);
      });
      return diffs.reduce((a,b)=>a+b,0) / courseList.length;
    })();
    const distribution = variance > 1.2
      ? "Complexity is spiky across courses (some trees are far more branched)."
      : "Complexity is fairly even across courses (forest canopy is balanced).";

    const previousExport = state.lastExport;
    const completionDelta = previousExport
      ? (completionRate - (previousExport.completionRate || 0))
      : 0;

    const momentumScore = Math.round(
      100 * ((completionRate * 0.6) + ((mode.dailyTotal ? (mode.dailyChecked / mode.dailyTotal) : 0) * 0.25) + ((mode.weeklyTotal ? (mode.weeklyChecked / mode.weeklyTotal) : 0) * 0.15))
    );

    const lines = [];
    lines.push(`---`);
    lines.push(`type: semester-dashboard`);
    lines.push(`date: ${dateISO}`);
    lines.push(`keystone: ${state.keystoneToday || ""}`);
    lines.push(`---`);
    lines.push("");

    lines.push(`# Semester Dashboard — ${dateStr}`);
    lines.push("");
    lines.push(`**Tags:** #daily #UMO #study #dashboard #obsidian`);
    lines.push("");
    lines.push(`**Keystone:** ${obsidianLink(state.keystoneToday || "")}`);

    lines.push("");
    lines.push("## Print Pack");
    lines.push("### Efficiency Snapshot");
    lines.push(`- **Tasks completed:** ${doneTotal}/${totalTasks || 0} (${totalTasks ? percent(completionRate) : "0%"})`);
    lines.push(`- **Completion delta vs last export:** ${formatDelta(completionDelta)}`);
    lines.push(`- **Today completion:** ${doneToday}/${totalToday || 0}`);
    lines.push(`- **Weekend completion:** ${doneWeekend}/${totalWeekend || 0}`);
    lines.push(`- **Mode adherence:** daily ${mode.dailyChecked}/${mode.dailyTotal} • weekly ${mode.weeklyChecked}/${mode.weeklyTotal}`);
    lines.push(`- **Momentum score:** ${momentumScore}/100`);

    lines.push("");
    lines.push("");
    lines.push("### Forest Snapshot");
    const forestFile = exportForestPngForMarkdown(dateISO, !!state.forest.hiResPng);
    if (forestFile) {
      lines.push(`![[${forestFile}]]`);
    } else {
      lines.push("_Forest image export failed; use Export PNG in the dashboard._");
      lines.push(`- **Avg words per course:** ${avgWords.toFixed(0)}`);
      lines.push(`- **Avg syntax score:** ${avgSyntax.toFixed(2)} (peak ${peakSyntax.toFixed(2)})`);
      lines.push(`- **Avg cohesion score:** ${avgCohesion.toFixed(2)} (peak ${peakCohesion.toFixed(2)})`);
      lines.push(`- **Complexity vs peak:** ${percent(complexityRatio || 0)}`);
    }

    lines.push("");
    lines.push("### Forest Narrative");
    lines.push(`${complexityTrend}`);
    lines.push(`${distribution}`);
    lines.push(`- **Avg words per course:** ${avgWords.toFixed(0)}`);
    lines.push(`- **Avg syntax score:** ${avgSyntax.toFixed(2)} (peak ${peakSyntax.toFixed(2)})`);
    lines.push(`- **Avg cohesion score:** ${avgCohesion.toFixed(2)} (peak ${peakCohesion.toFixed(2)})`);
    lines.push(`- **Complexity vs peak:** ${percent(complexityRatio || 0)}`);

    lines.push("");
    lines.push("");
    lines.push("### Writing & Prose Threads");
    if (state.writingSchedule?.trim()) lines.push(`- **GCAS schedule:** ${state.writingSchedule.trim()}`);
    if (state.writingThread?.trim()) lines.push(`- **GCAS thread:** ${state.writingThread.trim()}`);
    if (state.writingTargets?.trim()) lines.push(`- **GCAS targets:** ${state.writingTargets.trim()}`);
    if (state.proseSchedule?.trim()) lines.push(`- **Prose schedule:** ${state.proseSchedule.trim()}`);
    if (state.proseProject?.trim()) lines.push(`- **Prose project:** ${state.proseProject.trim()}`);
    if (state.proseTargets?.trim()) lines.push(`- **Prose targets:** ${state.proseTargets.trim()}`);
    if (state.downtimeRule?.trim()) lines.push(`- **Downtime boundary:** ${state.downtimeRule.trim()}`);

    const graphData = computeConceptGraph();
    const topEdges = graphData.edges
      .slice()
      .sort((a, b) => b.weight - a.weight)
      .slice(0, 4)
      .map(edge => `${edge.a} ↔ ${edge.b}`);
    const corpusKeywords = keyPhrases([collectWritingCorpus(), writingText, proseText].join(" "), 8);
    const response = buildConferenceResponse({
      keywords: corpusKeywords,
      linkages: topEdges,
      keystone: state.keystoneToday || "",
      complexityTrend,
      distribution
    });

    lines.push("");
    lines.push("### Conference Respondent Response (350 words)");
    lines.push(response);

    lines.push("");
    lines.push("---");
    lines.push(`**Print footer:** Week ${weekId} • ${dateStr}`);
    lines.push("**Exported from:** Semester Dashboard (local HTML)");
    state.lastExport = {
      dateISO,
      completionRate,
      doneTotal,
      totalTasks
    };
    saveState();
    return lines.join("\n");
  }

  function setMdPreview(md) {
    state.mdCache = md;
    saveState();
    mdPreviewEl.textContent = md;
  }

  // =====================================================================
  // FOREST: syntactic/semantic analysis + growing art + ghost overlay + export
  // =====================================================================

  // stoplist
  const STOP = new Set([
    "the","a","an","and","or","but","if","then","else","so","because","since","while","where","when",
    "to","of","in","on","for","from","with","without","within","between","into","over","under","across",
    "is","are","was","were","be","been","being","am","do","does","did","doing","have","has","had","having",
    "it","its","this","that","these","those","as","at","by","we","you","i","they","them","our","your","my",
    "their","there","here","also","very","more","most","less","not","no","yes","can","could","should","would",
    "may","might","will","just","about","up","down","out","off","only","than","such","some","any","each","all"
  ]);

  const CLAUSE_MARKERS = [
    "that","which","who","whom","whose",
    "because","since","while","whereas","although","though","unless","until",
    "insofar as","with regard to","with regard to which","in terms of","according to","such that",
    "whereby","thereby","in which","within which","through which"
  ];

  const PUNCT_HEAVY = new Set([":",";","—","(",")","[","]"]);

  function normalizeText(s){
    return String(s||"")
      .replaceAll("\u2019","'").replaceAll("\u2014","—").replaceAll("\u2013","-")
      .replace(/\s+/g, " ")
      .trim();
  }

  function splitSentences(text){
    const t = normalizeText(text);
    if (!t) return [];
    return t.split(/(?<=[\.\!\?])\s+/g).map(x => x.trim()).filter(Boolean);
  }

  function tokenize(text){
    const t = normalizeText(text).toLowerCase();
    if (!t) return [];
    return t
      .replace(/[^a-z0-9\-\s']/g, " ")
      .split(/\s+/)
      .map(x => x.trim())
      .filter(Boolean);
  }

  function contentWords(text){
    const toks = tokenize(text);
    return toks.filter(w => w.length >= 3 && !STOP.has(w) && !/^\d+$/.test(w));
  }

  function topNWords(text, n=10){
    const words = contentWords(text);
    const freq = new Map();
    for (const w of words) freq.set(w, (freq.get(w)||0)+1);
    const arr = Array.from(freq.entries()).sort((a,b)=>b[1]-a[1]);
    return arr.slice(0,n).map(([w,c])=>({w,c}));
  }

  function countMarkers(text){
    const lower = normalizeText(text).toLowerCase();
    let count = 0;
    for (const m of CLAUSE_MARKERS) {
      const re = new RegExp("\\b" + m.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + "\\b", "g");
      const matches = lower.match(re);
      if (matches) count += matches.length;
    }
    return count;
  }

  function punctProfile(text){
    const t = String(text||"");
    let heavy = 0, comma = 0, dash = 0;
    for (const ch of t) {
      if (PUNCT_HEAVY.has(ch)) heavy++;
      if (ch === ",") comma++;
      if (ch === "-" || ch === "—") dash++;
    }
    return { heavy, comma, dash };
  }

  function syntacticComplexity(text){
    const sents = splitSentences(text);
    const toks = tokenize(text);
    const words = toks.length || 0;
    const sentLens = sents.map(s => tokenize(s).length).filter(n=>n>0);
    const avgSent = sentLens.length ? (sentLens.reduce((a,b)=>a+b,0)/sentLens.length) : 0;

    let variance = 0;
    if (sentLens.length >= 2) {
      const mean = avgSent;
      variance = sentLens.reduce((a,x)=>a+(x-mean)*(x-mean),0) / sentLens.length;
    }

    const markers = countMarkers(text);
    const { heavy, comma, dash } = punctProfile(text);

    const avgSentScore = clamp(avgSent / 14, 0, 3);
    const markerScore = clamp((markers / Math.max(1, sents.length)) / 1.2, 0, 3);
    const punctScore = clamp((heavy + 0.35*comma + 0.5*dash) / Math.max(1, words) * 60, 0, 3);
    const varScore = clamp(Math.sqrt(variance) / 10, 0, 3);

    const score = 0.95*avgSentScore + 1.15*markerScore + 0.85*punctScore + 0.65*varScore;

    return {
      score: Number(score.toFixed(2)),
      avgSent: Number(avgSent.toFixed(1)),
      markers,
      sents: sents.length,
      punct: { heavy, comma, dash },
    };
  }

  function semanticCohesion(text){
    const words = contentWords(text);
    const total = words.length || 0;
    const uniq = new Set(words).size || 0;
    if (!total) return { score: 0, total: 0, uniq: 0, top: [] };
    const uniqRatio = uniq / total;
    const score = clamp((1 - uniqRatio) * 5, 0, 3);
    return {
      score: Number(score.toFixed(2)),
      total,
      uniq,
      top: topNWords(text, 10),
    };
  }

  // Max-memory: keep these from shrinking within the week:
  // - words (writing volume)
  // - syntax score
  // - cohesion score
  // - completed tasks count
  // Stress is dynamic (status changes should immediately show).
  function updateForestMax(weekId, perCourseComputed){
    state.forest.weekId = weekId;
    state.forest.perCourseMax = state.forest.perCourseMax || {};
    for (const [course, m] of Object.entries(perCourseComputed)) {
      const prev = state.forest.perCourseMax[course] || { maxWords:0, maxSyntax:0, maxCohesion:0, maxLeaves:0 };
      state.forest.perCourseMax[course] = {
        maxWords:    Math.max(prev.maxWords||0, m.words||0),
        maxSyntax:   Math.max(prev.maxSyntax||0, m.syntax||0),
        maxCohesion: Math.max(prev.maxCohesion||0, m.cohesion||0),
        maxLeaves:   Math.max(prev.maxLeaves||0, m.leaves||0),
      };
    }
    saveState();
  }

  function stressFromStatus(status){
    if (status === "danger") return 1.0;
    if (status === "hot") return 0.72;
    if (status === "watch") return 0.42;
    return 0.18;
  }

  function gatherCourseText(course){
    const c = state.courseNotes[course] || {};
    const notes = String(c.notes||"");
    const focus = String(c.focus||"");
    const budget = String(c.budget||"");
    const taskTitles = [
      ...state.todayTasks.filter(t=>t.course===course).map(t=>t.title||""),
      ...state.weekendTasks.filter(t=>t.course===course).map(t=>t.title||""),
    ].join(" ");
    return normalizeText([notes, focus, budget, taskTitles].filter(Boolean).join(" "));
  }

  function computeModeRatios(){
    const keys = Object.keys(state.modeChecks);
    const dailyKeys = keys.filter(k => (state.modeScope?.[k]||"weekly")==="daily");
    const weeklyKeys = keys.filter(k => (state.modeScope?.[k]||"weekly")==="weekly");
    const dailyChecked = dailyKeys.filter(k => !!state.modeChecks[k]).length;
    const weeklyChecked = weeklyKeys.filter(k => !!state.modeChecks[k]).length;
    return {
      dailyRatio: dailyKeys.length ? (dailyChecked / dailyKeys.length) : 0,
      weeklyRatio: weeklyKeys.length ? (weeklyChecked / weeklyKeys.length) : 0,
      dailyChecked, weeklyChecked,
      dailyTotal: dailyKeys.length || 0,
      weeklyTotal: weeklyKeys.length || 0
    };
  }

  function computeForestMetrics(){
    const weekId = isoWeekId(new Date());
    if (state.forest.weekId && state.forest.weekId !== weekId) {
      state.forest.perCourseMax = {};
    }
    if (!state.forest.weekId) state.forest.weekId = weekId;

    const keystone = state.keystoneToday || (state.courses[0]||"");
    const keystoneDaily = normalizeText(state.todayNotes || "");

    const perCourse = {};
    for (const course of state.courses) {
      const baseText = gatherCourseText(course);
      const text = (course === keystone && keystoneDaily)
        ? normalizeText(baseText + " " + keystoneDaily)
        : baseText;

      const syntax = syntacticComplexity(text);
      const sem = semanticCohesion(text);

      const leaves = [
        ...state.todayTasks.filter(t=>t.course===course && t.done),
        ...state.weekendTasks.filter(t=>t.course===course && t.done),
      ].length;

      const status = (state.courseNotes[course] || {}).status || "steady";
      const stress = stressFromStatus(status); // dynamic

      perCourse[course] = {
        text,
        words: tokenize(text).length,
        syntax: syntax.score,
        syntaxDetail: syntax,
        cohesion: sem.score,
        cohesionDetail: sem,
        leaves,
        stress,
        topWords: sem.top.map(x=>x.w),
      };
    }

    updateForestMax(weekId, Object.fromEntries(Object.entries(perCourse).map(([k,v])=>[
      k, { words:v.words, syntax:v.syntax, cohesion:v.cohesion, leaves:v.leaves }
    ])));

    return { weekId, perCourse, mode: computeModeRatios() };
  }

  function influenceMatrix(perCourse){
    const courses = Object.keys(perCourse);
    const mat = [];
    for (let i=0;i<courses.length;i++){
      mat[i] = [];
      for (let j=0;j<courses.length;j++){
        if (i===j) { mat[i][j]=0; continue; }
        const A = perCourse[courses[i]];
        const B = perCourse[courses[j]];
        const Bwords = new Set(contentWords(B.text));
        let hits = 0;
        for (const w of A.topWords.slice(0,8)) {
          if (Bwords.has(w)) hits++;
        }
        const score = hits / Math.max(1, Math.min(8, A.topWords.length));
        mat[i][j] = score;
      }
    }
    return { courses, mat };
  }

  // Seeded RNG
  function xmur3(str) {
    let h = 1779033703 ^ str.length;
    for (let i = 0; i < str.length; i++) {
      h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
      h = (h << 13) | (h >>> 19);
    }
    return function() {
      h = Math.imul(h ^ (h >>> 16), 2246822507);
      h = Math.imul(h ^ (h >>> 13), 3266489909);
      return (h ^= h >>> 16) >>> 0;
    };
  }
  function mulberry32(a) {
    return function() {
      let t = (a += 0x6D2B79F5);
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }
  function seededRand(seedStr){
    const seed = xmur3(seedStr)();
    return mulberry32(seed);
  }

  // Geometry capture for SVG export
  let lastForestGeom = null;

  function initCanvasHiDPI(canvas){
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    const w = Math.max(300, Math.floor(rect.width));
    const h = Math.max(240, Math.floor(rect.height));
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    const ctx = canvas.getContext("2d");
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    return { ctx, w, h, dpr };
  }

  function forestToSVG(geom){
    const { width, height, paths } = geom;
    const esc = (s)=>String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;");
    let out = [];
    out.push(`<?xml version="1.0" encoding="UTF-8"?>`);
    out.push(`<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">`);
    out.push(`<rect x="0" y="0" width="${width}" height="${height}" fill="white" fill-opacity="0.0"/>`);
    for (const p of paths) {
      const stroke = esc(p.stroke || "#000");
      const sw = p.sw ?? 1;
      const alpha = p.alpha ?? 1;
      const fill = p.fill ? esc(p.fill) : "none";
      const fa = p.fillAlpha ?? 1;
      if (p.type === "circle") {
        out.push(`<circle cx="${p.cx}" cy="${p.cy}" r="${p.r}" fill="${fill}" fill-opacity="${fa}" stroke="${stroke}" stroke-opacity="${alpha}" stroke-width="${sw}" />`);
      } else {
        const d = esc(p.d || "");
        out.push(`<path d="${d}" fill="${fill}" fill-opacity="${fa}" stroke="${stroke}" stroke-opacity="${alpha}" stroke-width="${sw}" stroke-linecap="round" stroke-linejoin="round" />`);
      }
    }
    out.push(`</svg>`);
    return out.join("\n");
  }

  function downloadText(filename, text, mime){
    const blob = new Blob([text], { type: mime || "text/plain" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function downloadDataUrl(filename, dataUrl){
    const a = document.createElement("a");
    a.href = dataUrl;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  function ghostKey(weekId){
    return `${STORAGE_KEY}__forest_ghost__${weekId}`;
  }

  function saveGhostSnapshot(weekId){
    try {
      const src = forestCanvas;
      const rect = src.getBoundingClientRect();
      const w = Math.max(420, Math.floor(rect.width));
      const h = Math.max(220, Math.floor(rect.height));
      const smallW = 720;
      const smallH = Math.floor((h / w) * smallW);

      const tmp = document.createElement("canvas");
      tmp.width = smallW;
      tmp.height = smallH;
      const tctx = tmp.getContext("2d");
      tctx.fillStyle = "rgba(255,255,255,0)";
      tctx.fillRect(0,0,smallW,smallH);
      tctx.drawImage(src, 0, 0, w, h, 0, 0, smallW, smallH);

      const url = tmp.toDataURL("image/webp", 0.7);
      localStorage.setItem(ghostKey(weekId), url);
    } catch {}
  }

  function loadGhostSnapshot(weekId){
    try {
      return localStorage.getItem(ghostKey(weekId));
    } catch { return null; }
  }

  function clearGhostSnapshot(weekId){
    try { localStorage.removeItem(ghostKey(weekId)); } catch {}
  }

  function renderForest(){
    const { weekId, perCourse, mode } = computeForestMetrics();
    const { courses, mat } = influenceMatrix(perCourse);

    const ink = getCSSVar("--ink") || "#3a3d5e";
    const { ctx, w, h } = initCanvasHiDPI(forestCanvas);
    ctx.clearRect(0,0,w,h);
    drawRetroBackground(ctx, w, h, state.env);

    // Ghost overlay from previous week (faint trace)
    const prevId = prevIsoWeekId(weekId);
    const ghostUrl = loadGhostSnapshot(prevId);
    if (ghostUrl) {
      const img = new Image();
      img.onload = () => {
        ctx.save();
        ctx.globalAlpha = 0.08;
        ctx.drawImage(img, 0, 0, w, h);
        ctx.restore();
        drawForestCore(ctx, w, h, ink, perCourse, courses, mat, weekId, mode);
        applyDither(ctx);
      };
      img.src = ghostUrl;
    } else {
      drawForestCore(ctx, w, h, ink, perCourse, courses, mat, weekId, mode);
      applyDither(ctx);
    }

    const maxInfo = forestMaxInfo(weekId, courses);
    forestLegendEl.innerHTML = forestLegendHTML(weekId, maxInfo);
    forestLegendEl.classList.toggle("show", !!state.forest.legendOn);
  }

  function applyDither(ctx) {
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;
    const image = ctx.getImageData(0, 0, w, h);
    const data = image.data;
    const matrix = [
      [0, 8, 2, 10],
      [12, 4, 14, 6],
      [3, 11, 1, 9],
      [15, 7, 13, 5]
    ];
    const levels = 4;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const idx = (y * w + x) * 4;
        const threshold = (matrix[y % 4][x % 4] / 16 - 0.5) * 42;
        for (let c = 0; c < 3; c++) {
          const value = data[idx + c] + threshold;
          const quant = Math.round((levels - 1) * value / 255) * (255 / (levels - 1));
          data[idx + c] = clamp(quant, 0, 255);
        }
      }
    }
    ctx.putImageData(image, 0, 0);
  }

  function drawRetroBackground(ctx, w, h, env) {
    const temp = env?.temperature ?? 12;
    const wind = env?.windSpeed ?? 6;
    const humidity = env?.humidity ?? 65;
    const clouds = env?.cloudCover ?? 40;

    const hue = clamp(30 + (temp * 2), 15, 220);
    const gradient = ctx.createLinearGradient(0, 0, w, h);
    gradient.addColorStop(0, `hsla(${hue}, 40%, 92%, 0.9)`);
    gradient.addColorStop(1, `hsla(${hue + 30}, 50%, 78%, 0.9)`);
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, w, h);

    const stripeGap = Math.max(12, 50 - Math.round(humidity / 3));
    ctx.save();
    ctx.strokeStyle = `rgba(20,20,30,${0.06 + clouds / 600})`;
    ctx.lineWidth = 1;
    for (let y = 0; y < h; y += stripeGap) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(w, y);
      ctx.stroke();
    }
    ctx.restore();

    const amplitude = 6 + wind * 0.8;
    const frequency = 0.012 + (humidity / 8000);
    ctx.save();
    ctx.strokeStyle = `rgba(40,40,60,${0.12 + wind / 150})`;
    ctx.lineWidth = 1.2;
    for (let y = 0; y < h; y += 38) {
      ctx.beginPath();
      for (let x = 0; x <= w; x += 8) {
        const wave = Math.sin(x * frequency + y * 0.03) * amplitude;
        const py = y + wave;
        if (x === 0) ctx.moveTo(x, py);
        else ctx.lineTo(x, py);
      }
      ctx.stroke();
    }
    ctx.restore();
  }

  function forestMaxInfo(weekId, courses){
    const max = state.forest.perCourseMax || {};
    let best = { course: "", syntax: -1 };
    for (const c of courses) {
      const m = max[c] || {};
      if ((m.maxSyntax||0) > best.syntax) best = { course: c, syntax: (m.maxSyntax||0) };
    }
    return { weekId, best, per: max };
  }

  function forestLegendHTML(weekId, info){
    const best = info.best.course
      ? `<b>Highest complexity:</b> ${escapeHtml(info.best.course)} (${Number(info.best.syntax).toFixed(2)})`
      : `<b>Highest complexity:</b> (none yet)`;
    return `
      <div style="display:grid;gap:6px;">
        <div><b>Forest mappings</b></div>
        <div>• <b>Height</b> = writing volume (max words this week)</div>
        <div>• <b>Branching</b> = syntactic / derivational complexity (clauses + punctuation + sentence stats)</div>
        <div>• <b>Leaf clusters</b> = completed tasks (max this week)</div>
        <div>• <b>Trunk thickness</b> = current “stress” from course status (steady→danger)</div>
        <div>• <b>Mycelium</b> = organic filament field biased by shared signifier overlap</div>
        <div>${best}</div>
        <div class="mini">Week: <code>${escapeHtml(weekId)}</code>. Trees do not shrink from deleted text; stress + mode checkboxes remain dynamic.</div>
      </div>
    `;
  }

  // --------- Organic mycelium: filament field ----------
  function drawMyceliumField(ctx, geom, w, h, baseY, courses, perCourse, mat, ink, weekId, mode) {
    const r = seededRand("myc-field::" + weekId);

    // Density responds to daily checkbox completion (dynamic)
    const dailyBoost = 0.7 + 0.6 * clamp(mode?.dailyRatio ?? 0, 0, 1);
    const densityBase = Math.round(220 * dailyBoost);

    // Subterrain depth (visible due to higher canvas + raised ground)
    const depthRange = 140;
    const minLen = 18;
    const maxLen = 105;

    // sample multiple filaments; each chooses a semantic "hot zone" influence
    for (let k = 0; k < densityBase; k++) {
      const x0 = r() * w;
      const y0 = baseY + 12 + r() * depthRange;

      const i = Math.floor(r() * courses.length);
      const j = Math.floor(r() * courses.length);
      const influence = clamp((mat[i]?.[j] || 0), 0, 1);

      const thickness = 0.35 + 2.4 * influence;
      const length = minLen + (maxLen - minLen) * (0.35 + 0.95*influence) * r();
      const alphaBase = 0.12 + 0.25 * influence;

      const branches = 3 + Math.floor(8 * influence);

      growFilament(x0, y0, length, -Math.PI/2 + (r()-0.5)*0.9, branches, thickness, alphaBase);

      function growFilament(x, y, len, ang, depth, thick, alpha) {
        if (depth <= 0 || len < 9) return;

        const nx = x + Math.cos(ang) * len;
        const ny = y + Math.sin(ang) * len;

        // organic curvature: lateral noise
        const cx = x + Math.cos(ang) * len * 0.45 + (r()-0.5)*16;
        const cy = y + Math.sin(ang) * len * 0.45 + (r()-0.5)*14;

        // keep within soil band
        if (ny < baseY + 4) return;
        if (ny > h + 30) return;

        ctx.save();
        ctx.strokeStyle = ink;
        ctx.globalAlpha = alpha;
        ctx.lineWidth = Math.max(0.35, thick * (depth/7));
        ctx.beginPath();
        ctx.moveTo(x,y);
        ctx.quadraticCurveTo(cx, cy, nx, ny);
        ctx.stroke();
        ctx.restore();

        const nodeR = 0.6 + 1.4 * influence;
        ctx.save();
        ctx.fillStyle = ink;
        ctx.globalAlpha = alpha * 0.9;
        ctx.beginPath();
        ctx.arc(nx, ny, nodeR, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        geom.paths.push({
          d: `M ${x} ${y} Q ${cx} ${cy} ${nx} ${ny}`,
          stroke: ink,
          sw: Math.max(0.35, thick * (depth/7)),
          alpha: alpha,
          fill: "none"
        });
        geom.paths.push({
          type: "circle",
          cx: nx,
          cy: ny,
          r: nodeR,
          stroke: ink,
          sw: 0.6,
          alpha: alpha * 0.9,
          fill: ink,
          fillAlpha: alpha * 0.9
        });

        // branching probabilities
        const jitter = (r()-0.5) * 0.9;
        if (r() < (0.62 + 0.18*influence)) {
          growFilament(nx, ny, len*(0.62 + 0.18*r()), ang + jitter*0.55, depth-1, thick*0.92, alpha*0.92);
        }
        if (r() < (0.38 + 0.24*influence)) {
          growFilament(nx, ny, len*(0.50 + 0.18*r()), ang - jitter*0.55, depth-1, thick*0.90, alpha*0.90);
        }
      }
    }
  }

  // --------- Forest core ----------
  function drawForestCore(ctx, w, h, ink, perCourse, courses, mat, weekId, mode){
    // geometry capture for SVG export
    const geom = { width: w, height: h, paths: [] };
    lastForestGeom = geom;

    // baseline + padding so tops never clip; raise ground slightly for subterrain
    const padL = 70, padR = 70, padT = 18, padB = 110;
    const groundRaise = 12;                   // raised ground to show mycelium
    const baseY = (h - padB) - groundRaise;

    // draw ground line
    ctx.save();
    ctx.strokeStyle = getCSSVar("--line") || "#dbdbdb";
    ctx.globalAlpha = 0.35;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, baseY);
    ctx.lineTo(w, baseY);
    ctx.stroke();
    ctx.restore();

    // compute scaling so tallest tree fits (includes canopy headroom)
    const max = state.forest.perCourseMax || {};
    const maxWords = Math.max(1, ...courses.map(c => (max[c]?.maxWords || 0)));
    const trunkMaxRaw = 90 + Math.log(1 + maxWords) * 72;

    const canopyFactor = 1.38;
    const canopyPadding = 30;
    const totalMaxRaw = trunkMaxRaw * canopyFactor + canopyPadding;

    const maxTargetHeight = (baseY - padT) * 0.74;
    const scale = Math.min(0.55, maxTargetHeight / Math.max(150, totalMaxRaw));

    const span = Math.max(1, courses.length - 1);
    const usableW = w - padL - padR;
    const xFor = (i) => padL + (i / span) * usableW;

    // organic mycelium under trees
    drawMyceliumField(ctx, geom, w, h, baseY, courses, perCourse, mat, ink, weekId, mode);

    // trees
    for (let i=0;i<courses.length;i++){
      const course = courses[i];
      const mMax = max[course] || { maxWords:0, maxSyntax:0, maxCohesion:0, maxLeaves:0 };

      const x0 = xFor(i);
      const r = seededRand(`${weekId}::${course}`);

      // Height from writing volume (max-memory)
      const words = mMax.maxWords || 0;
      const height = scale * (90 + Math.log(1 + words) * 72);

      // Syntax -> branchiness (max-memory)
      const syntax = mMax.maxSyntax || 0;
      const branchiness = clamp(syntax / 3.2, 0.1, 1.0);

      // Semantic cohesion -> leaf clustering (max-memory)
      const cohesion = mMax.maxCohesion || 0;
      const cohesionN = clamp(cohesion / 3.0, 0.0, 1.0);

      // Completed tasks -> leafCount driver (max-memory)
      const leaves = mMax.maxLeaves || 0;

      // Stress is dynamic (current, not max)
      const stress = clamp((perCourse[course]?.stress ?? 0.18), 0.1, 1.0);
      const trunkW = 1.0 + 3.8*stress;

      // Dynamic "sunlight" from daily modes: slight canopy lift/energy
      const dayLight = 0.88 + 0.22 * clamp(mode?.dailyRatio ?? 0, 0, 1);

      const mature = branchiness > 0.78;
      const crownSpread = mature ? 1.55 : 1.0;
      const curvature = mature ? 1.15 : 0.7;

      // Draw trunk
      ctx.save();
      ctx.strokeStyle = ink;
      ctx.globalAlpha = 0.33 + 0.22*stress;
      ctx.lineWidth = trunkW;
      ctx.setLineDash([]);

      const trunkTop = { x: x0 + (r()-0.5)*2, y: baseY - height*dayLight };
      trunkTop.y = Math.max(trunkTop.y, padT + 8);

      ctx.beginPath();
      ctx.moveTo(x0, baseY);
      ctx.lineTo(trunkTop.x, trunkTop.y);
      ctx.stroke();
      ctx.restore();

      geom.paths.push({
        d: `M ${x0} ${baseY} L ${trunkTop.x} ${trunkTop.y}`,
        stroke: ink,
        sw: trunkW,
        alpha: (0.33 + 0.22*stress),
        fill: "none"
      });

      // Branch recursion
      const maxDepth = Math.round(3 + 6*branchiness);
      const baseAngle = -Math.PI/2;

      const leafPoints = [];
      function branch(x,y, len, ang, depth){
        if (depth <= 0 || len < 6) { leafPoints.push({x,y}); return; }
        const nx = x + Math.cos(ang) * len;
        const ny = y + Math.sin(ang) * len;

        const sw = Math.max(0.6, (trunkW * 0.72) * (depth/(maxDepth+1)));
        const alpha = 0.12 + 0.18 * (depth/(maxDepth+1));

        ctx.save();
        ctx.strokeStyle = ink;
        ctx.globalAlpha = alpha;
        ctx.lineWidth = sw;
        ctx.beginPath();
        ctx.moveTo(x,y);
        const cx = x + Math.cos(ang) * len * 0.55 + (r()-0.5) * 6 * curvature;
        const cy = y + Math.sin(ang) * len * 0.55 + (r()-0.5) * 6 * curvature;
        ctx.quadraticCurveTo(cx, cy, nx, ny);
        ctx.stroke();
        ctx.restore();

        geom.paths.push({
          d: `M ${x} ${y} Q ${cx} ${cy} ${nx} ${ny}`,
          stroke: ink,
          sw,
          alpha,
          fill: "none"
        });

        const split = (r() < (0.55 + 0.35*branchiness)) ? 2 : 1;
        const jitter = (r()-0.5) * 0.18;
        const spread = (0.35 + 0.85*branchiness) * crownSpread;

        if (split === 1){
          const a2 = ang + jitter + (r()-0.5)*0.08;
          branch(nx, ny, len*(0.70 + 0.10*r()), a2, depth-1);
        } else {
          const aL = ang - (0.22 + 0.28*r())*spread + jitter;
          const aR = ang + (0.22 + 0.28*r())*spread + jitter;
          branch(nx, ny, len*(0.66 + 0.10*r()), aL, depth-1);
          branch(nx, ny, len*(0.66 + 0.10*r()), aR, depth-1);
          if (mature && r() < 0.30) {
            const aM = ang + (r()-0.5)*0.35*spread;
            branch(nx, ny, len*(0.55 + 0.08*r()), aM, depth-2);
          }
        }
      }

      const startLen = clamp(18 + height * (0.18 + 0.06*r()), 18, 74);
      branch(trunkTop.x, trunkTop.y, startLen, baseAngle + (r()-0.5)*0.16, maxDepth);

      // Leaves
      const leafCount = Math.min(140, Math.round(leaves * (6 + 10*cohesionN) * (0.92 + 0.18*mode.dailyRatio)));
      const autumnPalette = ["#7a1f1f", "#9b2c2c", "#b45309", "#d97706", "#f59e0b", "#facc15", "#eab308", "#c2410c"];
      const richness = clamp((syntax + cohesion) / 6, 0, 1);
      const paletteCount = Math.max(1, Math.round(1 + richness * (autumnPalette.length - 1)));
      const palette = autumnPalette.slice(0, paletteCount);
      if (leafCount > 0 && leafPoints.length) {
        ctx.save();
        ctx.strokeStyle = ink;
        ctx.fillStyle = palette[0];
        ctx.globalAlpha = 0.9;

        const clusters = Math.max(1, Math.round(4 - 3*cohesionN));
        const centers = [];
        for (let c=0;c<clusters;c++){
          centers.push(leafPoints[Math.floor(r()*leafPoints.length)]);
        }

        for (let k=0;k<leafCount;k++){
          const center = centers[Math.floor(r()*centers.length)];
          const spreadPx = 10 + 40*(1 - cohesionN);
          const px = center.x + (r()-0.5)*spreadPx;
          const py = center.y + (r()-0.5)*spreadPx;

          const rad = 1.2 + 1.8*r();
          ctx.fillStyle = palette[Math.floor(r() * palette.length)];
          ctx.beginPath();
          ctx.arc(px, py, rad, 0, Math.PI*2);
          ctx.fill();
          if (r() < 0.35) { ctx.globalAlpha = 0.20; ctx.stroke(); ctx.globalAlpha = 0.9; }

          geom.paths.push({
            type: "circle",
            cx: px, cy: py, r: rad,
            stroke: ink, sw: 0.8,
            alpha: 0.15,
            fill: "rgba(58,61,94,0.10)",
            fillAlpha: 1
          });
        }
        ctx.restore();
      }

      // Course labels (vertical along trunk)
      ctx.save();
      ctx.fillStyle = ink;
      ctx.globalAlpha = 0.5;
      ctx.font = "11px " + getCSSVar("--sans");
      const labelX = clamp(x0, padL, w - padR);
      ctx.translate(labelX, baseY - 10);
      ctx.rotate(-Math.PI / 2);
      ctx.textAlign = "center";
      ctx.fillText(course, 0, 0);
      ctx.restore();
    }

    // save snapshot for this week so it becomes next week's ghost
    saveGhostSnapshot(weekId);
  }

  // Debounced forest updates while typing
  const debouncedForest = debounce(() => {
    try { renderForest(); } catch {}
  }, 180);

  const debouncedGraph = debounce(() => {
    try { renderConceptGraph(); } catch {}
  }, 220);

  // ---------- Hydration ----------
  function hydrateInputs() {
    intentEl.value = state.intent || "";
    coreWindowEl.value = state.coreWindow || "";
    weekendPostureEl.value = state.weekendPosture || "";
    rebalanceDayEl.value = state.rebalanceDay || "Sunday";

    absorptionEl.value = state.absorption || "";
    workoutEl.value = state.workout || "";
    todayNotesEl.value = state.todayNotes || "";

    courseListEl.value = state.courses.join("; ");

    writingScheduleEl.value = state.writingSchedule || "";
    writingThreadEl.value = state.writingThread || "";
    writingTargetsEl.value = state.writingTargets || "";
    writingNotesEl.value = state.writingNotes || "";

    proseScheduleEl.value = state.proseSchedule || "";
    proseProjectEl.value = state.proseProject || "";
    proseTargetsEl.value = state.proseTargets || "";
    proseNotesEl.value = state.proseNotes || "";

    downtimeRuleEl.value = state.downtimeRule || "";

    renderModeChips();
    renderKeystoneDropdown();
    renderCourseCards();
    renderTasks();
    renderWeekSummary();
    renderConceptGraph();

    if (state.mdCache) mdPreviewEl.textContent = state.mdCache;

    forestLegendEl.classList.toggle("show", !!state.forest.legendOn);
    toggleHiResPngEl.checked = !!state.forest.hiResPng;
    document.body.classList.toggle("print-preview", !!state.printPreview);
    debouncedForest();
  }

  // ---------- Wire up ----------
    // ---------- Wire up ----------
    intentEl.addEventListener("input", () => { state.intent = intentEl.value; saveState(); });
  coreWindowEl.addEventListener("input", () => { state.coreWindow = coreWindowEl.value; saveState(); });
  weekendPostureEl.addEventListener("input", () => { state.weekendPosture = weekendPostureEl.value; saveState(); });
  rebalanceDayEl.addEventListener("change", () => { state.rebalanceDay = rebalanceDayEl.value; saveState(); });

  keystoneTodayEl.addEventListener("change", () => {
    state.keystoneToday = keystoneTodayEl.value;
    saveState();
    renderWeekSummary();
    debouncedForest();
  });

  absorptionEl.addEventListener("input", () => {
    state.absorption = absorptionEl.value;
    saveState();
  });

  workoutEl.addEventListener("input", () => {
    state.workout = workoutEl.value;
    saveState();
  });

  todayNotesEl.addEventListener("input", () => {
    state.todayNotes = todayNotesEl.value;
    saveState();
    debouncedForest();
    debouncedGraph();
  });

  courseListEl.addEventListener("keydown", (e) => {
    if (e.key === "Enter") { e.preventDefault(); el("btnApplyCourses").click(); }
  });

  writingScheduleEl.addEventListener("input", () => { state.writingSchedule = writingScheduleEl.value; saveState(); debouncedGraph(); });
  writingThreadEl.addEventListener("input", () => { state.writingThread = writingThreadEl.value; saveState(); debouncedGraph(); });
  writingTargetsEl.addEventListener("input", () => { state.writingTargets = writingTargetsEl.value; saveState(); debouncedGraph(); });
  writingNotesEl.addEventListener("input", () => { state.writingNotes = writingNotesEl.value; saveState(); debouncedGraph(); });

  proseScheduleEl.addEventListener("input", () => { state.proseSchedule = proseScheduleEl.value; saveState(); debouncedGraph(); });
  proseProjectEl.addEventListener("input", () => { state.proseProject = proseProjectEl.value; saveState(); debouncedGraph(); });
  proseTargetsEl.addEventListener("input", () => { state.proseTargets = proseTargetsEl.value; saveState(); debouncedGraph(); });
  proseNotesEl.addEventListener("input", () => { state.proseNotes = proseNotesEl.value; saveState(); debouncedGraph(); });

  downtimeRuleEl.addEventListener("input", () => { state.downtimeRule = downtimeRuleEl.value; saveState(); });

  // ---------- Buttons ----------

    // ---------- Buttons ----------
    el("btnAddTodayTask").addEventListener("click", () => {
      state.todayTasks.push({ id: uid(), done: false, title: "", course: state.keystoneToday || state.courses[0], mode: "(mode)" });
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
      toast("Added Today task");
      // focus newest title
      setTimeout(() => {
        const rows = todayTasksEl.querySelectorAll(".task input.title");
        rows[rows.length - 1]?.focus();
      }, 0);
    });

    el("btnClearTodayDone").addEventListener("click", () => {
      state.todayTasks = state.todayTasks.filter(t => !t.done);
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
      toast("Cleared completed Today tasks");
    });

    el("btnAddWeekendTask").addEventListener("click", () => {
      state.weekendTasks.push({ id: uid(), done: false, title: "", course: state.courses[0], mode: "(mode)" });
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
      toast("Added Weekend deliverable");
      setTimeout(() => {
        const rows = weekendTasksEl.querySelectorAll(".task input.title");
        rows[rows.length - 1]?.focus();
      }, 0);
    });

    el("btnClearWeekendDone").addEventListener("click", () => {
      state.weekendTasks = state.weekendTasks.filter(t => !t.done);
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
      toast("Cleared completed Weekend tasks");
    });

    el("btnApplyCourses").addEventListener("click", () => {
      const raw = String(courseListEl.value || "");
      const list = raw.split(";").map(x => x.trim()).filter(Boolean);

      if (!list.length) {
        toast("Course list is empty");
        return;
      }

      // Preserve existing notes where possible
      const old = state.courseNotes || {};
      const nextNotes = {};
      list.forEach(c => { nextNotes[c] = old[c] || { status: "steady", focus: "", budget: "", notes: "" }; });

      // Update tasks that pointed to removed courses -> move to first course
      const fallback = list[0];
      for (const t of [...state.todayTasks, ...state.weekendTasks]) {
        if (!list.includes(t.course)) t.course = fallback;
      }

      state.courses = list;
      state.courseNotes = nextNotes;

      if (!list.includes(state.keystoneToday)) state.keystoneToday = fallback;

      saveState();
      renderKeystoneDropdown();
      renderCourseCards();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
      toast("Applied courses");
    });

    // Markdown export buttons
    el("btnGenerateMd").addEventListener("click", () => {
      const md = generateMarkdown();
      setMdPreview(md);
      toast("Generated markdown");
    });

    el("btnCopyMd").addEventListener("click", async () => {
      const md = state.mdCache || generateMarkdown();
      setMdPreview(md);
      try {
        await navigator.clipboard.writeText(md);
        toast("Copied");
      } catch {
        toast("Copy failed (browser blocked)");
      }
    });

    el("btnDownloadMd").addEventListener("click", () => {
      const md = state.mdCache || generateMarkdown();
      setMdPreview(md);
      const dateISO = new Date().toISOString().slice(0,10);
      downloadText(`semester-dashboard_${dateISO}.md`, md, "text/markdown");
      toast("Downloaded .md");
    });

    el("btnArchiveBundle").addEventListener("click", async () => {
      try {
        const md = state.mdCache || generateMarkdown();
        setMdPreview(md);
        const dateISO = new Date().toISOString().slice(0,10);
        const forestName = `forest_${dateISO}${state.forest.hiResPng ? "_hires" : ""}.png`;
        const forestUrl = forestPngDataUrl(state.forest.hiResPng ? 2 : 1);
        const mdBytes = textToUint8(md);
        const pngBytes = dataUrlToUint8(forestUrl);
        const zip = zipFiles([
          { name: `semester-dashboard_${dateISO}.md`, data: mdBytes },
          { name: forestName, data: pngBytes }
        ]);
        const blob = new Blob([zip], { type: "application/zip" });
        downloadBlob(`semester-dashboard_${dateISO}.zip`, blob);
        toast("Downloaded archive bundle");
      } catch {
        toast("Archive bundle failed");
      }
    });

    // Reset day/week checkboxes
    el("btnResetDay").addEventListener("click", () => {
      for (const k of Object.keys(state.modeChecks)) {
        if ((state.modeScope?.[k] || "weekly") === "daily") state.modeChecks[k] = false;
      }
      saveState();
      renderModeChips();
      renderWeekSummary();
      debouncedForest();
      toast("Reset daily modes");
    });

    el("btnResetWeek").addEventListener("click", () => {
      for (const k of Object.keys(state.modeChecks)) {
        if ((state.modeScope?.[k] || "weekly") === "weekly") state.modeChecks[k] = false;
      }
      saveState();
      renderModeChips();
      renderWeekSummary();
      debouncedForest();
      toast("Reset weekly modes");
    });

    // Backup / reset
    el("btnBackup").addEventListener("click", () => {
      try {
        const dateISO = new Date().toISOString().slice(0,10);
        downloadText(`semester-dashboard_backup_${dateISO}.json`, JSON.stringify(state, null, 2), "application/json");
        toast("Exported JSON");
      } catch {
        toast("Export failed");
      }
    });

    el("btnHardReset").addEventListener("click", () => {
      const ok = confirm("Hard reset will wipe all locally saved dashboard data. Continue?");
      if (!ok) return;
      try { localStorage.removeItem(STORAGE_KEY); } catch {}
      state = structuredDefault();
      saveState();
      hydrateInputs();
      toast("Wiped local data");
    });

    el("btnPrintPreview").addEventListener("click", () => {
      state.printPreview = !state.printPreview;
      saveState();
      document.body.classList.toggle("print-preview", !!state.printPreview);
      toast(state.printPreview ? "Print preview on" : "Print preview off");
    });

    // Forest controls
    el("btnToggleLegend").addEventListener("click", () => {
      state.forest.legendOn = !state.forest.legendOn;
      saveState();
      forestLegendEl.classList.toggle("show", !!state.forest.legendOn);
      toast(state.forest.legendOn ? "Legend on" : "Legend off");
    });

    toggleHiResPngEl.addEventListener("change", () => {
      state.forest.hiResPng = !!toggleHiResPngEl.checked;
      saveState();
      toast(state.forest.hiResPng ? "Hi-res PNG on" : "Hi-res PNG off");
    });

    el("btnExportPNG").addEventListener("click", () => {
      try {
        const dateISO = new Date().toISOString().slice(0,10);
        const url = forestPngDataUrl(state.forest.hiResPng ? 2 : 1);
        downloadDataUrl(`forest_${dateISO}${state.forest.hiResPng ? "_hires" : ""}.png`, url);
        toast("Exported PNG");
      } catch {
        toast("PNG export failed");
      }
    });

    el("btnExportSVG").addEventListener("click", () => {
      try {
        if (!lastForestGeom) renderForest();
        const dateISO = new Date().toISOString().slice(0,10);
        const svg = forestToSVG(lastForestGeom);
        downloadText(`forest_${dateISO}.svg`, svg, "image/svg+xml");
        toast("Exported SVG");
      } catch {
        toast("SVG export failed");
      }
    });

    el("btnClearGhost").addEventListener("click", () => {
      const current = isoWeekId(new Date());
      const prev = prevIsoWeekId(current);
      clearGhostSnapshot(prev);
      debouncedForest();
      toast("Cleared last-week ghost");
    });

    // ---------- Keyboard shortcuts ----------
    function isTypingTarget(evt){
      const t = evt.target;
      if (!t) return false;
      const tag = (t.tagName || "").toLowerCase();
      return tag === "input" || tag === "textarea" || tag === "select";
    }

    window.addEventListener("keydown", (e) => {
      // Save (Ctrl/⌘+S)
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "s") {
        e.preventDefault();
        saveState();
        toast("Saved");
        return;
      }

      // "g then m" for markdown generation
      // simple two-key chord within 900ms
      if (!window.__gmState) window.__gmState = { t: 0, g: false };
      const gm = window.__gmState;

      const key = e.key.toLowerCase();

      if (key === "g" && !e.ctrlKey && !e.metaKey && !e.altKey) {
        if (!isTypingTarget(e)) {
          gm.g = true;
          gm.t = Date.now();
          return;
        }
      }
      if (key === "m" && gm.g && (Date.now() - gm.t) < 900) {
        if (!isTypingTarget(e)) {
          gm.g = false;
          const md = generateMarkdown();
          setMdPreview(md);
          toast("Generated markdown");
        }
        return;
      }
      if ((Date.now() - gm.t) >= 900) gm.g = false;

      // Add tasks (n / w) when not typing
      if (!isTypingTarget(e) && !e.ctrlKey && !e.metaKey && !e.altKey) {
        if (key === "n") { el("btnAddTodayTask").click(); }
        if (key === "w") { el("btnAddWeekendTask").click(); }
      }
    });

    // ---------- Responsive: rerender canvas on resize ----------
    window.addEventListener("resize", debounce(() => {
      debouncedForest();
    }, 120));

  async function fetchMaineEnvironment() {
    try {
      const url = "https://api.open-meteo.com/v1/forecast?latitude=43.6591&longitude=-70.2568&current_weather=true&hourly=relativehumidity_2m,cloudcover&timezone=America%2FNew_York";
      const res = await fetch(url);
      if (!res.ok) throw new Error("weather fetch failed");
      const data = await res.json();
      const current = data.current_weather || {};
      const hourly = data.hourly || {};
      const timeIndex = hourly.time ? hourly.time.indexOf(current.time) : -1;
      const humidity = timeIndex >= 0 ? hourly.relativehumidity_2m?.[timeIndex] : null;
      const cloudCover = timeIndex >= 0 ? hourly.cloudcover?.[timeIndex] : null;
      state.env = {
        temperature: current.temperature ?? 12,
        windSpeed: current.windspeed ?? 6,
        humidity: humidity ?? 65,
        cloudCover: cloudCover ?? 40,
        updated: current.time || new Date().toISOString()
      };
      saveState();
      debouncedForest();
    } catch {
      state.env = state.env || { temperature: 12, windSpeed: 6, humidity: 65, cloudCover: 40, updated: new Date().toISOString() };
      saveState();
    }
  }

  // ---------- Init ----------
  // Ensure weekId is set early to support ghost logic without flicker
  if (!state.forest.weekId) state.forest.weekId = isoWeekId(new Date());
  hydrateInputs();
  fetchMaineEnvironment();

    // If first load has no md cache, show empty but ready
    if (!state.mdCache) mdPreviewEl.textContent = "(Generate markdown to preview here.)";

  </script>
</body>
</html>
