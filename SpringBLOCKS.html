<!-- CANARY: local edit -->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Semester Dashboard — Modes + .md Export</title>
  <link rel="icon" href="favicon.svg" type="image/svg+xml" />
  <style>
    :root {
      --bg: #fbfaf7;
      --bg-grad-1: #fffdfa;
      --bg-grad-2: #f1ebdf;
      --panel: #ffffff;
      --panel2: #f6f4ef;
      --text: #1f1b16;
      --muted: #6f675d;
      --line: #e7e1d7;
      --accent: #efeae0;
      --chip: #f3eee5;
      --danger: #d92b4b;
      --ok: #1faa7a;
      --warn: #d9a12b;
      --radius: 16px;
      --shadow: 0 18px 40px rgba(32, 24, 14, 0.08);
      --shadowSoft: 0 8px 16px rgba(32, 24, 14, 0.05);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --serif: "Palatino Linotype", Palatino, "Book Antiqua", Georgia, "Times New Roman", serif;
      --sans: "Avenir Next", "Gill Sans", "Trebuchet MS", "Segoe UI", Arial, sans-serif;
      --ink: #2b2620;
    }
    body[data-theme="bright"] {
      --bg: #ffffff;
      --bg-grad-1: #ffffff;
      --bg-grad-2: #f4f4f4;
      --panel: #ffffff;
      --panel2: #f7f7f7;
      --text: #111111;
      --muted: #666666;
      --line: #e6e6e6;
      --accent: #f2f2f2;
      --chip: #f3f3f3;
      --ink: #2d2a26;
      --shadow: 0 16px 34px rgba(32, 32, 32, 0.08);
      --shadowSoft: 0 8px 16px rgba(32, 32, 32, 0.05);
    }
    body[data-theme="dark"] {
      --bg: #141210;
      --bg-grad-1: #191613;
      --bg-grad-2: #0f0d0b;
      --panel: #1c1a17;
      --panel2: #23201c;
      --text: #e8e4dc;
      --muted: #b0a79a;
      --line: #2c2924;
      --accent: #26231f;
      --chip: #2a2722;
      --ink: #f0ece4;
      --shadow: 0 18px 40px rgba(0, 0, 0, 0.35);
      --shadowSoft: 0 8px 16px rgba(0, 0, 0, 0.25);
    }
    body[data-theme="dark"] header {
      background: rgba(20, 18, 16, 0.72);
      border-bottom-color: rgba(255, 255, 255, 0.06);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: var(--sans);
      background:
        radial-gradient(1200px 900px at 15% 0%, var(--bg-grad-1) 0%, var(--bg) 55%),
        linear-gradient(180deg, var(--bg-grad-1) 0%, var(--bg-grad-2) 100%);
      color: var(--text);
      transition: background .18s ease, color .18s ease;
    }
    :focus-visible { outline: 2px solid var(--ink); outline-offset: 2px; border-radius: 10px; }

    header {
      position: sticky;
      top: 0;
      z-index: 10;
      background: rgba(255, 255, 255, 0.72);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--line);
    }
    .wrap { max-width: 1180px; margin: 0 auto; padding: 18px 18px 48px; }
    .topbar {
      display: grid;
      grid-template-columns: 1.6fr 1fr;
      gap: 18px;
      align-items: center;
    }
    h1 { margin: 0 0 4px; font-size: 18px; letter-spacing: .3px; font-family: var(--sans); }
    .subtitle { color: var(--muted); font-size: 12px; line-height: 1.4; }
    .controls {
      display: flex; gap: 10px; justify-content: flex-end; flex-wrap: wrap;
    }
    .controls details {
      border: 1px solid var(--line);
      background: var(--panel2);
      border-radius: 12px;
      padding: 6px 10px;
    }
    .controls details[open] {
      box-shadow: var(--shadowSoft);
    }
    .controls summary {
      cursor: pointer;
      font-weight: 700;
      font-size: 12px;
      list-style: none;
    }
    .controls summary::-webkit-details-marker { display: none; }
    .controls .utility-actions {
      display: grid;
      gap: 8px;
      margin-top: 8px;
    }
    button, .btn {
      border: 1px solid var(--line);
      background: var(--panel2);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      cursor: pointer;
      box-shadow: none;
      font-weight: 600;
      font-size: 13px;
      transition: background .18s ease, border-color .18s ease, color .18s ease, box-shadow .18s ease;
    }
    button:hover { border-color: var(--ink); background: var(--accent); }
    button:active { transform: translateY(1px); }
    .btn-secondary { background: var(--accent); box-shadow: none; }
    .btn-danger { border-color: rgba(255,92,122,.35); }
    .btn-danger:hover { border-color: rgba(255,92,122,.65); }
    .theme-switch { display: flex; gap: 6px; align-items: center; }
    .theme-switch select {
      border: 1px solid var(--line);
      background: var(--panel2);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 12px;
      font-weight: 600;
    }

    main { padding-top: 18px; }
    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 980px) {
      .topbar { grid-template-columns: 1fr; }
      .controls { justify-content: flex-start; }
      .grid { grid-template-columns: 1fr; }
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 18px;
      box-shadow: var(--shadowSoft);
      position: relative;
      transition: background .18s ease, border-color .18s ease, box-shadow .18s ease, transform .18s ease, opacity .18s ease;
    }
    .card-toggle {
      position: absolute;
      top: 12px;
      right: 12px;
      border: 1px solid var(--line);
      background: var(--panel2);
      color: var(--text);
      padding: 6px 10px;
      border-radius: 10px;
      font-size: 11px;
      font-weight: 700;
      cursor: pointer;
    }
    .card-toggle:hover { background: var(--accent); border-color: var(--ink); }
    body.card-focus { overflow: hidden; }
    body.card-focus::before {
      content: "";
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.08);
      z-index: 50;
    }
    .card.expanded {
      position: fixed;
      inset: 78px 22px 22px;
      z-index: 70;
      box-shadow: var(--shadow);
      overflow: auto;
      transform: translateZ(0);
    }
    .card.dimmed {
      opacity: 0.2;
      filter: blur(0.6px) saturate(0.9);
      pointer-events: none;
    }
    .card h2 {
      margin: 0 0 10px;
      font-size: 15px;
      letter-spacing: .6px;
      font-family: var(--sans);
    }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .row > * { flex: 1; }
    .row .tight { flex: 0 0 auto; }
    label { font-size: 12px; color: var(--muted); display: block; margin: 8px 0 6px; }
    input[type="text"], input[type="number"], textarea, select {
      width: 100%;
      border: 1px solid var(--line);
      background: var(--panel2);
      color: var(--text);
      padding: 10px 10px;
      border-radius: 12px;
      outline: none;
      font-size: 13px;
      transition: background .18s ease, border-color .18s ease, color .18s ease;
    }
    textarea { min-height: 92px; resize: vertical; }
    .mini { font-size: 12px; color: var(--muted); margin-top: 8px; }

    .chips { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 6px; }
    .chip {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      background: var(--chip);
      border: 1px solid var(--line);
      padding: 8px 10px;
      border-radius: 999px;
      font-size: 12px;
      color: var(--text);
      user-select: none;
      transition: background .18s ease, border-color .18s ease, color .18s ease;
    }
    .chip input { transform: translateY(1px); }
    .chip .chip-btn {
      border: 1px solid var(--line);
      background: var(--panel);
      color: var(--text);
      border-radius: 8px;
      padding: 2px 6px;
      font-size: 11px;
      cursor: pointer;
    }
    .pill {
      font-family: var(--mono);
      padding: 5px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--panel2);
      color: var(--muted);
      font-size: 11px;
      white-space: nowrap;
    }
    .pill.ink { color: var(--ink); border-color: rgba(58,61,94,.25); }

    .section-title {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      align-items: baseline;
      margin-bottom: 8px;
      padding-bottom: 6px;
      border-bottom: 1px dashed rgba(45,42,38,.15);
    }
    .section-title .hint { color: var(--muted); font-size: 12px; }

    .task {
      display: grid;
      grid-template-columns: 24px 1fr 110px 110px 34px;
      gap: 10px;
      align-items: center;
      padding: 9px 10px;
      border: 1px solid var(--line);
      background: var(--panel2);
      border-radius: 14px;
      margin-bottom: 8px;
      transition: background .18s ease, border-color .18s ease, color .18s ease;
    }
    .task input[type="checkbox"] { width: 18px; height: 18px; }
    .task input[type="text"] { padding: 9px 9px; }
    .task select { padding: 9px 9px; }
    .task .del {
      width: 34px; height: 34px; border-radius: 12px;
      background: rgba(255,92,122,.08);
      border: 1px solid rgba(255,92,122,.25);
      color: var(--text); cursor: pointer;
      box-shadow: none;
      font-weight: 900;
    }
    .task .del:hover { border-color: rgba(255,92,122,.55); }
    .task.done { opacity: .7; }
    .task.done .title { text-decoration: line-through; color: var(--muted); }

    .cols {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
    }
    @media (max-width: 980px) { .cols { grid-template-columns: 1fr; } }
    .stack-col {
      display: grid;
      grid-template-rows: 1fr 1fr;
      gap: 14px;
    }

    .mdbox {
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.45;
      white-space: pre-wrap;
      border: 1px dashed var(--ink);
      background: var(--panel2);
      padding: 12px;
      border-radius: 14px;
      min-height: 160px;
      max-height: 360px;
      overflow: auto;
    }

    .statusline { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
    .dot.ok { background: var(--ok); }
    .dot.warn { background: var(--warn); }
    .dot.bad { background: var(--danger); }

    .footer-note { color: var(--muted); font-size: 12px; margin-top: 10px; }
    a { color: var(--ink); }

    body.print-preview {
      background: #ffffff;
      color: #1f2234;
    }
    body.print-preview header {
      position: static;
      backdrop-filter: none;
      background: #ffffff;
    }
    body.print-preview .controls,
    body.print-preview button,
    body.print-preview .inlineForm,
    body.print-preview .del {
      display: none !important;
    }
    body.print-preview button.print-exit {
      display: inline-flex !important;
    }
    body.print-preview input,
    body.print-preview textarea,
    body.print-preview select {
      border: none;
      background: transparent;
      padding: 0;
      color: #1f2234;
      box-shadow: none;
    }
    body.print-preview .card {
      box-shadow: none;
    }

    .print-exit {
      position: fixed;
      top: 14px;
      right: 18px;
      z-index: 60;
      display: none;
    }
    body.print-preview .print-exit { display: inline-flex; }

    @media print {
      header,
      .controls,
      button,
      .inlineForm,
      .del {
        display: none !important;
      }
      .print-exit {
        display: none !important;
      }
      body {
        background: #ffffff;
        color: #1f2234;
      }
      .card {
        box-shadow: none;
      }
    }

    /* Toast */
    .toast {
      position: fixed;
      right: 16px;
      bottom: 16px;
      z-index: 50;
      background: var(--panel);
      border: 1px solid var(--line);
      box-shadow: none;
      padding: 10px 12px;
      border-radius: 14px;
      font-size: 12px;
      color: var(--text);
      opacity: 0;
      transform: translateY(6px);
      pointer-events: none;
      transition: opacity .18s ease, transform .18s ease;
    }
    .toast.show { opacity: 1; transform: translateY(0px); }

    /* Inline form */
    .inlineForm {
      border: 1px solid var(--line);
      background: var(--panel2);
      border-radius: 14px;
      padding: 10px;
      margin-top: 10px;
      display: none;
    }
    .inlineForm.show { display: block; }
    .inlineForm .cols { margin-top: 6px; }

    /* Forest */
    .span2 { grid-column: 1 / -1; } /* full-width card within the grid row */

    .forestWrap {
      border: 1px solid var(--line);
      background: var(--panel2);
      border-radius: 14px;
      padding: 10px;
      margin-top: 10px;
      overflow: hidden;
    }
    canvas#forestCanvas {
      width: 100%;
      height: 900px; /* taller to show mycelium network beneath labels */
      display: block;
      border-radius: 12px;
      background: var(--panel);
    }
    .forestLegend {
      margin-top: 10px;
      border: 1px solid var(--line);
      background: var(--panel2);
      border-radius: 14px;
      padding: 10px;
      font-size: 12px;
      color: var(--muted);
      display: none;
    }
    .forestLegend.show { display: block; }
    .forestLegend b { color: var(--ink); }
    .forestLegend code { font-family: var(--mono); font-size: 11px; color: var(--ink); }

    /* Concept graph */
    #conceptGraphCanvas {
      width: 100%;
      height: 320px;
      display: block;
      border-radius: 12px;
      background: var(--panel);
      border: 1px solid var(--line);
    }
    @media (max-width: 980px) {
      .card.expanded { inset: 72px 12px 12px; }
    }
    .graphHint { font-size: 12px; color: var(--muted); margin-top: 8px; }

    .apiKeyInput {
      min-width: 220px;
    }

    .focus-indicator {
      position: fixed;
      top: 12px;
      left: 12px;
      z-index: 80;
      display: none;
      gap: 8px;
      align-items: center;
      background: var(--panel2);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 6px 10px;
      font-size: 12px;
      color: var(--text);
      box-shadow: var(--shadowSoft);
    }
    .focus-indicator button {
      padding: 6px 8px;
      font-size: 12px;
    }
    .scale-debug {
      position: fixed;
      top: 52px;
      left: 12px;
      z-index: 80;
      display: none;
      background: var(--panel2);
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 11px;
      color: var(--text);
      box-shadow: var(--shadowSoft);
      line-height: 1.4;
      max-width: 240px;
    }
  </style>
</head>

<body>
<button class="btn-secondary print-exit" id="btnExitPrintPreview">Exit print preview</button>
<header>
  <div class="wrap topbar">
    <div>
      <h1>WILL HALLETT EES/GCAS SPRING 2026</h1>
      <div class="subtitle">
        Default posture: <span class="pill">9–5 = material-building</span> • evenings/weekends = deliverables.
        Everything auto-saves locally.
      </div>
    </div>
    <div class="controls">
      <label class="chip tight theme-switch">
        <span>Theme</span>
        <select id="themeSelect" aria-label="Theme mode">
          <option value="soft">Soft</option>
          <option value="bright">Bright</option>
          <option value="dark">Dark</option>
        </select>
      </label>
      <button class="btn-secondary" id="btnResetDay">Reset “Day”</button>
      <button class="btn-secondary" id="btnPrintPreview">Print preview</button>
      <details>
        <summary>Utilities</summary>
        <div class="utility-actions">
          <button class="btn-secondary" id="btnResetWeek">Weekly reset</button>
          <button class="btn-secondary" id="btnBackup">Export JSON backup</button>
          <button class="btn-secondary" id="btnImport">Import JSON backup</button>
          <button class="btn-secondary" id="btnSaveVault">Save to Vault</button>
          <button class="btn-danger" id="btnHardReset">Hard reset (wipe local)</button>
        </div>
      </details>
    </div>
  </div>
</header>
<div id="focusIndicator" class="focus-indicator">
  <span id="focusLabel">Focus</span>
  <button class="btn-secondary" id="focusBack">Back</button>
</div>
<div id="scaleDebug" class="scale-debug"></div>

<main class="wrap">
  <!-- Week Summary FULL WIDTH -->
  <div class="grid" style="margin-top:14px;">
    <section class="card span2">
      <div class="section-title">
        <h2>Week Summary</h2>
        <div class="hint">Stability readout + forest (no extra data entry)</div>
      </div>

      <div id="weekSummary" class="mini"></div>

      <div class="forestWrap" aria-label="Weekly forest visualization">
        <div class="row" style="margin-bottom:10px;">
          <button class="btn-secondary" id="btnToggleLegend" title="Toggle legend">Legend</button>
          <button class="btn-secondary" id="btnExportPNG" title="Download forest as JPG">Export JPG</button>
          <button class="btn-secondary" id="btnExportSVG" title="Download forest as SVG">Export SVG</button>
          <button class="btn-secondary" id="btnSimForest" title="Toggle max-week simulation">Simulate Max</button>
          <button class="btn-secondary" id="btnClearGhost" title="Clear last-week ghost overlay">Clear ghost</button>
          <label class="chip tight" style="padding:6px 10px;">
            <input type="checkbox" id="toggleFullGhost" />
            Full ghost
          </label>
          <label class="chip tight" style="padding:6px 10px;">
            <input type="checkbox" id="toggleHiResPng" />
            Hi-res JPG
          </label>
        </div>

        <canvas id="forestCanvas"></canvas>

        <div id="forestLegend" class="forestLegend"></div>
      </div>

      <div class="footer-note">
        This is computed from tasks + course statuses + your writing. It grows during the week (max-growth memory for writing/task completion), and overlays last week as a faint trace. Stress and daily-mode checkboxes remain dynamic.
      </div>
    </section>
  </div>

  <div class="grid">
    <!-- Left column: core structure -->
    <section class="card">
      <div class="section-title">
        <h2>Core Rhythm</h2>
        <div class="hint">Set the rules of engagement</div>
      </div>

      <label>Semester intent (1–2 sentences)</label>
      <input type="text" id="intent" placeholder="e.g., Build real understanding; avoid backlog; weekend slay sessions bounded." />

      <div class="cols" style="margin-top:10px;">
        <div>
          <label>Weekday core window</label>
          <input type="text" id="coreWindow" placeholder="e.g., 9:00–17:00" />
          <div class="mini">Used in the markdown export header.</div>
        </div>
        <div>
          <label>Weekend posture</label>
          <input type="text" id="weekendPosture" placeholder="e.g., deliverables + exam review + downtime" />
          <div class="mini">Keep bounded so it doesn’t become spillover.</div>
        </div>
        <div>
          <label>Weekly rebalance day</label>
          <select id="rebalanceDay">
            <option>Friday</option><option>Saturday</option><option>Sunday</option><option>Monday</option>
          </select>
          <div class="mini">20 minutes to re-allocate blocks.</div>
        </div>
      </div>

      <label style="margin-top:12px;">Modes checklist (daily + weekly anchors)</label>
      <div class="row inlineForm show" id="modeEditor" style="margin-bottom:8px;">
        <input type="text" id="newModeLabel" placeholder="Add mode label" />
        <select id="newModeScope">
          <option value="daily">daily</option>
          <option value="weekly" selected>weekly</option>
        </select>
        <button class="btn-secondary tight" id="btnAddMode">Add</button>
      </div>
      <div class="chips" id="modeChips"></div>

      <div class="footer-note">
        Tip: keep one protected “absorption block” each weekday (no new inputs; only consolidation).
      </div>
    </section>

    <!-- Right column: today planner -->
    <section class="card">
      <div class="section-title">
        <h2>Today — Focus & Blocks</h2>
        <div class="hint">Plan lightly; execute steadily</div>
      </div>

      <div class="cols">
        <div>
          <label>Keystone course today</label>
          <select id="keystoneToday"></select>
          <div class="mini">If this is stable, the day is stable.</div>
        </div>
        <div>
          <label>Absorption block (60–90 min)</label>
          <input type="text" id="absorption" placeholder="e.g., AOIC: re-derive key mechanisms + quiz-style Qs" />
        </div>
        <div>
          <label>Workout (quick note)</label>
          <input type="text" id="workout" placeholder="e.g., 35 min run + mobility" />
        </div>
      </div>

      <label style="margin-top:12px;">Quick capture (what matters / what’s fuzzy)</label>
      <textarea id="todayNotes" placeholder="2–6 bullet points: what landed, what’s confusing, what to ask ChatGPT / prof."></textarea>

      <div class="row" style="margin-top:10px;">
        <button id="btnAddTodayTask">+ Add Today Task</button>
        <button class="btn-secondary" id="btnClearTodayDone">Clear completed</button>
      </div>

      <div id="todayTasks" style="margin-top:10px;"></div>
    </section>
  </div>

  <div class="grid" style="margin-top:14px;">
    <!-- Courses -->
    <section class="card">
      <div class="section-title">
        <h2>Courses — Modes + Notes</h2>
        <div class="hint">Keep each course bounded</div>
      </div>

      <div class="row">
        <div>
          <label>Courses (editable)</label>
          <input type="text" id="courseList" placeholder="AOIC; Neurobiology; Biological Modeling; Calc II; Probability/Prereqs; GCAS Writing" />
          <div class="mini">Separate with semicolons.</div>
        </div>
        <div class="tight">
          <label>&nbsp;</label>
          <button class="btn-secondary" id="btnApplyCourses">Apply</button>
        </div>
      </div>

      <div id="courseCards" style="margin-top:12px;"></div>
    </section>

    <div class="stack-col">
      <!-- Writing sessions -->
      <section class="card focus-card">
        <div class="section-title">
          <h2>GCAS Writing</h2>
          <div class="hint">Light, consistent, non-sprawling</div>
        </div>

        <div class="cols" style="margin-top:10px;">
          <div>
            <label>GCAS schedule</label>
            <input type="text" id="writingSchedule" placeholder="e.g., Tue/Thu afternoons" />
          </div>
          <div>
            <label>Current writing thread</label>
            <input type="text" id="writingThread" placeholder="e.g., Neural Set; Saussure/Lacan; modeling epistemology" />
          </div>
          <div>
            <label>GCAS targets</label>
            <input type="text" id="writingTargets" placeholder="e.g., 300 words target; Badiou set theory; Freud neurobiology" />
          </div>
        </div>
        <label style="margin-top:12px;">GCAS notes</label>
        <textarea id="writingNotes" placeholder="Short synthesis, questions, or conceptual bridges to keep."></textarea>
        <div class="footer-note">Keep cadence and conceptual targets lightweight but explicit.</div>
      </section>

      <!-- Prose writing -->
      <section class="card focus-card">
        <div class="section-title">
          <h2>Prose Writing</h2>
          <div class="hint">Drafts, reflections, and narrative output</div>
        </div>

        <div class="cols" style="margin-top:10px;">
          <div>
            <label>Prose schedule</label>
            <input type="text" id="proseSchedule" placeholder="e.g., Wed/Fri afternoons" />
          </div>
          <div>
            <label>Current prose project</label>
            <input type="text" id="proseProject" placeholder="e.g., Semester reflection essay; narrative recap" />
          </div>
          <div>
            <label>Prose targets</label>
            <input type="text" id="proseTargets" placeholder="e.g., 300 words; draft scene; revision focus" />
          </div>
        </div>

        <label style="margin-top:12px;">Prose notes</label>
        <textarea id="proseNotes" placeholder="Short notes, tone cues, or narrative beats to keep." ></textarea>

        <div class="footer-note">Separate from GCAS; keep prose constraints visible.</div>
      </section>
    </div>
  </div>

  <div class="grid" style="margin-top:14px;">
    <!-- Weekend deliverables -->
    <section class="card">
      <div class="section-title">
        <h2>Weekend Deliverables</h2>
        <div class="hint">Slay sessions with edges</div>
      </div>

      <div class="row">
        <button id="btnAddWeekendTask">+ Add deliverable</button>
        <button class="btn-secondary" id="btnClearWeekendDone">Clear completed</button>
      </div>

      <div id="weekendTasks" style="margin-top:10px;"></div>

      <label style="margin-top:12px;">Downtime boundary (write it like a rule)</label>
      <input type="text" id="downtimeRule" placeholder="e.g., Sat night off; Sun morning slow; no work after 8pm." />
    </section>

    <!-- Markdown export -->
    <section class="card">
      <div class="section-title">
        <h2>.md Export (Obsidian)</h2>
        <div class="hint">Generate, copy, download</div>
      </div>

      <div class="row">
        <button id="btnGenerateMd">Generate Markdown</button>
        <input type="password" id="openaiKey" class="apiKeyInput" placeholder="OpenAI API key" />
        <button class="btn-secondary" id="btnCopyMd">Copy</button>
        <button class="btn-secondary" id="btnDownloadMd">Download .md</button>
        <button class="btn-secondary" id="btnClearMd">Clear Markdown</button>
        <button class="btn-secondary" id="btnArchiveBundle">Archive bundle</button>
      </div>

      <label style="margin-top:12px;">Markdown preview</label>
      <div id="mdPreview" class="mdbox"></div>

      <div class="statusline" style="margin-top:10px;">
        <span class="dot ok"></span><span class="mini">Saved locally</span>
        <span class="dot warn"></span><span class="mini">Reset week = clears writing + tasks</span>
        <span class="dot bad"></span><span class="mini">Hard reset wipes everything</span>
      </div>
    </section>
  </div>

  <div class="grid" style="margin-top:14px;">
    <!-- Concept graph -->
    <section class="card span2">
      <div class="section-title">
        <h2>Concept Graph (3D)</h2>
        <div class="hint">Major concepts and linkages across writing</div>
      </div>
      <canvas id="conceptGraphCanvas" aria-label="3D concept linkage graph"></canvas>
      <div class="row" style="margin-top:10px;">
        <button class="btn-secondary" id="btnRegenGraph">Regenerate graph</button>
        <label class="chip tight" style="padding:6px 10px;">
          <span style="margin-right:6px;">Spacing</span>
          <input type="range" id="graphSpacing" min="0.8" max="4.5" step="0.1" value="4.5" />
        </label>
      </div>
      <div class="graphHint">Drag to rotate; scroll to zoom. Nodes are inferred from all writing artifacts.</div>
    </section>
  </div>
</main>

<div id="toast" class="toast" role="status" aria-live="polite"></div>
<input type="file" id="importFile" accept="application/json" style="display:none" />

<script>
  // ---------- Version + migration ----------
  const STORAGE_KEY = "semester_dashboard_v1";
  const USER_SEED_SALT_KEY = `${STORAGE_KEY}_seed_salt`;
  const CURRENT_VERSION = 11; // add forest simulation toggle

  const DEFAULT = {
    version: CURRENT_VERSION,

    intent: "",
    coreWindow: "9:00–17:00",
    weekendPosture: "Deliverables + exam review + downtime",
    rebalanceDay: "Sunday",

    // Daily vs weekly semantics
    modeScope: {},

    modeChecks: {},

    courses: ["AOIC", "Neurobiology", "Biological Modeling", "Calc II", "Probability/Prereqs", "GCAS Writing"],
    courseNotes: {},

    keystoneToday: "AOIC",
    absorption: "",
    workout: "",
    todayNotes: "",
    todayTasks: [],
    weekendTasks: [],

    writingSchedule: "Tue/Thu afternoons",
    writingThread: "",
    writingTargets: "300 words target; Badiou set theory; Freud neurobiology",
    writingNotes: "",

    proseSchedule: "Wed/Fri afternoons",
    proseProject: "",
    proseTargets: "300 words; draft scene; revision focus",
    proseNotes: "",

    env: null,

    downtimeRule: "",
    mdCache: "",
    lastExport: null,
    printPreview: false,
    theme: "soft",
    llmKey: "",
    llmNoteAnalyses: {},
    llmConferenceResponse: "",

    // Forest
    forest: {
      legendOn: false,
      hiResPng: false,
      showFullGhost: false,
      simulateMax: false,
      weekly: { weekId: "", courses: {} },
      legacy: {
        weekId: "",
        perCourseMax: {}   // max-memory for writing volume / syntax / cohesion / completed tasks
      }
    }
  };

  function structuredDefault() {
    return (typeof structuredClone === "function")
      ? structuredClone(DEFAULT)
      : JSON.parse(JSON.stringify(DEFAULT));
  }

  function migrateState(s) {
    const v = s?.version || 1;
    if (v < 2) {
      s.modeScope = s.modeScope || structuredDefault().modeScope;
      s.version = 2;
    }
    if (v < 3) {
      s.forest = s.forest || structuredDefault().forest;
      s.version = 3;
    }
    if (v < 4) {
      // v4: remove maxStress storage if present; keep only the intended max-memory metrics
      if (s.forest?.perCourseMax) {
        for (const k of Object.keys(s.forest.perCourseMax)) {
          if ("maxStress" in s.forest.perCourseMax[k]) delete s.forest.perCourseMax[k].maxStress;
        }
      }
      s.version = 4;
    }
    if (v < 5) {
      s.proseProject = s.proseProject ?? "";
      s.proseNotes = s.proseNotes ?? "";
      s.version = 5;
    }
    if (v < 6) {
      s.lastExport = s.lastExport ?? null;
      s.printPreview = s.printPreview ?? false;
      s.forest = s.forest || structuredDefault().forest;
      s.forest.hiResPng = s.forest.hiResPng ?? false;
      s.version = 6;
    }
    if (v < 7) {
      s.writingSchedule = s.writingSchedule ?? structuredDefault().writingSchedule;
      s.writingTargets = s.writingTargets ?? structuredDefault().writingTargets;
      s.writingNotes = s.writingNotes ?? "";
      s.proseSchedule = s.proseSchedule ?? structuredDefault().proseSchedule;
      s.proseTargets = s.proseTargets ?? structuredDefault().proseTargets;
      s.env = s.env ?? null;
      s.version = 7;
    }
    if (v < 8) {
      s.forest = s.forest || structuredDefault().forest;
      s.forest.weekly = s.forest.weekly || structuredDefault().forest.weekly;
      s.version = 8;
    }
    if (v < 9) {
      s.llmKey = s.llmKey ?? "";
      s.llmNoteAnalyses = s.llmNoteAnalyses ?? {};
      s.llmConferenceResponse = s.llmConferenceResponse ?? "";
      s.forest = s.forest || structuredDefault().forest;
      s.forest.showFullGhost = s.forest.showFullGhost ?? false;
      s.version = 9;
    }
    if (v < 10) {
      s.theme = s.theme ?? "soft";
      s.version = 10;
    }
    if (v < 11) {
      s.forest = s.forest || structuredDefault().forest;
      s.forest.simulateMax = s.forest.simulateMax ?? false;
      s.version = 11;
    }
    return s;
  }

  function migrateForestState(s) {
    s.forest = s.forest || structuredDefault().forest;
    s.forest.legacy = s.forest.legacy || { weekId: "", perCourseMax: {} };
    if (s.forest.weekId != null) {
      if (!s.forest.legacy.weekId) s.forest.legacy.weekId = s.forest.weekId;
      delete s.forest.weekId;
    }
    if (s.forest.perCourseMax) {
      if (!s.forest.legacy.perCourseMax || !Object.keys(s.forest.legacy.perCourseMax).length) {
        s.forest.legacy.perCourseMax = s.forest.perCourseMax;
      }
      delete s.forest.perCourseMax;
    }
    return s;
  }

  function getLegacyForest() {
    state.forest = state.forest || structuredDefault().forest;
    state.forest.legacy = state.forest.legacy || { weekId: "", perCourseMax: {} };
    return state.forest.legacy;
  }

  function loadState() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return structuredDefault();
      const parsed = migrateState(JSON.parse(raw));
      const def = structuredDefault();
      const merged = {
        ...def,
        ...parsed,
        version: CURRENT_VERSION,
        modeChecks: { ...def.modeChecks, ...(parsed.modeChecks||{}) },
        modeScope:  { ...def.modeScope,  ...(parsed.modeScope||{})  },
        forest:     { ...def.forest,     ...(parsed.forest||{})     },
      };
      return migrateForestState(merged);
    } catch {
      return structuredDefault();
    }
  }

  let state = loadState();

  function pruneV01SnapshotsInPlace(v01, opts = {}) {
    if (!v01?.snapshots) return;
    const keepWeeks = opts.keepWeeks ?? 1;
    const keepDaysPerCourse = opts.keepDaysPerCourse ?? 3;
    const weekKeys = Object.keys(v01.snapshots).sort();
    const keepSet = new Set(weekKeys.slice(-keepWeeks));
    for (const wk of weekKeys) {
      if (!keepSet.has(wk)) delete v01.snapshots[wk];
    }
    for (const wk of Object.keys(v01.snapshots)) {
      const courses = v01.snapshots[wk]?.courses || {};
      Object.keys(courses).forEach((ck) => {
        const days = courses[ck]?.days || {};
        const dayKeys = Object.keys(days).sort();
        const keepDays = new Set(dayKeys.slice(-keepDaysPerCourse));
        dayKeys.forEach((dk) => {
          if (!keepDays.has(dk)) delete days[dk];
        });
      });
    }
  }

  function safeLocalStorageSetItem(key, value) {
    try {
      localStorage.setItem(key, value);
      return true;
    } catch (e) {
      if (String(e && e.name) === "QuotaExceededError") {
        try {
          if (state?.forest?.v01?.snapshots) {
            pruneV01SnapshotsInPlace(state.forest.v01, { keepWeeks: 1, keepDaysPerCourse: 3 });
          }
          localStorage.setItem(key, JSON.stringify(state));
          return true;
        } catch {
          console.warn("Save skipped: quota exceeded even after pruning");
          return false;
        }
      }
      throw e;
    }
  }

  function saveState() {
    state.version = CURRENT_VERSION;
    safeLocalStorageSetItem(STORAGE_KEY, JSON.stringify(state));
  }

  let saveStateTimer = null;
  function saveStateSoon(delay = 120) {
    if (saveStateTimer) clearTimeout(saveStateTimer);
    saveStateTimer = setTimeout(() => {
      saveStateTimer = null;
      saveState();
    }, delay);
  }

  function applyImportedState(raw) {
    const parsed = migrateState(raw || {});
    const def = structuredDefault();
    state = migrateForestState({
      ...def,
      ...parsed,
      version: CURRENT_VERSION,
      modeChecks: { ...def.modeChecks, ...(parsed.modeChecks || {}) },
      modeScope: { ...def.modeScope, ...(parsed.modeScope || {}) },
      forest: { ...def.forest, ...(parsed.forest || {}) }
    });
    saveState();
    hydrateInputs();
  }

  function uid() {
    return Math.random().toString(16).slice(2) + Date.now().toString(16);
  }

  let cachedSeedSalt = null;
  function getUserSeedSalt() {
    if (cachedSeedSalt) return cachedSeedSalt;
    try {
      const existing = localStorage.getItem(USER_SEED_SALT_KEY);
      if (existing) {
        cachedSeedSalt = existing;
        return existing;
      }
      const salt = uid();
      localStorage.setItem(USER_SEED_SALT_KEY, salt);
      cachedSeedSalt = salt;
      return salt;
    } catch {
      cachedSeedSalt = cachedSeedSalt || "seed";
      return cachedSeedSalt;
    }
  }

  // ---------- Toast ----------
  let toastTimer = null;
  function toast(msg) {
    const t = document.getElementById("toast");
    t.textContent = msg;
    t.classList.add("show");
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => t.classList.remove("show"), 1200);
  }

  // ---------- Elements ----------
  const el = (id) => document.getElementById(id);

  const intentEl = el("intent");
  const coreWindowEl = el("coreWindow");
  const weekendPostureEl = el("weekendPosture");
  const rebalanceDayEl = el("rebalanceDay");
  const themeSelectEl = el("themeSelect");
  const modeChipsEl = el("modeChips");
  const modeEditorEl = el("modeEditor");
  const newModeLabelEl = el("newModeLabel");
  const newModeScopeEl = el("newModeScope");

  const keystoneTodayEl = el("keystoneToday");
  const absorptionEl = el("absorption");
  const workoutEl = el("workout");
  const todayNotesEl = el("todayNotes");
  const todayTasksEl = el("todayTasks");

  const weekSummaryEl = el("weekSummary");

  const courseListEl = el("courseList");
  const courseCardsEl = el("courseCards");

  const writingScheduleEl = el("writingSchedule");
  const writingThreadEl = el("writingThread");
  const writingTargetsEl = el("writingTargets");
  const writingNotesEl = el("writingNotes");

  const proseScheduleEl = el("proseSchedule");
  const proseProjectEl = el("proseProject");
  const proseTargetsEl = el("proseTargets");
  const proseNotesEl = el("proseNotes");
  const conceptGraphCanvas = el("conceptGraphCanvas");
  const btnRegenGraph = el("btnRegenGraph");
  const graphSpacingEl = el("graphSpacing");

  const weekendTasksEl = el("weekendTasks");
  const downtimeRuleEl = el("downtimeRule");

  const mdPreviewEl = el("mdPreview");
  const openaiKeyEl = el("openaiKey");
  const btnImportEl = el("btnImport");
  const importFileEl = el("importFile");
  const btnSaveVaultEl = el("btnSaveVault");

  // Forest elements
  const forestCanvas = el("forestCanvas");
  const forestLegendEl = el("forestLegend");
  const toggleHiResPngEl = el("toggleHiResPng");
  const toggleFullGhostEl = el("toggleFullGhost");
  const btnSimForest = el("btnSimForest");
  const focusIndicatorEl = el("focusIndicator");
  const focusLabelEl = el("focusLabel");
  const focusBackEl = el("focusBack");
  const scaleDebugEl = el("scaleDebug");

  let focusMode = "grid";
  let focusedCourse = null;
  let lastCourseCells = [];
  let leavesEnabled = true;
  let scaleDebugOn = false;
  let lastScaleStats = {};

  // ---------- Utilities ----------
  function escapeHtml(s) {
    return (s || "").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
  }

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function lerp(a, b, t) { return a + (b - a) * t; }
  function lerpInt(a, b, t) { return Math.round(lerp(a, b, t)); }

  function smoothstep(edge0, edge1, x) {
    const t = clamp((x - edge0) / (edge1 - edge0), 0, 1);
    return t * t * (3 - 2 * t);
  }

  const IDLE_EPS = 0.02;
  const IDLE_TARGET_FRAC = 0.10;
  const EFFORT_MORPH_ONSET = 0.06;
  const EFFORT_MORPH_FULL = 0.35;
  const EFFORT_TASKS_CAP = 6;
  const EFFORT_DAYS_CAP = 5;
  const EFFORT_WORDS_CAP = 220;

  function computeEffortAbs(tasks = 0, writingDays = 0, words = 0) {
    if (!tasks && !writingDays && !words) return 0;
    const tasksN = clamp(tasks / EFFORT_TASKS_CAP, 0, 1);
    const daysN = clamp(writingDays / EFFORT_DAYS_CAP, 0, 1);
    const wordsN = clamp(words / EFFORT_WORDS_CAP, 0, 1);
    const effort = 0.45 * daysN + 0.35 * tasksN + 0.20 * wordsN;
    return clamp(effort, 0, 1);
  }

  function effortGateFor(effortAbs, idleMode = false) {
    if (idleMode) return 0;
    return smoothstep(EFFORT_MORPH_ONSET, EFFORT_MORPH_FULL, clamp(effortAbs, 0, 1));
  }

  function targetFracForGrowth(growthRel, idleMode = false) {
    if (idleMode) return IDLE_TARGET_FRAC;
    return 0.28 + (0.62 - 0.28) * smoothstep(0.0, 1.0, clamp(growthRel || 0, 0, 1));
  }

  function getGrowthN(data = {}) {
    const weekly = clamp(data.weeklyScoreN || 0, 0, 1);
    const tasksBase = clamp(data.tasksN || 0, 0, 1);
    const wordsBase = clamp(data.wordsN || 0, 0, 1);
    const recursion = clamp(data.recursionN || 0, 0, 1);
    const cohesion = clamp(data.cohesionN || 0, 0, 1);

    const tasksTerm = Math.pow(tasksBase, 0.75);
    const wordsTerm = Math.pow(wordsBase, 0.60);

    const weights = {
      weekly: 0.35,
      tasks: 0.20,
      words: 0.15,
      recursion: 0.15,
      cohesion: 0.15
    };

    const rawGrowth =
      weights.weekly * weekly +
      weights.tasks * tasksTerm +
      weights.words * wordsTerm +
      weights.recursion * recursion +
      weights.cohesion * cohesion;

    const growthN = clamp(rawGrowth, 0, 1);
    return {
      value: growthN,
      rawGrowth,
      weekly,
      tasksTerm,
      wordsTerm,
      recursion,
      cohesion
    };
  }

  function computeGrowthNormalization(courses, courseSignals = {}) {
    const byCourseId = new Map();
    let minRaw = Infinity;
    let maxRaw = -Infinity;

    courses.forEach((course) => {
      const info = courseSignals[course]?.growthInfo || getGrowthN({});
      const raw = info?.rawGrowth ?? 0;
      minRaw = Math.min(minRaw, raw);
      maxRaw = Math.max(maxRaw, raw);
      byCourseId.set(course, { rawGrowth: raw, growthInfo: info });
    });

    const range = maxRaw - minRaw;
    const flat = range < 1e-6;
    if (flat) {
      courses.forEach((course) => {
        const entry = byCourseId.get(course) || {};
        const raw = entry.rawGrowth ?? 0;
        const abs = (raw >= 0 && raw <= 1)
          ? clamp(raw, 0, 1)
          : (1 - Math.exp(-1.5 * Math.max(0, raw)));
        const growthRel = clamp(0.15 + 0.85 * abs, 0.15, 1);
        byCourseId.set(course, { ...entry, rel: 0, growthRel });
      });
    } else {
      const denom = range + 1e-6;
      courses.forEach((course) => {
        const entry = byCourseId.get(course) || {};
        const raw = entry.rawGrowth ?? 0;
        const rel = (raw - minRaw) / denom;
        const growthRel = clamp(0.15 + 0.85 * rel, 0, 1);
        byCourseId.set(course, { ...entry, rel, growthRel });
      });
    }

    return { minRaw, maxRaw, range, flat, byCourseId };
  }

  function getEffectiveCourseSignals(courseName, baseSignals, flags) {
    const s = { ...baseSignals };
    if (!flags?.simulateMax) return s;
    if (s.weeklyScoreN != null) s.weeklyScoreN = 1;
    if (s.weekendScoreN != null) s.weekendScoreN = 1;
    if (s.tasksN != null) s.tasksN = 1;
    if (s.wordsN != null) s.wordsN = 1;
    if (s.recursionN != null) s.recursionN = 1;
    if (s.cohesionN != null) s.cohesionN = 1;
    if (s.diversityN != null) s.diversityN = 1;
    if (s.argumentN != null) s.argumentN = 1;
    if (s.abstractionN != null) s.abstractionN = 1;
    if (s.tasks != null) s.tasks = Math.max(s.tasks, s.maxTasks ?? 60);
    if (s.words != null) s.words = Math.max(s.words, s.maxWords ?? 2400);
    if (s.recursion != null) s.recursion = Math.max(s.recursion, s.maxRecursion ?? s.recursion);
    if (s.abstraction != null) s.abstraction = Math.max(s.abstraction, s.maxAbstraction ?? s.abstraction);
    if (s.cohesion != null) s.cohesion = Math.max(s.cohesion, s.maxCohesion ?? s.cohesion);
    if (s.argument != null) s.argument = Math.max(s.argument, s.maxArgument ?? s.argument);
    if (s.diversity != null) s.diversity = Math.max(s.diversity, s.maxDiversity ?? s.diversity);
    if (s.writingDays != null) s.writingDays = Math.max(s.writingDays, EFFORT_DAYS_CAP);
    return s;
  }

  function signalSignature(eff) {
    const fmt = (v) => (Math.round(clamp(Number(v) || 0, 0, 1) * 1000) / 1000).toFixed(3);
    return [
      fmt(eff.weeklyScoreN),
      fmt(eff.weekendScoreN),
      fmt(eff.tasksN),
      fmt(eff.wordsN),
      fmt(eff.recursionN),
      fmt(eff.abstractionN),
      fmt(eff.cohesionN),
      fmt(eff.argumentN),
      fmt(eff.diversityN),
      fmt(eff.stress),
      Math.round(eff.writingDays || 0)
    ].join("|");
  }

  function getGeomCacheKey(courseName, flags, effectiveSignals, growthRel, weekId, dayKey, modeKey, seedSalt) {
    const sprout = (!flags?.simulateMax && (growthRel ?? 0) < 0.18) ? 1 : 0;
    const sig = hashString(signalSignature(effectiveSignals || {}));
    return [
      courseName,
      `mode:${modeKey || "grid"}`,
      `simMax:${flags?.simulateMax ? 1 : 0}`,
      `sprout:${sprout}`,
      `week:${weekId || ""}`,
      `day:${dayKey || ""}`,
      `seed:${seedSalt || ""}`,
      `sig:${sig}`,
      `gen:${GEN_VERSION}`
    ].join("|");
  }

  const forestRuntime = {
    legacy: {
      geomCache: new Map(),
      prevGeomByKey: new Map()
    },
    v01: {}
  };
  const geomCache = forestRuntime.legacy.geomCache;
  const prevGeomByKey = forestRuntime.legacy.prevGeomByKey;

  function invalidateForestCaches() {
    geomCache.clear();
    prevGeomByKey.clear();
    if (typeof geomCacheV01 !== "undefined") geomCacheV01.clear();
    if (state?.forest?.v01) state.forest.v01.lastMetrics = null;
  }

  const MetricsReporter = (() => {
    let frame = 0;
    let lastReport = null;

    function ensurePanel() {
      if (!METRICS.toPanel) return null;
      if (typeof document === "undefined") return null;
      let panel = document.getElementById(METRICS.panelId);
      if (!panel) {
        panel = document.createElement("pre");
        panel.id = METRICS.panelId;
        panel.style.position = "fixed";
        panel.style.top = "92px";
        panel.style.left = "12px";
        panel.style.zIndex = "80";
        panel.style.padding = "8px 10px";
        panel.style.border = "1px solid rgba(0,0,0,0.12)";
        panel.style.borderRadius = "8px";
        panel.style.background = "rgba(255,255,255,0.85)";
        panel.style.color = "#111";
        panel.style.fontSize = "11px";
        panel.style.lineHeight = "1.4";
        panel.style.opacity = "0.85";
        panel.style.pointerEvents = "none";
        panel.style.whiteSpace = "pre-wrap";
        document.body.appendChild(panel);
      }
      return panel;
    }

    function round(n, d = 3) {
      if (typeof n !== "number" || !isFinite(n)) return "—";
      return n.toFixed(d);
    }

    function summarizeCourse(courseName, stats) {
      return {
        name: courseName,
        growthRel: stats?.growthRel ?? 0,
        scaleFinal: stats?.scale?.scaleFinal ?? 0
      };
    }

    function computeWarnings(report) {
      const warnings = [];
      const spread = report?.normalization?.spread ?? 0;
      if (spread < METRICS.warn.spreadEps) warnings.push("GROWTH_SPREAD_COLLAPSE");

      const relVals = [];
      const relMap = report?.normalization?.byCourse || {};
      Object.values(relMap).forEach((v) => {
        if (typeof v?.growthRel === "number") relVals.push(v.growthRel);
      });
      if (relVals.length) {
        const relSpread = Math.max(...relVals) - Math.min(...relVals);
        if (relSpread < 0.05) warnings.push("REL_VALUES_FLAT");
      }
      if (report?.normalization?.idleMode) warnings.push("IDLE_MODE_SPROUT");

      (report?.courses || []).forEach((c) => {
        const bboxH = c?.bbox?.h ?? 0;
        if (bboxH < METRICS.warn.bboxMinHpx) warnings.push(`BBOX_DEGENERATE:${c.name}`);
        const scaleRaw = c?.scale?.yScaleRaw ?? c?.scale?.scaleRaw;
        const widthCap = c?.scale?.widthCapScale;
        if (typeof scaleRaw === "number" && typeof widthCap === "number") {
          if (widthCap < scaleRaw * METRICS.warn.widthCapDominanceRatio) {
            warnings.push(`WIDTH_CAP_DOMINANT:${c.name}`);
          }
        }
      });
      return warnings;
    }

    function formatText(report) {
      const spread = report?.normalization?.spread ?? 0;
      const lines = [];
      lines.push(`frame=${report.frame} mode=${report.mode} spread=${round(spread, 3)}`);
      if (report.selectedCourse) {
        const c = (report.courses || []).find((row) => row.name === report.selectedCourse);
        if (c) {
          lines.push(`selected=${c.name} growthRel=${round(c.growthRel, 3)} targetFrac=${round(c.targetFrac, 3)}`);
          lines.push(`bboxH=${round(c.bbox?.h, 1)} scaleFinal=${round(c.scale?.scaleFinal, 3)}`);
        }
      }
      const topGrowth = report?.top?.byGrowthRel || [];
      if (topGrowth.length) {
        lines.push(`topGrowthRel: ${topGrowth.map(t => `${t.name}:${round(t.growthRel, 3)}`).join(" | ")}`);
      }
      const topScale = report?.top?.byScaleFinal || [];
      if (topScale.length) {
        lines.push(`topScaleFinal: ${topScale.map(t => `${t.name}:${round(t.scaleFinal, 3)}`).join(" | ")}`);
      }
      const warnings = report?.warnings || [];
      if (warnings.length) lines.push(`warnings: ${warnings.join(", ")}`);
      return lines.join("\n");
    }

    function publish(report) {
      if (METRICS.toConsole && typeof console !== "undefined") {
        const spread = report?.normalization?.spread ?? 0;
        const title = `[ForestMetrics] frame=${report.frame} mode=${report.mode} spread=${round(spread, 3)}`;
        console.groupCollapsed(title);
        console.log("report", report);
        console.log("warnings", report.warnings || []);
        console.log("top", report.top || {});
        console.groupEnd();
      }
      if (METRICS.toPanel) {
        const panel = ensurePanel();
        if (panel) panel.textContent = formatText(report);
      }
    }

    function report(payload) {
      if (!METRICS.enabled) return;
      frame += 1;
      if (frame % METRICS.reportEveryNFrames !== 0) return;
      const report = {
        ...payload,
        frame
      };
      report.normalization = report.normalization || {};
      if (typeof report.normalization.spread !== "number") {
        report.normalization.spread = (report.normalization.maxRaw ?? 0) - (report.normalization.minRaw ?? 0);
      }
      report.warnings = computeWarnings(report);
      lastReport = report;
      publish(report);
    }

    return { report };
  })();

  function getCSSVar(name){
    return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
  }

  function initCanvasHiDPI(canvas, width = null, height = null, ctxOptions = null) {
    const rect = canvas.getBoundingClientRect();
    const cssW = width ?? rect.width;
    const cssH = height ?? rect.height;
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.max(1, Math.floor(cssW * dpr));
    canvas.height = Math.max(1, Math.floor(cssH * dpr));
    const ctx = canvas.getContext("2d", ctxOptions || undefined);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    return { ctx, w: cssW, h: cssH, dpr };
  }

  function hexToRgb(hex) {
    const h = String(hex || "").replace("#", "");
    if (h.length === 3) {
      return {
        r: parseInt(h[0] + h[0], 16),
        g: parseInt(h[1] + h[1], 16),
        b: parseInt(h[2] + h[2], 16)
      };
    }
    return {
      r: parseInt(h.slice(0, 2), 16),
      g: parseInt(h.slice(2, 4), 16),
      b: parseInt(h.slice(4, 6), 16)
    };
  }

  function mixHex(a, b, t) {
    const c1 = hexToRgb(a);
    const c2 = hexToRgb(b);
    const mix = (v1, v2) => Math.round(v1 + (v2 - v1) * t);
    const r = mix(c1.r, c2.r).toString(16).padStart(2, "0");
    const g = mix(c1.g, c2.g).toString(16).padStart(2, "0");
    const bch = mix(c1.b, c2.b).toString(16).padStart(2, "0");
    return `#${r}${g}${bch}`;
  }

  function debounce(fn, ms){
    let t = null;
    return (...args) => {
      clearTimeout(t);
      t = setTimeout(() => fn(...args), ms);
    };
  }

  function applyTheme(theme) {
    const next = ["bright", "soft", "dark"].includes(theme) ? theme : "soft";
    document.body.dataset.theme = next;
    if (state) {
      state.theme = next;
      saveState();
    }
    if (themeSelectEl) themeSelectEl.value = next;
  }

  function updateFocusUi() {
    if (!focusIndicatorEl) return;
    focusIndicatorEl.style.display = focusMode !== "grid" ? "flex" : "none";
    if (focusLabelEl) {
      if (focusMode === "focus" && focusedCourse) {
        focusLabelEl.textContent = `Focus: ${focusedCourse}`;
      } else if (focusMode === "hybrid" && focusedCourse) {
        focusLabelEl.textContent = `Hybrid: ${focusedCourse}`;
      } else {
        focusLabelEl.textContent = "Focus";
      }
    }
  }

  function setFocusMode(mode) {
    if (!mode || mode === focusMode) return;
    focusMode = mode;
    if (focusMode === "grid") focusedCourse = null;
    updateFocusUi();
    debouncedForest();
  }

  function setFocusCourse(course, modeOverride = null) {
    if (!course) return;
    focusedCourse = course;
    if (modeOverride) {
      focusMode = modeOverride;
    } else if (focusMode === "grid") {
      focusMode = "hybrid";
    }
    updateFocusUi();
    debouncedForest();
  }

  function exitFocusMode() {
    if (focusMode === "focus") {
      focusMode = "hybrid";
    } else if (focusMode === "hybrid") {
      focusMode = "grid";
      focusedCourse = null;
    } else {
      return;
    }
    updateFocusUi();
    debouncedForest();
  }

  function renderScaleDebug(courseName = null) {
    if (!scaleDebugEl) return;
    scaleDebugEl.style.display = scaleDebugOn ? "block" : "none";
    if (!scaleDebugOn) return;
    let stats = null;
    if (courseName && lastScaleStats[courseName]) {
      stats = lastScaleStats[courseName];
    } else if (focusedCourse && lastScaleStats[focusedCourse]) {
      stats = lastScaleStats[focusedCourse];
    } else {
      const entries = Object.values(lastScaleStats || {});
      if (entries.length) {
        stats = entries.sort((a, b) => (b.growthRel || 0) - (a.growthRel || 0))[0];
      }
    }
    if (!stats) {
      scaleDebugEl.textContent = "Scale: —";
      return;
    }
    const fmt = (v, n = 2) => (typeof v === "number" && isFinite(v)) ? v.toFixed(n) : "—";
    scaleDebugEl.innerHTML = [
      `<div><b>${stats.course || "Course"}</b></div>`,
      `<div>growthN: ${fmt(stats.growthN, 2)}</div>`,
      `<div>rel: ${fmt(stats.rel, 3)}</div>`,
      `<div>growthRel: ${fmt(stats.growthRel, 3)}</div>`,
      `<div>flatNorm: ${stats.flatNorm ? "yes" : "no"}</div>`,
      `<div>range: ${fmt(stats.normRange, 6)}</div>`,
      `<div>mode: ${stats.normMode || "relative"}</div>`,
      `<div>isSprout: ${stats.isSprout ? "yes" : "no"}</div>`,
      `<div>effortAbs: ${fmt(stats.effortAbs, 3)}</div>`,
      `<div>effortTotal: ${fmt(stats.effortTotal, 3)}</div>`,
      `<div>idleMode: ${stats.idleMode ? "yes" : "no"}</div>`,
      `<div>desiredPx: ${fmt(stats.desiredPx, 2)}</div>`,
      `<div>recDepth: ${fmt(stats.recDepth, 0)}</div>`,
      `<div>branchProb: ${fmt(stats.branchProb, 3)}</div>`,
      `<div>clusterProb: ${fmt(stats.clusterProb, 3)}</div>`,
      `<div>segments: ${fmt(stats.segmentsDrawn, 0)}</div>`,
      `<div>branchEvents: ${fmt(stats.branchEvents, 0)}</div>`,
      `<div>minRaw: ${fmt(stats.minRaw, 3)}</div>`,
      `<div>maxRaw: ${fmt(stats.maxRaw, 3)}</div>`,
      `<div>rawGrowth: ${fmt(stats.rawGrowth, 3)}</div>`,
      `<div>weekly: ${fmt(stats.weekly, 2)}</div>`,
      `<div>tasks: ${fmt(stats.tasksTerm, 2)}</div>`,
      `<div>words: ${fmt(stats.wordsTerm, 2)}</div>`,
      `<div>recursion: ${fmt(stats.recursion, 2)}</div>`,
      `<div>cohesion: ${fmt(stats.cohesion, 2)}</div>`,
      `<div>trunkBudget: ${fmt(stats.trunkBudgetSteps, 0)}</div>`,
      `<div>trunkStep: ${fmt(stats.trunkStep, 0)}</div>`,
      `<div>trunkLenMult: ${fmt(stats.trunkLenMult, 2)}</div>`,
      `<div>targetFrac: ${fmt(stats.targetFrac, 3)}</div>`,
      `<div>availH: ${fmt(stats.availH, 1)}</div>`,
      `<div>targetH: ${fmt(stats.targetH, 1)}</div>`,
      `<div>yScaleRaw: ${fmt(stats.yScaleRaw, 3)}</div>`,
      `<div>xCap: ${fmt(stats.widthCapScale, 3)}</div>`,
      `<div>xScale: ${fmt(stats.xScale, 3)} yScale: ${fmt(stats.yScale, 3)}</div>`,
      `<div>aniso: ${fmt(stats.appliedAniso, 3)}</div>`,
      `<div>widthLimited: ${stats.widthLimited ? "yes" : "no"}</div>`,
      `<div>bboxH: ${fmt(stats.bboxH, 1)}</div>`,
      `<div>scaleFinal: ${fmt(stats.scaleFinal, 3)}</div>`,
      `<div>widthCap: ${fmt(stats.widthCapScale, 3)}</div>`
    ].join("");
  }

  // ISO week id: YYYY-Www
  function isoWeekId(date = new Date()) {
    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    const dayNum = d.getUTCDay() || 7; // Mon=1..Sun=7
    d.setUTCDate(d.getUTCDate() + 4 - dayNum);
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    const y = d.getUTCFullYear();
    const w = String(weekNo).padStart(2, "0");
    return `${y}-W${w}`;
  }

  function prevIsoWeekId(currentId){
    const [yPart, wPart] = currentId.split("-W");
    const y = Number(yPart);
    const w = Number(wPart);
    const jan4 = new Date(Date.UTC(y, 0, 4));
    const dayNum = jan4.getUTCDay() || 7;
    const mondayWeek1 = new Date(jan4);
    mondayWeek1.setUTCDate(jan4.getUTCDate() - (dayNum - 1));
    const mondayTarget = new Date(mondayWeek1);
    mondayTarget.setUTCDate(mondayWeek1.getUTCDate() + (w - 1) * 7);
    mondayTarget.setUTCDate(mondayTarget.getUTCDate() - 7);
    return isoWeekId(new Date(mondayTarget.getUTCFullYear(), mondayTarget.getUTCMonth(), mondayTarget.getUTCDate()));
  }

  function isoWeekStartKey(weekId) {
    const [yPart, wPart] = String(weekId || "").split("-W");
    const y = Number(yPart);
    const w = Number(wPart);
    if (!y || !w) return "1970-01-01";
    const jan4 = new Date(Date.UTC(y, 0, 4));
    const dayNum = jan4.getUTCDay() || 7;
    const mondayWeek1 = new Date(jan4);
    mondayWeek1.setUTCDate(jan4.getUTCDate() - (dayNum - 1));
    const mondayTarget = new Date(mondayWeek1);
    mondayTarget.setUTCDate(mondayWeek1.getUTCDate() + (w - 1) * 7);
    const yyyy = mondayTarget.getUTCFullYear();
    const mm = String(mondayTarget.getUTCMonth() + 1).padStart(2, "0");
    const dd = String(mondayTarget.getUTCDate()).padStart(2, "0");
    return `${yyyy}-${mm}-${dd}`;
  }

  const WEEKLY_ROLLOVER_HOUR_ET = 5;

  function getETParts(date = new Date()) {
    const fmt = new Intl.DateTimeFormat("en-US", {
      timeZone: "America/New_York",
      weekday: "short",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      hour12: false
    });
    const parts = fmt.formatToParts(date);
    const out = {};
    parts.forEach((p) => { out[p.type] = p.value; });
    return {
      weekday: out.weekday || "",
      year: out.year || "1970",
      month: out.month || "01",
      day: out.day || "01",
      hour: Number(out.hour || 0)
    };
  }

  function etDateKey(date = new Date()) {
    const p = getETParts(date);
    return `${p.year}-${p.month}-${p.day}`;
  }

  function currentWeekId(date = new Date()) {
    const shifted = new Date(date.getTime() - WEEKLY_ROLLOVER_HOUR_ET * 3600000);
    const p = getETParts(shifted);
    return isoWeekId(new Date(Number(p.year), Number(p.month) - 1, Number(p.day)));
  }

  function isMondayAfterNoonET(date = new Date()) {
    const p = getETParts(date);
    return p.weekday === "Mon" && p.hour >= 12;
  }

  // ---------- Render helpers ----------
  function renderModeChips() {
    modeChipsEl.innerHTML = "";
    const labels = Object.keys(state.modeChecks);

    labels.forEach((label) => {
      const chip = document.createElement("label");
      chip.className = "chip";

      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.checked = !!state.modeChecks[label];
      cb.addEventListener("change", () => {
        state.modeChecks[label] = cb.checked;
        saveState();
        renderWeekSummary();
        debouncedForest(); // dynamic response to daily checkbox changes
      });

      const span = document.createElement("span");
      span.textContent = label;

      const scope = document.createElement("span");
      scope.className = "pill";
      scope.textContent = (state.modeScope?.[label] || "weekly").toUpperCase();

      const del = document.createElement("button");
      del.className = "del";
      del.textContent = "×";
      del.title = "Delete mode";
      del.addEventListener("click", (e) => {
        e.preventDefault();
        delete state.modeChecks[label];
        delete state.modeScope[label];
        saveState();
        renderModeChips();
        renderWeekSummary();
        debouncedForest();
      });

      chip.appendChild(cb);
      chip.appendChild(span);
      chip.appendChild(scope);
      chip.appendChild(del);
      modeChipsEl.appendChild(chip);
    });
  }

  function renderKeystoneDropdown() {
    keystoneTodayEl.innerHTML = "";
    state.courses.forEach((c) => {
      const opt = document.createElement("option");
      opt.value = c;
      opt.textContent = c;
      keystoneTodayEl.appendChild(opt);
    });
    keystoneTodayEl.value = state.keystoneToday || state.courses[0] || "";
  }

  function renderCourseCards() {
    courseCardsEl.innerHTML = "";
    state.courses.forEach((course) => {
      if (!state.courseNotes[course]) {
        state.courseNotes[course] = { status: "steady", focus: "", budget: "", notes: "" };
      }
      const data = state.courseNotes[course];

      const card = document.createElement("div");
      card.className = "card course-card";
      card.style.marginBottom = "10px";

      const title = document.createElement("div");
      title.className = "section-title";
      title.innerHTML = `<h2>${escapeHtml(course)}</h2><div class="hint">bounded notes + focus modes</div>`;
      card.appendChild(title);

      const row = document.createElement("div");
      row.className = "cols";

      const col1 = document.createElement("div");
      col1.innerHTML = `<label>Status</label>`;
      const status = document.createElement("select");
      ["steady","watch","hot","danger"].forEach(s => {
        const opt = document.createElement("option");
        opt.value = s;
        opt.textContent = s;
        status.appendChild(opt);
      });
      status.value = data.status || "steady";
      status.addEventListener("change", () => {
        state.courseNotes[course].status = status.value;
        saveState();
        renderWeekSummary();
        debouncedForest(); // dynamic response to stress changes
      });
      col1.appendChild(status);

      const col2 = document.createElement("div");
      col2.innerHTML = `<label>Focus (this week)</label>`;
      const focus = document.createElement("input");
      focus.type = "text";
      focus.placeholder = "e.g., AOIC quiz prep; Neuro: lecture map; Modeling: tools + first HW";
      focus.value = data.focus || "";
      focus.addEventListener("input", () => {
        state.courseNotes[course].focus = focus.value;
        saveState();
        debouncedGraph();
      });
      col2.appendChild(focus);

      const col3 = document.createElement("div");
      col3.innerHTML = `<label>Block budget</label>`;
      const budget = document.createElement("input");
      budget.type = "text";
      budget.placeholder = "e.g., 1 deep block + 2 light blocks";
      budget.value = data.budget || "";
      budget.addEventListener("input", () => {
        state.courseNotes[course].budget = budget.value;
        saveState();
        debouncedGraph();
      });
      col3.appendChild(budget);

      row.appendChild(col1); row.appendChild(col2); row.appendChild(col3);
      card.appendChild(row);

      const notesLabel = document.createElement("label");
      notesLabel.style.marginTop = "10px";
      notesLabel.textContent = "Notes (what landed / what’s fuzzy / next question)";
      card.appendChild(notesLabel);

      const weeklyBadge = document.createElement("div");
      weeklyBadge.className = "mini";
      weeklyBadge.style.marginTop = "6px";
      card.appendChild(weeklyBadge);

      const notes = document.createElement("textarea");
      notes.value = data.notes || "";
      notes.placeholder = "Keep it short. Capture confusion early.";
      notes.addEventListener("input", () => {
        state.courseNotes[course].notes = notes.value;
        updateWeeklySession(course, notes.value);
        saveState();
        const weekId = currentWeekId();
        const weekly = weeklyScoreForCourse(course, weekId);
        const todayKey = etDateKey();
        const dayScore = (state.forest.weekly?.courses?.[course]?.days?.[todayKey] || 0);
        weeklyBadge.textContent = `Weekly sessions: ${weekly.sessions}/6 • Today: ${(dayScore * 100).toFixed(0)}%`;
        debouncedForest(); // update forest as you write
        debouncedGraph();
      });
      card.appendChild(notes);

      const weekId = currentWeekId();
      const weekly = weeklyScoreForCourse(course, weekId);
      const todayKey = etDateKey();
      const dayScore = (state.forest.weekly?.courses?.[course]?.days?.[todayKey] || 0);
      weeklyBadge.textContent = `Weekly sessions: ${weekly.sessions}/6 • Today: ${(dayScore * 100).toFixed(0)}%`;

    courseCardsEl.appendChild(card);
  });
  saveState();
  renderWeekSummary();
  setupCardToggles();
}

  function taskRow(task, listName) {
    const row = document.createElement("div");
    row.className = "task" + (task.done ? " done" : "");

    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.checked = !!task.done;
    cb.addEventListener("change", () => {
      task.done = cb.checked;
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest(); // dynamic response to task completion changes
    });

    const title = document.createElement("input");
    title.type = "text";
    title.className = "title";
    title.value = task.title || "";
    title.placeholder = "Task (bounded, concrete)";
    title.addEventListener("input", () => {
      task.title = title.value;
      saveState();
      debouncedForest();
    });

    title.addEventListener("blur", () => {
      if (!String(task.title || "").trim()) toast("Task title is empty (export will mark as untitled).");
    });

    const course = document.createElement("select");
    state.courses.forEach((c) => {
      const opt = document.createElement("option");
      opt.value = c;
      opt.textContent = c;
      course.appendChild(opt);
    });
    course.value = task.course || state.courses[0];
    course.addEventListener("change", () => {
      task.course = course.value;
      saveState();
      renderWeekSummary();
      debouncedForest();
    });

    const mode = document.createElement("select");
    const modes = Object.keys(state.modeChecks);
    ["(mode)", ...modes].forEach((m) => {
      const opt = document.createElement("option");
      opt.value = m;
      opt.textContent = m;
      mode.appendChild(opt);
    });
    mode.value = task.mode || "(mode)";
    mode.addEventListener("change", () => {
      task.mode = mode.value;
      saveState();
      debouncedForest();
    });

    const del = document.createElement("button");
    del.className = "del";
    del.textContent = "×";
    del.title = "Delete";
    del.addEventListener("click", () => {
      state[listName] = state[listName].filter((t) => t.id !== task.id);
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
    });

    row.appendChild(cb);
    row.appendChild(title);
    row.appendChild(course);
    row.appendChild(mode);
    row.appendChild(del);
    return row;
  }

  function renderTasks() {
    todayTasksEl.innerHTML = "";
    state.todayTasks.forEach((t) => todayTasksEl.appendChild(taskRow(t, "todayTasks")));

    weekendTasksEl.innerHTML = "";
    state.weekendTasks.forEach((t) => weekendTasksEl.appendChild(taskRow(t, "weekendTasks")));
  }

  // ---------- Card focus ----------
  let expandedCard = null;

  function setCardFocus(card, active) {
    const cards = Array.from(document.querySelectorAll(".card"));
    const containerCard = card?.parentElement?.closest(".card");
    if (active) {
      expandedCard = card;
      document.body.classList.add("card-focus");
      cards.forEach((c) => {
        const keepClear = c === card || c === containerCard;
        c.classList.toggle("expanded", c === card);
        c.classList.toggle("dimmed", !keepClear);
      });
      const btn = card.querySelector(".card-toggle");
      if (btn) btn.textContent = "Collapse";
    } else {
      expandedCard = null;
      document.body.classList.remove("card-focus");
      cards.forEach((c) => c.classList.remove("expanded", "dimmed"));
      cards.forEach((c) => {
        const btn = c.querySelector(".card-toggle");
        if (btn) btn.textContent = "Focus";
      });
    }
  }

  function setupCardToggles() {
    const cards = document.querySelectorAll(".card");
    cards.forEach((card) => {
      if (card.querySelector(".card-toggle")) return;
      const btn = document.createElement("button");
      btn.className = "card-toggle";
      btn.type = "button";
      btn.textContent = "Focus";
      btn.addEventListener("click", (e) => {
        e.preventDefault();
        const isActive = card.classList.contains("expanded");
        setCardFocus(card, !isActive);
      });
      card.appendChild(btn);
    });
  }

  // ---------- Concept graph ----------
  let graphState = null;
  let graphSpacing = 4.5;

  function collectWritingCorpus() {
    const parts = [];
    if (state.todayNotes) parts.push(state.todayNotes);
    state.courses.forEach((course) => {
      const c = state.courseNotes[course] || {};
      if (c.focus) parts.push(c.focus);
      if (c.budget) parts.push(c.budget);
      if (c.notes) parts.push(c.notes);
    });
    if (state.writingSchedule) parts.push(state.writingSchedule);
    if (state.writingThread) parts.push(state.writingThread);
    if (state.writingTargets) parts.push(state.writingTargets);
    if (state.writingNotes) parts.push(state.writingNotes);
    if (state.proseSchedule) parts.push(state.proseSchedule);
    if (state.proseProject) parts.push(state.proseProject);
    if (state.proseTargets) parts.push(state.proseTargets);
    if (state.proseNotes) parts.push(state.proseNotes);
    return normalizeText(parts.join(" "));
  }

  function computeConceptGraph() {
    const corpus = collectWritingCorpus();
    if (!corpus) return { nodes: [], edges: [] };
    const keywords = topNWords(corpus, 16).map(x => x.w);
    const nodes = keywords.map((w) => ({
      id: w,
      label: w,
      x: (Math.random() - 0.5) * graphSpacing,
      y: (Math.random() - 0.5) * graphSpacing,
      z: (Math.random() - 0.5) * graphSpacing,
      size: 2
    }));
    const edges = [];
    const sentences = splitSentences(corpus);
    const keywordSet = new Set(keywords);
    const edgeMap = new Map();

    sentences.forEach((sentence) => {
      const words = contentWords(sentence);
      const present = Array.from(new Set(words.filter((w) => keywordSet.has(w))));
      for (let i = 0; i < present.length; i++) {
        for (let j = i + 1; j < present.length; j++) {
          const key = [present[i], present[j]].sort().join("|");
          edgeMap.set(key, (edgeMap.get(key) || 0) + 1);
        }
      }
    });

    const degree = new Map();
    for (const [pair, weight] of edgeMap.entries()) {
      const [a, b] = pair.split("|");
      edges.push({ a, b, weight });
      degree.set(a, (degree.get(a) || 0) + weight);
      degree.set(b, (degree.get(b) || 0) + weight);
    }

    nodes.forEach((node) => {
      node.size = 2;
    });

    return { nodes, edges };
  }

  function projectPoint(node, rotX, rotY, zoom, w, h) {
    let { x, y, z } = node;
    const cosY = Math.cos(rotY);
    const sinY = Math.sin(rotY);
    const cosX = Math.cos(rotX);
    const sinX = Math.sin(rotX);

    const dx = x * cosY - z * sinY;
    const dz = x * sinY + z * cosY;
    const dy = y * cosX - dz * sinX;
    const dz2 = y * sinX + dz * cosX;

    const perspective = zoom / (zoom + dz2 + 2.2);
    return {
      x: w / 2 + dx * w * 0.25 * perspective,
      y: h / 2 + dy * h * 0.25 * perspective,
      scale: perspective
    };
  }

  function renderConceptGraph() {
    if (!conceptGraphCanvas) return;
    if (!graphState) {
      graphState = {
        data: computeConceptGraph(),
        rotX: -0.25,
        rotY: 0.25,
        zoom: 2.4,
        dragging: false,
        lastX: 0,
        lastY: 0
      };
      attachGraphHandlers();
      requestAnimationFrame(drawConceptGraph);
    } else {
      graphState.data = computeConceptGraph();
    }
  }

  function drawConceptGraphFrame() {
    if (!conceptGraphCanvas || !graphState) return;
    const { ctx, w, h } = initCanvasHiDPI(conceptGraphCanvas);
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = getCSSVar("--panel");
    ctx.fillRect(0, 0, w, h);

    const { nodes, edges } = graphState.data;
    if (!nodes.length) {
      ctx.fillStyle = "#8b8c9b";
      ctx.font = "12px " + getCSSVar("--sans");
      ctx.textAlign = "center";
      ctx.fillText("No writing data yet to generate concepts.", w / 2, h / 2);
      return;
    }

    const projections = new Map();
    nodes.forEach((node) => {
      projections.set(node.id, projectPoint(node, graphState.rotX, graphState.rotY, graphState.zoom, w, h));
    });

    ctx.strokeStyle = "rgba(58,61,94,0.25)";
    edges.forEach((edge) => {
      const a = projections.get(edge.a);
      const b = projections.get(edge.b);
      if (!a || !b) return;
      ctx.lineWidth = Math.max(0.6, edge.weight * 0.6);
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();
    });

    nodes.forEach((node) => {
      const p = projections.get(node.id);
      if (!p) return;
      const radius = node.size * p.scale;
      ctx.fillStyle = "#111111";
      ctx.beginPath();
      ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#111111";
      ctx.font = `${Math.max(9, 10 * p.scale)}px ${getCSSVar("--sans")}`;
      ctx.textAlign = "center";
      ctx.fillText(node.label, p.x, p.y - radius - 4);
    });
  }

  function attachGraphHandlers() {
    conceptGraphCanvas.addEventListener("mousedown", (e) => {
      graphState.dragging = true;
      graphState.lastX = e.clientX;
      graphState.lastY = e.clientY;
    });
    window.addEventListener("mouseup", () => {
      if (graphState) graphState.dragging = false;
    });
    window.addEventListener("mousemove", (e) => {
      if (!graphState?.dragging) return;
      const dx = e.clientX - graphState.lastX;
      const dy = e.clientY - graphState.lastY;
      graphState.rotY += dx * 0.005;
      graphState.rotX += dy * 0.005;
      graphState.lastX = e.clientX;
      graphState.lastY = e.clientY;
    });
    conceptGraphCanvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      graphState.zoom = clamp(graphState.zoom + e.deltaY * 0.004, 1.0, 10);
    }, { passive: false });
    btnRegenGraph?.addEventListener("click", () => {
      graphState.data = computeConceptGraph();
      toast("Regenerated concept graph");
    });
    graphSpacingEl?.addEventListener("input", () => {
      graphSpacing = Number(graphSpacingEl.value) || 1.6;
      graphState.data = computeConceptGraph();
    });
  }

  function drawConceptGraph() {
    if (!conceptGraphCanvas || !graphState) return;
    drawConceptGraphFrame();
    graphState.rotY += 0.0015;
    requestAnimationFrame(drawConceptGraph);
  }

  // ---------- Week summary ----------
  function renderWeekSummary() {
    const openToday = state.todayTasks.filter(t => !t.done).length;
    const openWeekend = state.weekendTasks.filter(t => !t.done).length;
    const doneToday = state.todayTasks.filter(t => t.done).length;
    const doneWeekend = state.weekendTasks.filter(t => t.done).length;

    const flagged = state.courses
      .map(c => ({ course: c, status: (state.courseNotes[c] || {}).status || "steady" }))
      .filter(x => x.status === "hot" || x.status === "danger");

    const keystone = state.keystoneToday || "";
    const keystoneOpen = state.todayTasks.filter(t => !t.done && t.course === keystone).length;

    const dailyTotal = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="daily").length || 1;
    const weeklyTotal = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="weekly").length || 1;

    const dailyChecked = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="daily" && state.modeChecks[k]).length;
    const weeklyChecked = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="weekly" && state.modeChecks[k]).length;

    const lines = [];
    lines.push(`Open tasks: <b>${openToday + openWeekend}</b> (Today ${openToday}, Weekend ${openWeekend})`);
    lines.push(`Completed tasks: ${doneToday + doneWeekend} (Today ${doneToday}, Weekend ${doneWeekend})`);
    lines.push(`Keystone: <b>${escapeHtml(keystone)}</b> — open today tasks in keystone: <b>${keystoneOpen}</b>`);
    lines.push(`Modes checked: daily ${dailyChecked}/${dailyTotal} • weekly ${weeklyChecked}/${weeklyTotal}`);

    if (flagged.length) {
      const list = flagged.map(x => `${escapeHtml(x.course)}: <code>${escapeHtml(x.status)}</code>`).join(" • ");
      lines.push(`Flagged courses: <b>${flagged.length}</b> — ${list}`);
    } else {
      lines.push(`Flagged courses: 0`);
    }

    weekSummaryEl.innerHTML = `<div style="display:grid;gap:6px;">${lines.map(x => `<div>${x}</div>`).join("")}</div>`;
    debouncedForest();
  }

  // ---------- Markdown generation ----------
  function mdCheckbox(label, checked) {
    return `- [${checked ? "x" : " "}] ${label}`;
  }

  function obsidianLink(name) {
    const safe = String(name || "").replaceAll("]","\\]");
    return `[[${safe}]]`;
  }

  function slugTag(word) {
    return String(word || "")
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/^-+|-+$/g, "");
  }

  const KEYWORD_SKIP = new Set([
    "make","made","making","made","need","needs","needed","want","wants","wanted",
    "good","better","best","bad","worse","worst","thing","things","stuff","like",
    "use","used","using","get","got","getting","should","could","would","might"
  ]);

  function titleCase(word) {
    const s = String(word || "");
    return s ? s[0].toUpperCase() + s.slice(1) : "";
  }

  function keyPhrases(text, n = 6) {
    const sentences = splitSentences(text);
    const freq = new Map();
    sentences.forEach((sentence) => {
      const words = contentWords(sentence);
      for (let i = 0; i < words.length; i++) {
        for (let size = 2; size <= 4; size++) {
          const slice = words.slice(i, i + size);
          if (slice.length < size) continue;
          const phrase = slice.join(" ");
          if (KEYWORD_SKIP.has(phrase)) continue;
          freq.set(phrase, (freq.get(phrase) || 0) + 1);
        }
      }
    });
    return Array.from(freq.entries())
      .sort((a, b) => b[1] - a[1])
      .map(([phrase]) => phrase)
      .slice(0, n);
  }

  function extractAcademicAnchors(text) {
    const anchors = [
      "1900s",
      "20th century",
      "continental philosophy",
      "structuralist mathematics",
      "theoretical biology",
      "set theory",
      "computation theory",
      "neurophysiology",
      "neuroecology",
      "systems theory",
      "phenomenology",
      "network epistemology",
      "cybernetics",
      "semiotics",
      "complex systems",
      "systems neuroscience",
      "information theory"
    ];
    const lower = String(text || "").toLowerCase();
    const hits = anchors.filter(a => lower.includes(a));
    return hits.map((t) => `#${slugTag(t)}`);
  }

  function tokenizeWords(text) {
    const norm = normalizeText(text);
    if (!norm) return [];
    return norm.split(/\s+/).filter(Boolean).filter(w => !STOP.has(w));
  }

  function extractSentences(text) {
    return splitSentences(text);
  }

  function sentenceScore(sentence, keywords) {
    const words = contentWords(sentence);
    if (!words.length) return 0;
    const lenScore = clamp(words.length / 20, 0, 1);
    let keyHits = 0;
    const lower = sentence.toLowerCase();
    keywords.forEach((k) => { if (lower.includes(k.toLowerCase())) keyHits += 1; });
    const keyScore = keywords.length ? clamp(keyHits / keywords.length, 0, 1) : 0;
    const structureScore = /[;:]/.test(sentence) ? 0.15 : 0;
    return lenScore + keyScore + structureScore;
  }

  function extractConceptSentences(text, n = 3) {
    const sentences = extractSentences(text);
    if (!sentences.length) return [];
    const keywords = topNWords(normalizeText(text), 8).map(x => x.w);
    const scored = sentences.map(s => ({ s, score: sentenceScore(s, keywords) }));
    return scored.sort((a, b) => b.score - a.score).map(x => x.s).slice(0, n);
  }

  function titleFromSentence(sentence) {
    const words = contentWords(sentence).slice(0, 6).map(titleCase);
    return words.length ? words.join(" ") : "Untitled Note";
  }

  function buildNoteAnalysis(noteText) {
    const concepts = extractConceptSentences(noteText, 3).map((s) => {
      const trimmed = s.trim();
      return trimmed.length > 160 ? `${trimmed.slice(0, 157)}…` : trimmed;
    });
    const title = concepts.length ? titleFromSentence(concepts[0]) : "Untitled Note";
    const anchors = [
      ...new Set([
        ...formatProperNounTags(noteText),
        ...extractAcademicAnchors(noteText)
      ])
    ];
    return { title, concepts, anchors };
  }

  function noteKeywords(text, n = 6) {
    return keyPhrases(text, n);
  }

  function titleCasePhrase(phrase) {
    return phrase.split(" ").map(titleCase).join(" ");
  }

  function noteTitleFromKeywords(keywords) {
    if (!keywords.length) return "Untitled Note";
    return keywords.slice(0, 2).map(titleCasePhrase).join(" · ");
  }

  function extractProperNouns(text, n = 6) {
    const raw = String(text || "");
    const matches = raw.match(/\b(?:[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\b/g) || [];
    const extras = raw.match(/\b\d{1,2}(?:st|nd|rd|th)\s+century\b/gi) || [];
    const seen = new Set();
    const out = [];
    [...matches, ...extras].forEach((m) => {
      const cleaned = m.trim();
      if (!cleaned || cleaned.length < 3) return;
      if (STOP.has(cleaned.toLowerCase())) return;
      const key = cleaned.toLowerCase();
      if (!seen.has(key)) {
        seen.add(key);
        out.push(cleaned);
      }
    });
    return out.slice(0, n);
  }

  function formatProperNounTags(text) {
    return extractProperNouns(text, 8)
      .map((name) => slugTag(name))
      .filter(Boolean)
      .map((tag) => `#${tag}`);
  }

  function percent(n) {
    return `${Math.round(n * 100)}%`;
  }

  function forestPngDataUrl(scale = 1, mime = "image/jpeg", quality = 0.92) {
    try {
      renderForest();
      const src = forestCanvas;
      if (!src) return "";
      const rect = src.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width));
      const h = Math.max(1, Math.floor(rect.height));
      const tmp = document.createElement("canvas");
      tmp.width = Math.floor(w * scale);
      tmp.height = Math.floor(h * scale);
      const tctx = tmp.getContext("2d");
      tctx.fillStyle = "#ffffff";
      tctx.fillRect(0, 0, tmp.width, tmp.height);
      tctx.drawImage(src, 0, 0, src.width, src.height, 0, 0, tmp.width, tmp.height);
      return mime === "image/png" ? tmp.toDataURL(mime) : tmp.toDataURL(mime, quality);
    } catch {
      return "";
    }
  }

  function conceptGraphPngDataUrl(scale = 1, mime = "image/jpeg", quality = 0.92) {
    try {
      if (!conceptGraphCanvas) return "";
      renderConceptGraph();
      if (graphState) drawConceptGraphFrame();
      const src = conceptGraphCanvas;
      const rect = src.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width));
      const h = Math.max(1, Math.floor(rect.height));
      const tmp = document.createElement("canvas");
      tmp.width = Math.floor(w * scale);
      tmp.height = Math.floor(h * scale);
      const tctx = tmp.getContext("2d");
      tctx.fillStyle = "#ffffff";
      tctx.fillRect(0, 0, tmp.width, tmp.height);
      tctx.drawImage(src, 0, 0, src.width, src.height, 0, 0, tmp.width, tmp.height);
      return mime === "image/png" ? tmp.toDataURL(mime) : tmp.toDataURL(mime, quality);
    } catch {
      return "";
    }
  }

  function wrapTextLines(ctx, text, maxWidth) {
    const words = String(text || "").split(/\s+/);
    const lines = [];
    let line = "";
    words.forEach((word) => {
      const next = line ? `${line} ${word}` : word;
      if (ctx.measureText(next).width > maxWidth && line) {
        lines.push(line);
        line = word;
      } else {
        line = next;
      }
    });
    if (line) lines.push(line);
    return lines;
  }

  function buildLegendGridRows(perCourse, courses, weekId) {
    return courses.map((course) => {
      const m = perCourse[course] || {};
      const notes = state.courseNotes?.[course]?.notes || "";
      const words = m.words || wordCount(notes);
      const recursion = Math.round((m.recursion || 0) * 100);
      const abstraction = Math.round((m.abstraction || 0) * 100);
      const cohesion = Math.round((m.cohesion || 0) * 100);
      const argument = Math.round((m.argument || 0) * 100);
      const diversityN = Math.round((m.diversity || 0) * 100);
      const keywordCount = courseKeywords(course).size;
      const phraseCount = keyPhrases(notes, 8).length;
      const conceptN = clamp((keywordCount / 12 + phraseCount / 6 + (m.cohesion || 0)) / 3, 0, 1);
      const stress = m.stress || 0;
      const tasks = m.tasks || 0;
      const weekly = weeklyScoreForCourse(course, weekId);
      const status = (state.courseNotes?.[course]?.status || "steady");
      return {
        title: `${course} (${status})`,
        lines: [
          `Words ${words} • Recursion ${recursion}% • Abstraction ${abstraction}%`,
          `Cohesion ${cohesion}% • Argument ${argument}% • Diversity ${diversityN}%`,
          `Concepts ${keywordCount} • Phrases ${phraseCount} • Linkage ${(conceptN * 100).toFixed(1)}%`,
          `Tasks ${tasks} • Stress ${(stress * 100).toFixed(1)}%`,
          `Weekly ${weekly.sessions}/6 • Score ${(weekly.score * 100).toFixed(1)}%`
        ]
      };
    });
  }

  function renderForestLegend(perCourse, courseList, weekId) {
    if (!forestLegendEl) return;
    const rows = buildLegendGridRows(perCourse, courseList, weekId);
    const html = rows.map((row) => {
      const lines = row.lines.map(line => `<div>${line}</div>`).join("");
      return `
        <div style="display:grid;gap:4px;padding:8px;border:1px solid var(--line);border-radius:10px;background:var(--panel2);color:var(--text);">
          <div><b>${escapeHtml(row.title)}</b></div>
          ${lines}
        </div>
      `;
    }).join("");

    forestLegendEl.innerHTML = `
      <div style="display:grid;gap:8px;">
        <div><b>Tree Analysis Legend</b> — per-course signals driving structure</div>
        <div style="display:grid;gap:10px;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));">
          ${html || "<div>No courses yet.</div>"}
        </div>
      </div>
    `;
  }

  function forestCardDataUrl(mime = "image/jpeg", quality = 0.92, scale = 1) {
    try {
      renderForest();
      const src = forestCanvas;
      if (!src) return "";
      const rect = src.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width));
      const h = Math.max(1, Math.floor(rect.height));
      const { perCourse, weekId } = computeForestMetrics();
      const rows = buildLegendGridRows(perCourse, state.courses || [], weekId);
      const cols = w > 960 ? 3 : (w > 640 ? 2 : 1);
      const cellW = Math.floor(w / cols);
      const lineH = 14;
      const cellPad = 10;
      const cellHeight = 6 * lineH + 20;
      const legendRows = Math.max(1, Math.ceil(rows.length / cols));
      const legendHeight = legendRows * cellHeight + cellPad;
      const totalH = h + legendHeight;

      const tmp = document.createElement("canvas");
      tmp.width = Math.max(1, Math.floor(w * scale));
      tmp.height = Math.max(1, Math.floor(totalH * scale));
      const ctx = tmp.getContext("2d");
      ctx.scale(scale, scale);
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, w, totalH);
      ctx.drawImage(src, 0, 0, src.width, src.height, 0, 0, w, h);

      ctx.fillStyle = "#111111";
      ctx.font = `12px ${getCSSVar("--sans")}`;
      const startY = h + cellPad;
      const maxTextWidth = (cellW - cellPad * 2) * scale;
      rows.forEach((row, idx) => {
        const col = idx % cols;
        const r = Math.floor(idx / cols);
        const x = col * cellW + cellPad;
        const y = startY + r * cellHeight;
        ctx.font = `12px ${getCSSVar("--sans")}`;
        ctx.fillText(row.title, x, y + 12);
        ctx.font = `11px ${getCSSVar("--sans")}`;
        row.lines.forEach((line, i) => {
          const lines = wrapTextLines(ctx, line, maxTextWidth);
          lines.forEach((l, li) => {
            const yy = y + 28 + (i * lineH) + (li * lineH);
            if (yy < y + cellHeight - 4) ctx.fillText(l, x, yy);
          });
        });
      });
      return mime === "image/png" ? tmp.toDataURL(mime) : tmp.toDataURL(mime, quality);
    } catch {
      return "";
    }
  }

  function formatDelta(delta) {
    const pct = Math.round(delta * 100);
    if (!pct) return "0%";
    return `${pct > 0 ? "+" : ""}${pct}%`;
  }

  function crc32(buf) {
    const table = crc32.table || (crc32.table = (() => {
      const t = new Uint32Array(256);
      for (let i = 0; i < 256; i++) {
        let c = i;
        for (let k = 0; k < 8; k++) {
          c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
        }
        t[i] = c >>> 0;
      }
      return t;
    })());
    let crc = 0xFFFFFFFF;
    for (let i = 0; i < buf.length; i++) {
      crc = table[(crc ^ buf[i]) & 0xFF] ^ (crc >>> 8);
    }
    return (crc ^ 0xFFFFFFFF) >>> 0;
  }

  function textToUint8(text) {
    return new TextEncoder().encode(text);
  }

  function dataUrlToUint8(dataUrl) {
    const [meta, data] = dataUrl.split(",");
    const isBase64 = meta.includes(";base64");
    if (!isBase64) return textToUint8(decodeURIComponent(data));
    const bin = atob(data);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
    return arr;
  }

  function zipFiles(files) {
    const records = [];
    let offset = 0;

    files.forEach((file) => {
      const nameBytes = textToUint8(file.name);
      const data = file.data;
      const crc = crc32(data);
      const localHeader = new Uint8Array(30 + nameBytes.length);
      const view = new DataView(localHeader.buffer);
      view.setUint32(0, 0x04034b50, true);
      view.setUint16(4, 20, true);
      view.setUint16(6, 0, true);
      view.setUint16(8, 0, true);
      view.setUint16(10, 0, true);
      view.setUint16(12, 0, true);
      view.setUint32(14, crc, true);
      view.setUint32(18, data.length, true);
      view.setUint32(22, data.length, true);
      view.setUint16(26, nameBytes.length, true);
      view.setUint16(28, 0, true);
      localHeader.set(nameBytes, 30);

      const centralHeader = new Uint8Array(46 + nameBytes.length);
      const cview = new DataView(centralHeader.buffer);
      cview.setUint32(0, 0x02014b50, true);
      cview.setUint16(4, 20, true);
      cview.setUint16(6, 20, true);
      cview.setUint16(8, 0, true);
      cview.setUint16(10, 0, true);
      cview.setUint16(12, 0, true);
      cview.setUint16(14, 0, true);
      cview.setUint32(16, crc, true);
      cview.setUint32(20, data.length, true);
      cview.setUint32(24, data.length, true);
      cview.setUint16(28, nameBytes.length, true);
      cview.setUint16(30, 0, true);
      cview.setUint16(32, 0, true);
      cview.setUint16(34, 0, true);
      cview.setUint16(36, 0, true);
      cview.setUint32(38, 0, true);
      cview.setUint32(42, offset, true);
      centralHeader.set(nameBytes, 46);

      records.push({ localHeader, data, centralHeader });
      offset += localHeader.length + data.length;
    });

    const centralSize = records.reduce((sum, r) => sum + r.centralHeader.length, 0);
    const end = new Uint8Array(22);
    const endView = new DataView(end.buffer);
    endView.setUint32(0, 0x06054b50, true);
    endView.setUint16(4, 0, true);
    endView.setUint16(6, 0, true);
    endView.setUint16(8, records.length, true);
    endView.setUint16(10, records.length, true);
    endView.setUint32(12, centralSize, true);
    endView.setUint32(16, offset, true);
    endView.setUint16(20, 0, true);

    const totalSize = offset + centralSize + end.length;
    const out = new Uint8Array(totalSize);
    let ptr = 0;
    records.forEach((r) => {
      out.set(r.localHeader, ptr);
      ptr += r.localHeader.length;
      out.set(r.data, ptr);
      ptr += r.data.length;
    });
    records.forEach((r) => {
      out.set(r.centralHeader, ptr);
      ptr += r.centralHeader.length;
    });
    out.set(end, ptr);
    return out;
  }

  function downloadBlob(filename, blob) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function downloadText(filename, text, mime = "text/plain") {
    const blob = new Blob([text], { type: mime });
    downloadBlob(filename, blob);
  }

  function downloadDataUrl(filename, dataUrl) {
    const a = document.createElement("a");
    a.href = dataUrl;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  async function writeFileToDir(dirHandle, name, blob) {
    const fileHandle = await dirHandle.getFileHandle(name, { create: true });
    const writable = await fileHandle.createWritable();
    await writable.write(blob);
    await writable.close();
  }

  async function saveArchiveToVault() {
    if (!window.isSecureContext || !window.showDirectoryPicker) {
      toast("Vault save requires Chrome/Edge on https or localhost");
      return;
    }
    try {
      const d = new Date();
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const dd = String(d.getDate()).padStart(2, "0");
      const folderName = `Dashboard_${yyyy}-${mm}-${dd}`;

      const md = state.mdCache || generateMarkdown({ forestFilename: "forest.jpg", graphFilename: "concept_graph.jpg" });
      setMdPreview(md);

      const forestUrl = forestCardDataUrl("image/jpeg", 0.92, state.forest.hiResPng ? 2 : 1);
      const graphUrl = conceptGraphPngDataUrl(1, "image/jpeg", 0.92);

      const dirHandle = await window.showDirectoryPicker({ id: "umo-vault", mode: "readwrite" });
      const dashDir = await dirHandle.getDirectoryHandle(folderName, { create: true });

      await writeFileToDir(dashDir, `Dashboard_${yyyy}-${mm}-${dd}.md`, new Blob([md], { type: "text/markdown" }));

      if (forestUrl) {
        const forestBytes = dataUrlToUint8(forestUrl);
        await writeFileToDir(dashDir, "forest.jpg", new Blob([forestBytes], { type: "image/jpeg" }));
      }
      if (graphUrl) {
        const graphBytes = dataUrlToUint8(graphUrl);
        await writeFileToDir(dashDir, "concept_graph.jpg", new Blob([graphBytes], { type: "image/jpeg" }));
      }

      toast("Saved to vault");
    } catch (err) {
      if (err && err.name === "AbortError") return;
      toast("Vault save failed");
    }
  }

  function forestToSVG(geom) {
    if (!geom) return "";
    const w = Math.max(1, Math.round(geom.width || 1));
    const h = Math.max(1, Math.round(geom.height || 1));
    const parts = [
      `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">`,
      `<rect width="100%" height="100%" fill="white"/>`
    ];

    geom.trees.forEach((tree) => {
      tree.paths.forEach((p) => {
        if (p.type === "circle") {
          const stroke = p.stroke || "#3a3d5e";
          const sw = p.sw || 1;
          const fill = p.fill || "none";
          const alpha = p.alpha ?? 1;
          parts.push(
            `<circle cx="${p.cx}" cy="${p.cy}" r="${p.r}" stroke="${stroke}" stroke-width="${sw}" fill="${fill}" opacity="${alpha}"/>`
          );
        } else if (p.d) {
          const stroke = p.stroke || "#3a3d5e";
          const sw = p.sw || 1;
          const alpha = p.alpha ?? 1;
          parts.push(
            `<path d="${p.d}" stroke="${stroke}" stroke-width="${sw}" fill="none" opacity="${alpha}"/>`
          );
        } else if (typeof p.x1 === "number") {
          const stroke = p.stroke || "#3a3d5e";
          const sw = p.sw || 1;
          const alpha = p.alpha ?? 1;
          parts.push(
            `<line x1="${p.x1}" y1="${p.y1}" x2="${p.x2}" y2="${p.y2}" stroke="${stroke}" stroke-width="${sw}" opacity="${alpha}"/>`
          );
        }
      });
    });

    parts.push("</svg>");
    return parts.join("");
  }

  function wordCount(text) {
    return String(text || "").trim().split(/\s+/).filter(Boolean).length;
  }

  function enforceWordCount(text, target) {
    let words = String(text || "").trim().split(/\s+/).filter(Boolean);
    const filler = [
      "The argument would benefit from clearer operational definitions and a sharper distinction between descriptive claims and interpretive stakes.",
      "Methodologically, a tighter articulation of evidence warrants would strengthen the transition from observation to inference.",
      "The conceptual framing aligns with literature on knowledge-building communities and warrants further triangulation with empirical traces.",
      "I encourage foregrounding how the analytic lens translates into concrete revision decisions for the next iteration."
    ];
    let i = 0;
    while (words.length < target) {
      words = words.concat(filler[i % filler.length].split(/\s+/));
      i += 1;
    }
    if (words.length > target) words = words.slice(0, target);
    return words.join(" ");
  }

  const RESPONDENT_CANON = [
    "Alain Badiou", "Joan Copjec", "Slavoj Zizek", "Alexander Galloway",
    "Sarah Pourciau", "Anil Bawa Cavvia", "Leif Weatherby", "Reza Negarestani",
    "Luciana Parisi", "Gualtieri Piccinini", "Katherine Hayles", "Mary Tiles",
    "Jose Ferreiros", "Denise Ferreira da Silva", "Fermin Fulda",
    "Stewart A. Newman", "Michael Heinrich", "Bruce Fink", "Bracha Ettinger"
  ];

  function bestSentenceFromText(text) {
    const sentences = extractConceptSentences(text, 1);
    return sentences[0] || "";
  }

  function summaryCorpusFromState() {
    const parts = [];
    if (state.todayNotes) parts.push(`Today notes: ${state.todayNotes}`);
    state.courses.forEach((course) => {
      const c = state.courseNotes?.[course] || {};
      if (c.focus) parts.push(`${course} focus: ${c.focus}`);
      if (c.notes) parts.push(`${course} notes: ${c.notes}`);
    });
    if (state.writingThread) parts.push(`GCAS thread: ${state.writingThread}`);
    if (state.writingNotes) parts.push(`GCAS notes: ${state.writingNotes}`);
    if (state.proseProject) parts.push(`Prose project: ${state.proseProject}`);
    if (state.proseNotes) parts.push(`Prose notes: ${state.proseNotes}`);
    return parts.join("\n");
  }

  async function callOpenAI(messages, temperature = 0.5) {
    const key = (state.llmKey || "").trim();
    if (!key) throw new Error("Missing OpenAI API key");
    const res = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${key}`
      },
      body: JSON.stringify({
        model: "gpt-4o-mini",
        temperature,
        messages
      })
    });
    if (!res.ok) {
      const err = await res.json().catch(() => ({}));
      throw new Error(err?.error?.message || `OpenAI error ${res.status}`);
    }
    const data = await res.json();
    return (data.choices?.[0]?.message?.content || "").trim();
  }
  function extractFirstUrl(text) {
    const match = String(text || "").match(/https?:\/\/[^\s\)\]]+/i);
    return match ? match[0].replace(/[\]\)\.,]+$/, "") : "";
  }

  function extractFirstDoi(text) {
    const match = String(text || "").match(/\b10\.\d{4,9}\/[\w.()\-;/:]+/i);
    return match ? match[0] : "";
  }

  const NOTE_GLOSSARY = [
    {
      keys: ["membrane", "potential"],
      concept: "Ion channels",
      gloss: "Ion channels are selective pore-forming proteins that regulate ion flow and thus shape membrane potential dynamics.",
      resource: "https://www.ncbi.nlm.nih.gov/books/"
    },
    {
      keys: ["action", "potential"],
      concept: "Voltage-gated channels",
      gloss: "Voltage-gated channels open or close in response to membrane voltage, enabling rapid spike initiation and propagation.",
      resource: "https://www.ncbi.nlm.nih.gov/books/"
    },
    {
      keys: ["synapse", "synaptic"],
      concept: "Neurotransmitter release",
      gloss: "Release couples presynaptic calcium influx to vesicle fusion, converting electrical signals into chemical transmission.",
      resource: "https://www.ncbi.nlm.nih.gov/books/"
    },
    {
      keys: ["model", "modeling", "system"],
      concept: "Model validation",
      gloss: "Validation tests whether a model reproduces key behaviors and predictions against data, not just fit quality.",
      resource: "https://www.ncbi.nlm.nih.gov/books/"
    },
    {
      keys: ["calculus", "integral", "derivative"],
      concept: "Fundamental Theorem of Calculus",
      gloss: "The theorem links derivatives and integrals, showing accumulation and rate of change are inverse processes.",
      resource: "https://www.khanacademy.org/"
    },
    {
      keys: ["probability", "random", "stochastic"],
      concept: "Random variables",
      gloss: "Random variables formalize uncertainty by mapping outcomes to numerical values with a defined distribution.",
      resource: "https://www.khanacademy.org/"
    }
  ];

  function glossForNote(noteText) {
    const lower = String(noteText || "").toLowerCase();
    let best = null;
    let bestScore = 0;
    NOTE_GLOSSARY.forEach((entry) => {
      const score = entry.keys.reduce((sum, k) => sum + (lower.includes(k) ? 1 : 0), 0);
      if (score > bestScore) {
        bestScore = score;
        best = entry;
      }
    });
    if (best) return best;
    const fallback = topNWords(lower, 1)[0]?.w || "related concept";
    return {
      concept: titleCase(fallback),
      gloss: "This adjacent concept provides framing that can clarify the mechanisms and assumptions in the note.",
      resource: "https://www.ncbi.nlm.nih.gov/books/"
    };
  }

  async function generateGptConferenceResponse() {
    const courses = state.courses || [];
    const entries = courses
      .map((course) => ({ course, notes: state.courseNotes?.[course]?.notes || "" }))
      .filter((c) => c.notes.trim());
    if (!entries.length) return "";
    const prompt = [
      "For each course note, return markdown with this exact structure:",
      "### <Course>",
      "- Summary:",
      "  - ...",
      "  - ...",
      "- Corrections: <1-2 sentences correcting misunderstandings if needed; otherwise write 'No correction needed.'>",
      "- Related concept: <2-4 sentence gloss directly tied to the note>",
      "- Recent article: <URL to a peer-reviewed article from the last ~5 years>",
      "- Resource: <URL to a good learning resource>",
      "Provide best-effort real URLs. If unsure, use a reputable journal homepage or DOI resolver search link.",
      "Be concise and helpful, not critical.",
      "Notes:",
      entries.map((c) => `### ${c.course}\n${c.notes}`).join("\n\n")
    ].join("\n");
    return callOpenAI([{ role: "user", content: prompt }], 0.35);
  }

  function buildConferenceResponse() {
    const courses = state.courses || [];
    const blocks = [];
    courses.forEach((course) => {
      const noteText = state.courseNotes?.[course]?.notes || "";
      if (!noteText.trim()) return;
      const bullets = extractConceptSentences(noteText, 3);
      const fallbackBullets = extractSentences(noteText).slice(0, 2);
      const summaryBullets = bullets.length ? bullets : (fallbackBullets.length ? fallbackBullets : ["—"]);
      const gloss = glossForNote(noteText);
      const resourceUrl = extractFirstUrl(noteText) || gloss.resource || "";
      const doi = extractFirstDoi(noteText);
      const articleUrl = doi ? `https://doi.org/${doi}` : "";
      blocks.push(`### ${course}`);
      blocks.push("- Summary:");
      summaryBullets.forEach((b) => blocks.push(`  - ${b}`));
      blocks.push("- Corrections: No correction needed.");
      blocks.push(`- Related concept: ${gloss.concept}. ${gloss.gloss}`);
      blocks.push(`- Recent article: ${articleUrl || "Add link"}`);
      blocks.push(`- Resource: ${resourceUrl || "Add link"}`);
      blocks.push("");
    });
    return blocks.length ? blocks.join("\n") : "";
  }

  async function analyzeNotesWithGpt(course, noteText) {
    if (!noteText || !noteText.trim()) return null;
    const prompt = [
      "Return strict JSON only (no markdown).",
      "Fields: title (string), key_concepts (array of 3 short sentences), academic_anchors (array of short tags).",
      "Title should be 3-8 words. Concepts should be short sentences.",
      `Course: ${course}`,
      `Notes: ${noteText}`
    ].join("\n");
    const raw = await callOpenAI([{ role: "user", content: prompt }], 0.3);
    try {
      const parsed = JSON.parse(raw);
      return {
        title: String(parsed.title || ""),
        concepts: Array.isArray(parsed.key_concepts) ? parsed.key_concepts.map(String) : [],
        anchors: Array.isArray(parsed.academic_anchors) ? parsed.academic_anchors.map(String) : []
      };
    } catch {
      return null;
    }
  }

  function generateMarkdown(opts = {}) {
    const d = new Date();
    const dateISO = d.toISOString().slice(0,10);
    const dateStr = d.toLocaleDateString(undefined, { weekday:"long", year:"numeric", month:"long", day:"numeric" });

    const { perCourse, mode, weekId } = computeForestMetrics();
    const courseList = state.courses || [];
    const doneToday = state.todayTasks.filter(t => t.done).length;
    const doneWeekend = state.weekendTasks.filter(t => t.done).length;
    const totalToday = state.todayTasks.length;
    const totalWeekend = state.weekendTasks.length;
    const totalTasks = totalToday + totalWeekend;
    const doneTotal = doneToday + doneWeekend;
    const completionRate = totalTasks ? (doneTotal / totalTasks) : 0;
    const writingText = normalizeText([state.writingSchedule, state.writingThread, state.writingTargets, state.writingNotes].filter(Boolean).join(" "));
    const proseText = normalizeText([state.proseSchedule, state.proseProject, state.proseTargets, state.proseNotes].filter(Boolean).join(" "));

    const perCourseMax = getLegacyForest().perCourseMax || {};
    const averages = courseList.length
      ? courseList.reduce((acc, course) => {
        const cur = perCourse[course] || {};
        const max = perCourseMax[course] || {};
        acc.words += cur.words || 0;
        acc.recursion += cur.recursion || 0;
        acc.abstraction += cur.abstraction || 0;
        acc.cohesion += cur.cohesion || 0;
        acc.argument += cur.argument || 0;
        acc.diversity += cur.diversity || 0;
        acc.tasks += cur.tasks || 0;
        acc.maxWords += max.words || 0;
        acc.maxRecursion += max.recursion || 0;
        acc.maxAbstraction += max.abstraction || 0;
        acc.maxCohesion += max.cohesion || 0;
        acc.maxArgument += max.argument || 0;
        acc.maxDiversity += max.diversity || 0;
        acc.maxTasks += max.tasks || 0;
        return acc;
      }, { words: 0, recursion: 0, abstraction: 0, cohesion: 0, argument: 0, diversity: 0, tasks: 0, maxWords: 0, maxRecursion: 0, maxAbstraction: 0, maxCohesion: 0, maxArgument: 0, maxDiversity: 0, maxTasks: 0 })
      : { words: 0, recursion: 0, abstraction: 0, cohesion: 0, argument: 0, diversity: 0, tasks: 0, maxWords: 0, maxRecursion: 0, maxAbstraction: 0, maxCohesion: 0, maxArgument: 0, maxDiversity: 0, maxTasks: 0 };

    const avgWords = courseList.length ? averages.words / courseList.length : 0;
    const avgRecursion = courseList.length ? averages.recursion / courseList.length : 0;
    const avgAbstraction = courseList.length ? averages.abstraction / courseList.length : 0;
    const avgCohesion = courseList.length ? averages.cohesion / courseList.length : 0;
    const avgArgument = courseList.length ? averages.argument / courseList.length : 0;
    const avgDiversity = courseList.length ? averages.diversity / courseList.length : 0;

    const avgMaxWords = courseList.length ? averages.maxWords / courseList.length : 0;
    const avgMaxRecursion = courseList.length ? averages.maxRecursion / courseList.length : 0;
    const avgMaxAbstraction = courseList.length ? averages.maxAbstraction / courseList.length : 0;
    const avgMaxCohesion = courseList.length ? averages.maxCohesion / courseList.length : 0;
    const avgMaxArgument = courseList.length ? averages.maxArgument / courseList.length : 0;
    const avgMaxDiversity = courseList.length ? averages.maxDiversity / courseList.length : 0;

    const complexityTrend = avgMaxWords + avgMaxRecursion + avgMaxAbstraction + avgMaxCohesion + avgMaxArgument + avgMaxDiversity
      ? formatDelta(((avgWords + avgRecursion + avgAbstraction + avgCohesion + avgArgument + avgDiversity) - (avgMaxWords + avgMaxRecursion + avgMaxAbstraction + avgMaxCohesion + avgMaxArgument + avgMaxDiversity)) / ((avgMaxWords + avgMaxRecursion + avgMaxAbstraction + avgMaxCohesion + avgMaxArgument + avgMaxDiversity) || 1))
      : "0%";

    const distribution = courseList.length
      ? (() => {
        const high = courseList.filter(c => (perCourse[c]?.stress || 0) >= 0.66).length;
        const low = courseList.filter(c => (perCourse[c]?.stress || 0) <= 0.33).length;
        const mid = courseList.length - high - low;
        return `Stress distribution: ${high} hot / ${mid} warm / ${low} steady.`;
      })()
      : "Stress distribution: 0 hot / 0 warm / 0 steady.";

    const keywords = topNWords(writingText, 6).map(x => titleCase(x.w));
    const linkages = keyPhrases(writingText, 6).map(titleCasePhrase);
    const confResponse = state.llmConferenceResponse || buildConferenceResponse();

    const forestFilename = opts.forestFilename || "forest.jpg";
    const graphFilename = opts.graphFilename || "concept_graph.jpg";

    const header = [
      `# Semester Dashboard — ${dateStr}`,
      ``,
      `**Intent:** ${state.intent || "—"}`,
      `**Core window:** ${state.coreWindow || "—"} | **Weekend posture:** ${state.weekendPosture || "—"} | **Rebalance:** ${state.rebalanceDay || "—"}`
    ].join("\n");

    const modes = Object.keys(state.modeChecks).map(label => {
      return mdCheckbox(label + ` (${(state.modeScope?.[label] || "weekly").toUpperCase()})`, !!state.modeChecks[label]);
    }).join("\n");

    const courseNotes = state.courses.map(course => {
      const c = state.courseNotes[course] || {};
      const t = [];
      t.push(`- ${obsidianLink(course)} — status: **${c.status || "steady"}**`);
      if (c.focus) t.push(`  - Focus: ${c.focus}`);
      if (c.budget) t.push(`  - Block budget: ${c.budget}`);
      const noteText = c.notes || "";
      const gptAnalysis = noteText.trim() ? (state.llmNoteAnalyses?.[course] || null) : null;
      const analysis = gptAnalysis && (gptAnalysis.title || gptAnalysis.concepts)
        ? {
          title: gptAnalysis.title || "Untitled Note",
          concepts: Array.isArray(gptAnalysis.concepts) ? gptAnalysis.concepts : [],
          anchors: Array.isArray(gptAnalysis.anchors) ? gptAnalysis.anchors : []
        }
        : buildNoteAnalysis(noteText);
      const noteBullets = analysis.concepts.map(p => `    - ${p || "—"}`).join("\n");
      const noteAnchors = (analysis.anchors || []).map((a) => a.startsWith("#") ? a : `#${slugTag(a)}`);
      t.push(`  - Note title: ${analysis.title}`);
      t.push(`  - Key concepts:`);
      t.push(noteBullets || "    - —");
      t.push(`  - Academic anchors: ${noteAnchors.join(" ") || "—"}`);
      if (noteText) t.push(`  - Notes: ${noteText}`);
      return t.join("\n");
    }).join("\n");

    const taskList = (title, list) => {
      if (!list.length) return `### ${title}\n- (none)`;
      return `### ${title}\n` + list.map(t => {
        const status = t.done ? "x" : " ";
        const course = t.course ? ` (${t.course})` : "";
        const mode = (t.mode && t.mode !== "(mode)") ? ` [${t.mode}]` : "";
        const label = (t.title || "Untitled").replace(/\n/g, " ");
        return `- [${status}] ${label}${course}${mode}`;
      }).join("\n");
    };

    const writing = [
      `### GCAS Writing`,
      `- Schedule: ${state.writingSchedule || "—"}`,
      `- Thread: ${state.writingThread || "—"}`,
      `- Targets: ${state.writingTargets || "—"}`,
      `- Notes: ${state.writingNotes || "—"}`
    ].join("\n");

    const prose = [
      `### Prose Writing`,
      `- Schedule: ${state.proseSchedule || "—"}`,
      `- Project: ${state.proseProject || "—"}`,
      `- Targets: ${state.proseTargets || "—"}`,
      `- Notes: ${state.proseNotes || "—"}`
    ].join("\n");

    const forestFile = forestFilename;
    const graphFile = graphFilename;

    const out = [
      header,
      ``,
      `## Modes`,
      modes,
      ``,
      `## Courses`,
      courseNotes,
      ``,
      taskList("Today Tasks", state.todayTasks),
      ``,
      taskList("Weekend Deliverables", state.weekendTasks),
      ``,
      writing,
      ``,
      prose,
      ``,
      `## Note Briefs + Concept Gloss`,
      confResponse,
      ``,
      `## Forest Snapshot`,
      `- Week: ${weekId}`,
      `- Avg words: ${avgWords.toFixed(1)} (max ${avgMaxWords.toFixed(1)})`,
      `- Avg recursion: ${avgRecursion.toFixed(2)} (max ${avgMaxRecursion.toFixed(2)})`,
      `- Avg abstraction: ${avgAbstraction.toFixed(2)} (max ${avgMaxAbstraction.toFixed(2)})`,
      `- Avg cohesion: ${avgCohesion.toFixed(2)} (max ${avgMaxCohesion.toFixed(2)})`,
      `- Avg argument: ${avgArgument.toFixed(2)} (max ${avgMaxArgument.toFixed(2)})`,
      `- Avg diversity: ${avgDiversity.toFixed(2)} (max ${avgMaxDiversity.toFixed(2)})`,
      `- Completion rate: ${percent(completionRate)}`,
      `- Forest image: ${forestFile ? `![[${forestFile}]]` : "N/A"}`,
      `- Concept graph image: ${graphFile ? `![[${graphFile}]]` : "N/A"}`
    ].join("\n");

    return out;
  }

  function setMdPreview(md) {
    state.mdCache = md;
    saveState();
    mdPreviewEl.textContent = md;
  }

  // ---------- Basic NLP helpers ----------
  const STOP = new Set([
    "the","a","an","and","or","but","if","then","else","when","where","why","how","what","which",
    "of","to","in","on","for","from","by","with","about","as","at","into","over","after","before","between","through",
    "is","are","was","were","be","been","being","it","its","this","that","these","those","i","you","he","she","they",
    "we","me","my","our","your","their","them","his","her","not","no","yes","so","do","did","does","doing","can","will",
    "just","than","too","very","more","most","less","least","up","down","out","off","again","new","old","also","still"
  ]);

  function normalizeText(s){
    return String(s || "")
      .replace(/\n/g, " ")
      .replace(/[^a-zA-Z0-9\s]/g, " ")
      .replace(/\s+/g, " ")
      .trim()
      .toLowerCase();
  }

  function splitSentences(text){
    if (!text) return [];
    return text.split(/[\.\?\!\n]/).map(s => s.trim()).filter(Boolean);
  }

  function contentWords(text){
    return String(text || "")
      .toLowerCase()
      .replace(/[^a-z0-9\s]/g, " ")
      .split(/\s+/)
      .filter(Boolean)
      .filter(w => !STOP.has(w))
      .filter(w => w.length > 2);
  }

  function topNWords(text, n=8){
    const freq = new Map();
    contentWords(text).forEach(w => freq.set(w, (freq.get(w)||0)+1));
    return Array.from(freq.entries())
      .sort((a,b)=>b[1]-a[1])
      .slice(0,n)
      .map(([w,count])=>({w,count}));
  }

  // ---------- Forest visualization ----------
  let lastForestGeom = null;
  const WEEKLY_ARCHIVE_PREFIX = `${STORAGE_KEY}_weekly_`;

  function saveWeeklyArchive(store) {
    if (!store?.weekId) return;
    try {
      localStorage.setItem(`${WEEKLY_ARCHIVE_PREFIX}${store.weekId}`, JSON.stringify(store));
    } catch {}
  }

  function loadWeeklyArchive(weekId) {
    if (!weekId) return null;
    try {
      const raw = localStorage.getItem(`${WEEKLY_ARCHIVE_PREFIX}${weekId}`);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed || parsed.weekId !== weekId) return null;
      return parsed;
    } catch {
      return null;
    }
  }

  function getWeeklyStore(weekId) {
    state.forest.weekly = state.forest.weekly || { weekId: "", courses: {} };
    if (state.forest.weekly.weekId !== weekId) {
      if (state.forest.weekly.weekId) saveWeeklyArchive(state.forest.weekly);
      const archived = loadWeeklyArchive(weekId);
      state.forest.weekly = archived || { weekId, courses: {} };
    }
    return state.forest.weekly;
  }

  const SUBORDINATE_MARKERS = ["that","which","because","if","since","although","while","unless","whereas","who","whom","whose"];
  const ABSTRACT_SUFFIXES = ["ness","ity","tion","sion","ment","ism","ence","hood","ship","tude"];
  const CONCEPT_VOCAB = new Set([
    "system","structure","function","process","mechanism","model","theory","framework","method",
    "concept","category","relation","dynamics","complexity","network","representation","inference",
    "causality","ontology","epistemology","phenomenology","semiotics","cybernetics","feedback",
    "homeostasis","entropy","information","computation","evidence","interpretation","hypothesis",
    "axiom","proof","lemma","constraint","parameter","variable","mapping","topology","category",
    "agent","ecology","evolution","plasticity","signal","encoding","decoding","gradient",
    "probability","distribution","derivative","integral","potential","channel","synapse","membrane"
  ]);
  const LOGICAL_CONNECTIVES = ["therefore","however","thus","hence","moreover","nevertheless","consequently","since","because","while","whereas","although"];
  const REFERENTIAL_PRONOUNS = ["this","that","these","those","such"];
  const MODAL_MARKERS = ["must","cannot","can't","should","ought","entails","implies","requires"];

  function countMatches(text, regex) {
    return (String(text || "").match(regex) || []).length;
  }

  function computeLinguisticMetrics(text) {
    const raw = String(text || "");
    const lower = raw.toLowerCase();
    const sentences = extractSentences(raw);
    const rawWords = lower.match(/\b[a-z][a-z'’\-]*\b/g) || [];
    const words = rawWords.length;

    const clauseSeparators = countMatches(raw, /[,;:—-]/g);
    const totalClauses = Math.max(1, sentences.length + clauseSeparators);
    const avgClauseLen = words ? (words / totalClauses) : 0;

    // BEGIN PATCH: fix word boundary regex
    const subordinateCount = countMatches(lower, new RegExp(`\\b(${SUBORDINATE_MARKERS.join("|")})\\b`, "g"));
    // END PATCH
    const punctCount = countMatches(raw, /[,;:—-]/g);

    const clauseLenN = clamp((avgClauseLen - 6) / 16, 0, 1);
    const subordinateN = clamp(subordinateCount / Math.max(1, sentences.length * 1.5), 0, 1);
    const punctN = clamp(punctCount / Math.max(1, sentences.length * 2), 0, 1);
    const recursionScore = clamp(0.45 * clauseLenN + 0.35 * subordinateN + 0.2 * punctN, 0, 1);

    const suffixCount = rawWords.filter(w => ABSTRACT_SUFFIXES.some(s => w.endsWith(s))).length;
    const conceptCount = rawWords.filter(w => CONCEPT_VOCAB.has(w)).length;
    const abstractionScore = clamp(((suffixCount / Math.max(1, words)) * 6) + ((conceptCount / Math.max(1, words)) * 4), 0, 1);

    const pronounCount = rawWords.filter(w => REFERENTIAL_PRONOUNS.includes(w)).length;
    const connectiveCount = rawWords.filter(w => LOGICAL_CONNECTIVES.includes(w)).length;
    const cohesionScore = clamp(((pronounCount / Math.max(1, words)) * 6) + ((connectiveCount / Math.max(1, words)) * 8), 0, 1);

    const modalCount = rawWords.filter(w => MODAL_MARKERS.includes(w)).length;
    const conditionalCount = sentences.filter(s => /\bif\b/i.test(s) && /\bthen\b/i.test(s)).length;
    const argumentScore = clamp(((modalCount / Math.max(1, words)) * 8) + (conditionalCount / Math.max(1, sentences.length)) * 2, 0, 1);

    const freq = new Map();
    rawWords.forEach(w => freq.set(w, (freq.get(w) || 0) + 1));
    const unique = freq.size;
    const typeToken = words ? unique / words : 0;
    const hapax = Array.from(freq.values()).filter(v => v === 1).length;
    const rareLong = rawWords.filter(w => w.length >= 9).length;
    const diversityScore = clamp(0.5 * typeToken + 0.3 * (hapax / Math.max(1, words)) + 0.2 * (rareLong / Math.max(1, words)), 0, 1);

    return {
      words,
      recursionScore,
      abstractionScore,
      cohesionScore,
      argumentScore,
      diversityScore
    };
  }

  function noteSessionScore(notes) {
    const metrics = computeLinguisticMetrics(notes);
    const words = metrics.words || 0;
    if (words < 10) return 0;

    const lengthTarget = 180;
    const lengthFactor = clamp(Math.sqrt(words) / Math.sqrt(lengthTarget), 0, 1);
    const complexity = clamp(
      0.25 * metrics.recursionScore +
      0.2 * metrics.abstractionScore +
      0.2 * metrics.cohesionScore +
      0.2 * metrics.argumentScore +
      0.15 * metrics.diversityScore,
      0,
      1
    );
    return clamp(0.35 * lengthFactor + 0.65 * complexity, 0, 1);
  }

  function updateWeeklySession(course, notes) {
    const weekId = currentWeekId();
    const store = getWeeklyStore(weekId);
    const dayKey = etDateKey();
    store.courses[course] = store.courses[course] || { days: {}, total: 0 };
    const score = noteSessionScore(notes);
    if (score <= 0) return;
    const prev = store.courses[course].days[dayKey] || 0;
    if (score > prev) {
      store.courses[course].days[dayKey] = score;
      const total = Object.values(store.courses[course].days).reduce((sum, v) => sum + v, 0);
      store.courses[course].total = total;
      saveState();
    }
  }

  function weeklyScoreForCourse(course, weekId) {
    const store = getWeeklyStore(weekId);
    const c = store.courses[course];
    if (!c) return { score: 0, sessions: 0 };
    const scores = Object.values(c.days || {});
    const sessions = scores.filter(s => s >= 0.2).length;
    const score = clamp(scores.reduce((sum, s) => sum + s, 0) / 5, 0, 1);
    return { score, sessions };
  }

  function computeForestMetrics() {
    const courses = state.courses || [];
    const perCourse = {};
    let total = 0;

    courses.forEach((course) => {
      const notes = (state.courseNotes[course]?.notes || "");
      const metrics = computeLinguisticMetrics(notes);
      const words = metrics.words || 0;
      const tasks = state.todayTasks.filter(t => t.course === course && t.done).length
        + state.weekendTasks.filter(t => t.course === course && t.done).length;

      const status = state.courseNotes[course]?.status || "steady";
      const stress = status === "danger" ? 1 : status === "hot" ? 0.75 : status === "watch" ? 0.45 : 0.2;

      perCourse[course] = {
        words,
        recursion: metrics.recursionScore,
        abstraction: metrics.abstractionScore,
        cohesion: metrics.cohesionScore,
        argument: metrics.argumentScore,
        diversity: metrics.diversityScore,
        tasks,
        stress
      };
      total += words + tasks * 20;
    });

    const dailyTotal = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="daily").length || 1;
    const weeklyTotal = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="weekly").length || 1;
    const dailyChecked = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="daily" && state.modeChecks[k]).length;
    const weeklyChecked = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="weekly" && state.modeChecks[k]).length;

    const mode = {
      dailyRatio: dailyChecked / dailyTotal,
      weeklyRatio: weeklyChecked / weeklyTotal,
      dailyChecked,
      weeklyChecked
    };

    const weekId = currentWeekId();
    return { perCourse, total, mode, weekId };
  }

  function hashString(str) {
    let h = 2166136261;
    for (let i = 0; i < str.length; i++) {
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h >>> 0;
  }

  function makeRng(seed) {
    let s = hashString(String(seed)) || 1;
    return () => {
      s = (s * 1664525 + 1013904223) >>> 0;
      return (s >>> 8) / 16777216;
    };
  }

  function seededRandom(key, salt = "") {
    const h = hashString(`${key}::${salt}`);
    return (h % 100000) / 100000;
  }

  function courseKeywords(course) {
    const raw = state.courseNotes?.[course]?.notes || "";
    const norm = normalizeText(raw);
    const words = topNWords(norm, 8).map(x => x.w);
    const phrases = keyPhrases(raw, 6).map(p => p.replace(/[^a-z0-9\s]/gi, "").trim()).filter(Boolean);
    return new Set([...words, ...phrases].filter(Boolean));
  }

  function getCourseKey(course) {
    return course?.id ?? course?.key ?? course?.name ?? String(course);
  }

  function courseComplexity(metrics) {
    const words = clamp((metrics.words || 0) / 220, 0, 1);
    const recursion = clamp(metrics.recursion || 0, 0, 1);
    const abstraction = clamp(metrics.abstraction || 0, 0, 1);
    const cohesion = clamp(metrics.cohesion || 0, 0, 1);
    const argument = clamp(metrics.argument || 0, 0, 1);
    const diversity = clamp(metrics.diversity || 0, 0, 1);
    const tasks = clamp((metrics.tasks || 0) / 6, 0, 1);
    return clamp(0.25 * words + 0.2 * recursion + 0.15 * abstraction + 0.15 * cohesion + 0.15 * argument + 0.1 * diversity + 0.1 * tasks, 0, 1);
  }

  function computeMyceliumGraph() {
    return { nodes: [], edges: [], weeklyByCourse: {}, conceptByCourse: {} };
  }

  function _buildFullGhost_impl(w, h, padL, padR, padT, baseY, perCourse, mode, weekId) {
    const legacy = getLegacyForest();
    const courses = state.courses || [];
    const simulateMax = !!state.forest.simulateMax;
    const seedSalt = getUserSeedSalt();
    const weekStartKey = isoWeekStartKey(weekId);
    const count = Math.max(1, courses.length);
    const spacing = w / (count + 1);
    const maxSource = simulateMax ? (legacy.perCourseMax || {}) : perCourse;
    const currentMax = {
      words: Math.max(1, ...Object.values(maxSource).map(m => m.words || 0)),
      recursion: Math.max(0.1, ...Object.values(maxSource).map(m => m.recursion || 0)),
      abstraction: Math.max(0.1, ...Object.values(maxSource).map(m => m.abstraction || 0)),
      cohesion: Math.max(0.1, ...Object.values(maxSource).map(m => m.cohesion || 0)),
      argument: Math.max(0.1, ...Object.values(maxSource).map(m => m.argument || 0)),
      diversity: Math.max(0.1, ...Object.values(maxSource).map(m => m.diversity || 0)),
      tasks: Math.max(1, ...Object.values(maxSource).map(m => m.tasks || 0))
    };
    const dummyCanvas = document.createElement("canvas");
    dummyCanvas.width = w;
    dummyCanvas.height = h;
    const ctx = dummyCanvas.getContext("2d");
    const ghostGeom = { width: w, height: h, trees: [] };
    courses.forEach((course, idx) => {
      const x0 = spacing * (idx + 1);
      const metrics = perCourse[course] || { words: 0, recursion: 0, abstraction: 0, cohesion: 0, argument: 0, diversity: 0, tasks: 0, stress: 0 };
      const maxMetrics = (legacy.perCourseMax || {})[course] || {};
      const wordsN = clamp((metrics.words || 0) / currentMax.words, 0, 1);
      const recursionN = clamp((metrics.recursion || 0) / currentMax.recursion, 0, 1);
      const abstractionN = clamp((metrics.abstraction || 0) / currentMax.abstraction, 0, 1);
      const cohesionN = clamp((metrics.cohesion || 0) / currentMax.cohesion, 0, 1);
      const argumentN = clamp((metrics.argument || 0) / currentMax.argument, 0, 1);
      const diversityN = clamp((metrics.diversity || 0) / currentMax.diversity, 0, 1);
      const tasksN = clamp((metrics.tasks || 0) / currentMax.tasks, 0, 1);
      const stress = clamp(metrics.stress || 0, 0, 1);
      const baseSignals = {
        words: metrics.words || 0,
        recursion: metrics.recursion || 0,
        abstraction: metrics.abstraction || 0,
        cohesion: metrics.cohesion || 0,
        argument: metrics.argument || 0,
        diversity: metrics.diversity || 0,
        tasks: metrics.tasks || 0,
        stress,
        wordsN,
        recursionN,
        abstractionN,
        cohesionN,
        argumentN,
        diversityN,
        tasksN,
        weeklyScoreN: 1,
        weekendScoreN: 1,
        writingDays: EFFORT_DAYS_CAP,
        maxWords: maxMetrics.words ?? metrics.words,
        maxRecursion: maxMetrics.recursion ?? metrics.recursion,
        maxAbstraction: maxMetrics.abstraction ?? metrics.abstraction,
        maxCohesion: maxMetrics.cohesion ?? metrics.cohesion,
        maxArgument: maxMetrics.argument ?? metrics.argument,
        maxDiversity: maxMetrics.diversity ?? metrics.diversity,
        maxTasks: maxMetrics.tasks ?? metrics.tasks
      };
      const eff = getEffectiveCourseSignals(course, baseSignals, { simulateMax });
      const effWordsN = eff.wordsN ?? 0;
      const effRecursionN = eff.recursionN ?? 0;
      const effAbstractionN = eff.abstractionN ?? 0;
      const effCohesionN = eff.cohesionN ?? 0;
      const effArgumentN = eff.argumentN ?? 0;
      const effDiversityN = eff.diversityN ?? 0;
      const effTasksN = eff.tasksN ?? 0;
      const noteText = state.courseNotes?.[course]?.notes || "";
      const keywordCount = courseKeywords(course).size;
      const phraseCount = keyPhrases(noteText, 8).length;
      const conceptN = clamp((keywordCount / 12 + phraseCount / 6 + effCohesionN) / 3, 0, 1);
      const weeklyScoreN = eff.weeklyScoreN ?? 1;
      const taskScoreN = eff.weekendScoreN ?? 1;
      const isGcas = /gcas/i.test(course);
      const heightScale = isGcas ? 1 : 0.7;
      const canopyBoost = isGcas ? 1 : 1.2;
      const maxHeight = Math.max(40, baseY - padT - 70);
      const height = Math.min(
        maxHeight * 0.6 * heightScale,
        (12 + 40 * weeklyScoreN + 16 * (effWordsN * weeklyScoreN) + 10 * (effTasksN * weeklyScoreN)) * heightScale
      );
      const complexityN = clamp((effWordsN + effRecursionN + effAbstractionN + effCohesionN + effArgumentN + effDiversityN + weeklyScoreN) / 7, 0, 1);
      const branchiness = clamp(0.25 + 0.9 * effRecursionN * weeklyScoreN + 0.2 * effTasksN * weeklyScoreN, 0.2, 1.8);
      const leaves = clamp(0.4 + 1.6 * taskScoreN * canopyBoost + 0.8 * effAbstractionN * weeklyScoreN + 0.4 * mode.weeklyRatio * weeklyScoreN, 0.3, 3.2);
      const crownSpread = clamp(1.0 + 1.4 * taskScoreN * canopyBoost + 0.7 * effAbstractionN, 1.0, 4.0);
      const dayLight = clamp(0.45 + 0.7 * mode.dailyRatio, 0.3, 1.1);

      drawTree(ctx, {
        x0,
        baseY,
        height,
        trunkW: 0.4 + 1.4 * effArgumentN,
        branchiness,
        leaves,
        crownSpread,
        stress,
        padT,
        padL,
        padR,
        w,
        dayLight,
        recursionN: effRecursionN,
        abstractionN: effAbstractionN,
        cohesionN: effCohesionN,
        argumentN: effArgumentN,
        diversityN: effDiversityN,
        tasksN: effTasksN,
        wordsN: effWordsN,
        conceptN,
        weeklyScoreN,
        weekendScoreN: taskScoreN,
        noteText,
        recursion: eff.recursion ?? metrics.recursion ?? 0,
        abstraction: eff.abstraction ?? metrics.abstraction ?? 0,
        cohesion: eff.cohesion ?? metrics.cohesion ?? 0,
        argument: eff.argument ?? metrics.argument ?? 0,
        diversity: eff.diversity ?? metrics.diversity ?? 0,
        complexityN,
        seedKey: `${course}|${weekStartKey}|${seedSalt}|full`,
        course,
        mode,
        effortAbs: 1,
        effortTotal: 1,
        idleMode: false
      }, ghostGeom);
    });
    return ghostGeom;
  }

  function buildFullGhost(...args) {
    if (FOREST_ENGINE === "v01") {
      throw new Error("Legacy ghost blocked (FOREST_ENGINE=v01)");
    }
    return _buildFullGhost_impl(...args);
  }

  function applyOrderedDither(ctx, w, h, strength = 0.05) {
    if (!ctx || !w || !h || strength <= 0) return;
    const bayer8 = [
      [0, 48, 12, 60, 3, 51, 15, 63],
      [32, 16, 44, 28, 35, 19, 47, 31],
      [8, 56, 4, 52, 11, 59, 7, 55],
      [40, 24, 36, 20, 43, 27, 39, 23],
      [2, 50, 14, 62, 1, 49, 13, 61],
      [34, 18, 46, 30, 33, 17, 45, 29],
      [10, 58, 6, 54, 9, 57, 5, 53],
      [42, 26, 38, 22, 41, 25, 37, 21]
    ];
    const img = ctx.getImageData(0, 0, Math.floor(w), Math.floor(h));
    const data = img.data;
    const amp = 255 * strength;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const idx = (y * w + x) * 4;
        const threshold = (bayer8[y % 8][x % 8] / 64 - 0.5) * amp;
        data[idx] = clamp(data[idx] + threshold, 0, 255);
        data[idx + 1] = clamp(data[idx + 1] + threshold, 0, 255);
        data[idx + 2] = clamp(data[idx + 2] + threshold, 0, 255);
      }
    }
    ctx.putImageData(img, 0, 0);
  }

  // BEGIN PATCH: capture + embed helpers
  function computeGeomBounds(geom) {
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;

    const expand = (x, y) => {
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
    };

    (geom?.paths || []).forEach((p) => {
      if (p.type === "circle") {
        const r = Math.max(0, p.r || 0);
        const pad = (p.sw || 0) * 0.5;
        expand((p.cx || 0) - r - pad, (p.cy || 0) - r - pad);
        expand((p.cx || 0) + r + pad, (p.cy || 0) + r + pad);
      } else if (typeof p.x1 === "number") {
        const pad = (p.sw || 0) * 0.5;
        expand(p.x1 - pad, p.y1 - pad);
        expand(p.x1 + pad, p.y1 + pad);
        expand(p.x2 - pad, p.y2 - pad);
        expand(p.x2 + pad, p.y2 + pad);
      }
    });

    if (!isFinite(minX) || !isFinite(minY) || !isFinite(maxX) || !isFinite(maxY)) {
      return { minX: 0, minY: 0, maxX: 1, maxY: 1, width: 1, height: 1 };
    }
    return { minX, minY, maxX, maxY, width: maxX - minX || 1, height: maxY - minY || 1 };
  }

  function buildCourseCells(w, h, courses, padL, padR, padT, padB, labelBand = 24) {
    const count = Math.max(1, courses.length);
    const totalW = Math.max(1, w - padL - padR);
    const cellW = totalW / count;
    const cellH = Math.max(1, h - padT - padB - labelBand);
    return courses.map((_, i) => ({
      x: padL + i * cellW,
      y: padT,
      w: cellW,
      h: cellH,
      labelY: padT + cellH + labelBand
    }));
  }

  function fitBoundsToCell(bounds, cell, padding = 16) {
    const innerW = Math.max(1, cell.w - padding * 2);
    const innerH = Math.max(1, cell.h - padding * 2);
    const scale = Math.min(innerW / bounds.width, innerH / bounds.height);
    const offsetX = cell.x + padding + (innerW - bounds.width * scale) / 2 - bounds.minX * scale;
    const offsetY = cell.y + padding + (innerH - bounds.height * scale) / 2 - bounds.minY * scale;
    return { scale, offsetX, offsetY };
  }

  function applyTransformToGeom(geom, t) {
    (geom?.paths || []).forEach((p) => {
      if (p.type === "circle") {
        p.cx = (p.cx || 0) * t.scale + t.offsetX;
        p.cy = (p.cy || 0) * t.scale + t.offsetY;
        p.r = Math.max(0.1, (p.r || 0) * t.scale);
        // Keep stroke width in screen space (do not scale).
      } else if (typeof p.x1 === "number") {
        p.x1 = p.x1 * t.scale + t.offsetX;
        p.y1 = p.y1 * t.scale + t.offsetY;
        p.x2 = p.x2 * t.scale + t.offsetX;
        p.y2 = p.y2 * t.scale + t.offsetY;
        // Keep stroke width in screen space (do not scale).
      }
    });
    if (Array.isArray(geom?.trunkNodes)) {
      geom.trunkNodes = geom.trunkNodes.map((n) => ({
        x: n.x * t.scale + t.offsetX,
        y: n.y * t.scale + t.offsetY
      }));
    }
    if (Array.isArray(geom?.leafPoints)) {
      geom.leafPoints = geom.leafPoints.map((p) => ({
        ...p,
        x: p.x * t.scale + t.offsetX,
        y: p.y * t.scale + t.offsetY
      }));
    }
  }

  function renderGeom(ctx, geom, scaleX = 1, scaleY = 1) {
    const eff = Math.max(0.0001, Math.sqrt(Math.abs(scaleX * scaleY)));
    const isSprout = !!geom?.morphStats?.isSprout;
    const maxTrunkPx = isSprout ? 0.9 : 1.6;
    (geom?.paths || []).forEach((p) => {
      if (p.type === "circle") {
        const r = Math.max(0, p.r || 0);
        if (p.fill && p.fill !== "none") {
          ctx.save();
          ctx.globalAlpha = p.fillAlpha ?? 1;
          ctx.fillStyle = p.fill;
          ctx.beginPath();
          ctx.arc(p.cx, p.cy, r, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
        const weight = p.sw ?? 0;
        const hasStroke = (p.stroke && p.stroke !== "none") && weight > 0;
        if (hasStroke) {
          ctx.save();
          ctx.globalAlpha = p.alpha ?? 1;
          ctx.strokeStyle = p.stroke || "#000000";
          const desiredPx = Math.max(0, Math.min(STROKE_BASE_PX * weight, maxTrunkPx));
          ctx.lineWidth = desiredPx / eff;
          ctx.beginPath();
          ctx.arc(p.cx, p.cy, r, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }
      } else if (typeof p.x1 === "number") {
        const weight = (typeof p.sw === "number") ? p.sw : 1;
        const alpha = p.alpha ?? 1;
        if (weight <= 0 || alpha <= 0) return;
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.strokeStyle = p.stroke || "#000000";
        const isTrunk = p.type === "trunk" || p.zoneType === "trunk";
        const rawPx = STROKE_BASE_PX * weight;
        const desiredPx = isTrunk
          ? Math.min(rawPx, maxTrunkPx)
          : clamp(rawPx, STROKE_MIN_PX, 1.6);
        ctx.lineWidth = desiredPx / eff;
        ctx.beginPath();
        ctx.moveTo(p.x1, p.y1);
        ctx.lineTo(p.x2, p.y2);
        ctx.stroke();
        ctx.restore();
      } else if (p.d) {
        const weight = (typeof p.sw === "number") ? p.sw : 1;
        const alpha = p.alpha ?? 1;
        if (weight <= 0 || alpha <= 0) return;
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.strokeStyle = p.stroke || "#000000";
        const desiredPx = clamp(STROKE_BASE_PX * weight, STROKE_MIN_PX, 1.6);
        ctx.lineWidth = desiredPx / eff;
        const path = new Path2D(p.d);
        ctx.stroke(path);
        ctx.restore();
      }
    });
  }

  function thinLeafPoints(points, params, rng) {
    const kept = [];
    const cell = Math.max(1, params.leafMinDist || 8);
    const grid = new Map();
    const key = (x, y) => `${(x / cell) | 0},${(y / cell) | 0}`;

    for (let i = 0; i < points.length; i++) {
      const p = points[i];
      const keepProb = clamp(p.keepProb ?? 1, 0, 1);
      if (rng() > keepProb) continue;
      const k = key(p.x, p.y);
      if (grid.has(k)) continue;
      grid.set(k, true);
      kept.push(p);
    }
    return kept;
  }

  function renderLeaves(ctx, geom, seedKey, settings) {
    if (!leavesEnabled) return;
    if (!settings?.enabled) return;
    let points = geom?.leafPoints || [];
    if (!points.length) return;
    const basePx = settings.leafBasePx ?? 1.4;
    const burstMult = settings.leafBurstMult ?? 1.6;
    const trunkMult = settings.leafTrunkMult ?? 0.7;
    const params = {
      leafMinDist: settings.leafMinDist ?? 8,
      leafCoreSuppression: settings.leafCoreSuppression ?? 0.5,
      leafMaxPerTree: settings.leafMaxPerTree ?? 900,
      leafBurstMult: burstMult,
      leafTrunkMult: trunkMult
    };
    const rng = makeRng(`${seedKey}|leaf-thin`);
    const prepared = points.map((p) => ({
      ...p,
      keepProb:
        (p.state === "BURST" ? params.leafBurstMult : params.leafTrunkMult) *
        (typeof p.bandNorm === "number" && p.bandNorm < 0.35 ? params.leafCoreSuppression : 1)
    }));
    points = thinLeafPoints(prepared, params, rng).slice(0, params.leafMaxPerTree);
    geom.leafPoints = points;
    const palette = [
      "#3a2c1b", "#5a3a1c", "#7a3d1a", "#9b4a1f",
      "#b8572a", "#d26a3a", "#e07f3f", "#f29c38",
      "#c6423a", "#a8332b", "#7f2b2b", "#612727",
      "#8d6a3c", "#a07c43"
    ];

    points.forEach((pt, idx) => {
      const state = pt.state === "BURST" ? "BURST" : "TRUNK";
      const probRand = seededRandom(seedKey, `leaf:${idx}:prob`);
      const keepProb = state === "BURST"
        ? (0.15 + 0.2 * probRand)
        : (0.03 + 0.05 * probRand);
      const keepRoll = seededRandom(seedKey, `leaf:${idx}:keep`);
      if (keepRoll > keepProb) return;

      const sizeRand = seededRandom(seedKey, `leaf:${idx}:size`);
      const alphaRand = seededRandom(seedKey, `leaf:${idx}:alpha`);
      const jitterX = (seededRandom(seedKey, `leaf:${idx}:jx`) - 0.5) * 6;
      const jitterY = (seededRandom(seedKey, `leaf:${idx}:jy`) - 0.5) * 6;
      const color = palette[Math.floor(seededRandom(seedKey, `leaf:${idx}:c`) * palette.length)];

      const weight = clamp(pt.w || 1, 0.5, 1.5);
      const mult = state === "BURST" ? burstMult : trunkMult;
      const size = clamp(basePx * (0.8 + 0.6 * sizeRand) * weight * mult, 0.6, 3.2);
      const alpha = 0.25 + 0.2 * alphaRand;

      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.ellipse(pt.x + jitterX, pt.y + jitterY, size * 1.2, size, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    });
  }
  // END PATCH

  const FOREST_ENGINE = "v01";
  // BEGIN PATCH: debug defaults for fast validation
  const DEBUG_FOREST = {
    enabled: true,
    showCells: true,
    showBBoxes: false,
    maxInternodePx: 6,
    nodeSpacingPx: 10,
    cellPadding: 18
  };
  const DEBUG_SCALE = false;
  // END PATCH

  const METRICS = {
    enabled: true,
    toConsole: true,
    toPanel: true,
    panelId: "forestMetricsPanel",
    reportEveryNFrames: 1,
    warn: {
      spreadEps: 1e-3,
      widthCapDominanceRatio: 0.90,
      bboxMinHpx: 10
    }
  };
  const TRUNK_GRAV = 0.06;
  const TRUNK_VISIBLE = false;
  const STROKE_BASE_PX = 0.85;
  const STROKE_MIN_PX = 0.35;
  const GEN_VERSION = 1;

  
  // ---------- Forest v01 (segments-only, deterministic, uniform scale) ----------
  const BLUEPRINT_CANVAS_W = 1200;
  const BLUEPRINT_CANVAS_H = 800;
  const V01_VERSION = 1;
  const MIN_STEPS = 120;
  const MAX_STEPS = 3200;
  const TOP_PAD = 16;
  const BOTTOM_PAD = 10;
  const V01_UNGUARDED = true;

  if (typeof window !== "undefined") {
    window.V01_DEBUG_DISABLE_OCC = window.V01_DEBUG_DISABLE_OCC || false;
    window.V01_DEBUG_DISABLE_TIER = window.V01_DEBUG_DISABLE_TIER || false;
    window.V01_DEBUG_DISABLE_CONE = window.V01_DEBUG_DISABLE_CONE || false;
    window.V01_DEBUG_DISABLE_DENSITYCAP = window.V01_DEBUG_DISABLE_DENSITYCAP || false;
    window.V01_DEBUG_DISABLE_SANITIZE_REDO = window.V01_DEBUG_DISABLE_SANITIZE_REDO || false;
    window.V01_DEBUG_DISABLE_COOLDOWN = window.V01_DEBUG_DISABLE_COOLDOWN || false;
    window.V01_DEBUG_SPAWN_HISTO = window.V01_DEBUG_SPAWN_HISTO || false;
  }

  function getV01DebugFlag(name) {
    if (typeof window === "undefined") return false;
    return !!window[name];
  }

  function clamp01(v) { return clamp(v, 0, 1); }

  function forestSignalsHash(obj) {
    if (!obj) return "0";
    const keys = Object.keys(obj).sort();
    const parts = [];
    for (const k of keys) {
      const v = obj[k];
      if (typeof v === "number") parts.push(`${k}:${v.toFixed(4)}`);
      else parts.push(`${k}:${String(v)}`);
    }
    return String(hashString(parts.join("|")));
  }

  function getForestV01Store() {
    state.forest = state.forest || {};
    state.forest.v01 = state.forest.v01 || { version: V01_VERSION, snapshots: {}, lastMetrics: null };
    if (state.forest.v01.version !== V01_VERSION) {
      state.forest.v01.version = V01_VERSION;
      state.forest.v01.snapshots = {};
      state.forest.v01.lastMetrics = null;
    }
    return state.forest.v01;
  }

  function getV01Snapshot(weekId, ck, dayKey) {
    const store = getForestV01Store();
    const week = store.snapshots[weekId];
    const course = week?.courses?.[ck];
    return course?.days?.[dayKey] || null;
  }

  function setV01Snapshot(weekId, ck, dayKey, snap) {
    const store = getForestV01Store();
    store.snapshots[weekId] = store.snapshots[weekId] || { courses: {} };
    store.snapshots[weekId].courses[ck] = store.snapshots[weekId].courses[ck] || { days: {} };
    store.snapshots[weekId].courses[ck].days[dayKey] = snap;
  }

  const geomCacheV01 = new Map();
  forestRuntime.v01.geomCache = geomCacheV01;

  function getGeomCacheKeyV01({ ck, weekId, dayKey, modeKey, simulateMax, signalsHash }) {
    return ["v01", ck, weekId, dayKey, modeKey, simulateMax ? 1 : 0, signalsHash || "0"].join("|");
  }

  function rotateVec(v, ang) {
    const c = Math.cos(ang);
    const s = Math.sin(ang);
    return { x: v.x * c - v.y * s, y: v.x * s + v.y * c };
  }

  function lerpVec(a, b, t) {
    return { x: lerp(a.x, b.x, t), y: lerp(a.y, b.y, t) };
  }

  function courseSignature(seedKey) {
    const lean = lerp(-0.35, 0.35, seededRandom(seedKey || "", "sig-lean"));
    const crownWidth = lerp(0.6, 1.6, seededRandom(seedKey || "", "sig-crown"));
    const tierSpacing = lerp(0.6, 1.6, seededRandom(seedKey || "", "sig-tier"));
    const taper = lerp(0.85, 1.15, seededRandom(seedKey || "", "sig-taper"));
    return { lean, crownWidth, tierSpacing, taper };
  }

  function clampAngleToCone(a, cone) {
    const up = -Math.PI / 2;
    const minA = up - cone;
    const maxA = up + cone;
    const d = angleDelta(up, a);
    const clamped = clamp(d, -cone, cone);
    return up + clamped;
  }

  function clampDirToCone(v, cone) {
    const a = Math.atan2(v.y, v.x);
    const clamped = clampAngleToCone(a, cone);
    return { x: Math.cos(clamped), y: Math.sin(clamped) };
  }

  function computeSegmentsBounds(segments) {
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    for (const s of segments) {
      if (!s) continue;
      minX = Math.min(minX, s.x1, s.x2);
      minY = Math.min(minY, s.y1, s.y2);
      maxX = Math.max(maxX, s.x1, s.x2);
      maxY = Math.max(maxY, s.y1, s.y2);
    }
    if (!Number.isFinite(minX)) return { minX: 0, minY: 0, maxX: 1, maxY: 1, width: 1, height: 1 };
    return { minX, minY, maxX, maxY, width: Math.max(1e-6, maxX - minX), height: Math.max(1e-6, maxY - minY) };
  }

  function sanitizeSegments(segments, observedMaxDepth, opts = {}) {
    const minLenBase = opts.minLenBase ?? 0.6;
    const minLenEnd = opts.minLenEnd ?? 1.8;
    const depthBins = 8;
    const segKeptCountByDepth = Array(depthBins).fill(0);
    const segKeptLenSumByDepth = Array(depthBins).fill(0);
    const clean = [];
    let minLenBaseUsed = minLenBase;
    const disableRedo = getV01DebugFlag("V01_DEBUG_DISABLE_SANITIZE_REDO");

    const keepPass = (scale = 1) => {
      clean.length = 0;
      segKeptCountByDepth.fill(0);
      segKeptLenSumByDepth.fill(0);
      for (const s of segments) {
        if (!s) continue;
        const x1 = s.x1, y1 = s.y1, x2 = s.x2, y2 = s.y2;
        if (!Number.isFinite(x1) || !Number.isFinite(y1) || !Number.isFinite(x2) || !Number.isFinite(y2)) continue;
        const len = Number.isFinite(s.len) ? s.len : Math.hypot(x2 - x1, y2 - y1);
        const d = Math.max(0, Number.isFinite(s.depth) ? s.depth : 0);
        const dN = observedMaxDepth > 0 ? clamp(d / observedMaxDepth, 0, 1) : 0;
        const minLen = lerp(minLenBase, minLenEnd, dN) * scale;
        if (len < minLen) continue;
        const db = Math.min(depthBins - 1, Math.floor(dN * depthBins));
        segKeptCountByDepth[db] += 1;
        segKeptLenSumByDepth[db] += len;
        clean.push({ ...s, len });
      }
    };

    keepPass(1);
    const segGen = segments.length;
    const minKeep = Math.max(40, Math.floor(segGen * 0.55));
    let sanitizeRedo = false;
    let redoTriggered = false;
    if (!disableRedo && clean.length < minKeep && segments.length) {
      sanitizeRedo = true;
      redoTriggered = true;
      keepPass(0.65);
      minLenBaseUsed = minLenBase * 0.65;
      if (clean.length < minKeep) {
        const sorted = [...segments].filter(Boolean).map((s) => {
          const len = Number.isFinite(s.len) ? s.len : Math.hypot(s.x2 - s.x1, s.y2 - s.y1);
          return { ...s, len };
        }).sort((a, b) => b.len - a.len);
        clean.length = 0;
        const K = Math.max(40, Math.floor(segGen * 0.65));
        for (let i = 0; i < Math.min(K, sorted.length); i++) clean.push(sorted[i]);
      }
    }

    let densityCapApplied = false;
    let hardCapSegmentsUsed = false;
    if (opts.densityCap && !getV01DebugFlag("V01_DEBUG_DISABLE_DENSITYCAP")) {
      densityCapApplied = true;
      const depthBinsCap = 10;
      const yBinsCap = 8;
      const buckets = new Map();
      for (const s of clean) {
        const d = Math.max(0, Number.isFinite(s.depth) ? s.depth : 0);
        const dN = observedMaxDepth > 0 ? clamp(d / observedMaxDepth, 0, 1) : 0;
        const db = Math.min(depthBinsCap - 1, Math.floor(dN * depthBinsCap));
        const yN = clamp((s.y2 + BLUEPRINT_CANVAS_H) / (2 * BLUEPRINT_CANVAS_H), 0, 1);
        const yb = Math.min(yBinsCap - 1, Math.floor(yN * yBinsCap));
        const key = `${db}|${yb}`;
        if (!buckets.has(key)) buckets.set(key, []);
        buckets.get(key).push(s);
      }
      const capped = [];
      buckets.forEach((list) => {
        list.sort((a, b) => (b.len || 0) - (a.len || 0));
        const keepN = Math.max(6, Math.floor(list.length * 0.5));
        capped.push(...list.slice(0, keepN));
      });
      clean.length = 0;
      clean.push(...capped);
      hardCapSegmentsUsed = true;
    }

    const segKeptAvgLenByDepth = segKeptCountByDepth.map((c, i) => c ? (segKeptLenSumByDepth[i] / c) : 0);
    return {
      segments: clean,
      segKeptCountByDepth,
      segKeptAvgLenByDepth,
      sanitizeRedo,
      redoTriggered,
      hardCapSegmentsUsed,
      densityCapApplied,
      minLenBaseUsed,
      keptCount: clean.length,
      genCount: segGen
    };
  }

  function computeSegmentStats(segments) {
    let total = 0;
    let horiz = 0;
    let up = 0;
    segments.forEach((s) => {
      const dx = s.x2 - s.x1;
      const dy = s.y2 - s.y1;
      const len = Math.hypot(dx, dy);
      if (len <= 0) return;
      total += len;
      if (Math.abs(dy) < 0.15 * len) horiz += len;
      if (dy < 0) up += len;
    });
    return { totalLen: total, horizFrac: total > 0 ? horiz / total : 0, upFrac: total > 0 ? up / total : 0 };
  }

  function stepRand(seedKey, step, salt = "") {
    const h = hashString(`${seedKey}|${salt}|${step}`) >>> 0;
    return (h % 100000) / 100000;
  }

  function generateSegmentsTreeV01(seedKey, params) {
    const growthRel = clamp(params.growthRel ?? 0, 0, 1);
    const isSimMax = !!(params?.simulateMax || params?.__simulateMax);
    const unguarded = !!V01_UNGUARDED;
    const disableOcc = getV01DebugFlag("V01_DEBUG_DISABLE_OCC") || unguarded;
    const disableTier = getV01DebugFlag("V01_DEBUG_DISABLE_TIER");
    const disableCone = getV01DebugFlag("V01_DEBUG_DISABLE_CONE") || unguarded;
    const disableCooldown = getV01DebugFlag("V01_DEBUG_DISABLE_COOLDOWN") || unguarded;
    const spawnDebug = getV01DebugFlag("V01_DEBUG_SPAWN_HISTO");
    let maxSteps = Math.max(1, Math.round(params.maxSteps || MIN_STEPS));
    const sig = courseSignature(seedKey || "");
    const grammarType = Math.floor(seededRandom(seedKey || "", "v01-grammar") * 4) % 4;
    const grammarProfiles = [
      { angleBias: 0.9, curvScale: 0.6, clusterSpread: 0.8 },
      { angleBias: 1.05, curvScale: 0.9, clusterSpread: 1.0 },
      { angleBias: 1.2, curvScale: 1.2, clusterSpread: 1.15 },
      { angleBias: 0.8, curvScale: 1.0, clusterSpread: 1.3 }
    ];
    const grammar = grammarProfiles[grammarType] || grammarProfiles[0];
    const sigCrownN = clamp((sig.crownWidth - 0.6) / 1.0, 0, 1);
    const sigTierN = clamp((sig.tierSpacing - 0.6) / 1.0, 0, 1);
    const sigTaperN = clamp((sig.taper - 0.85) / 0.3, 0, 1);
    const lenScale = MIN_STEPS / Math.max(MIN_STEPS, maxSteps);
    const baseLen = lerp(12, 16, growthRel) * lenScale;
    let decay = lerp(0.97, 0.92, growthRel);
    decay = clamp(decay * sig.taper, 0.88, 0.98);
    const tropism = lerp(0.08, 0.18, growthRel) * lerp(0.85, 1.15, sigTaperN);
    const jitterDeg = lerp(2, 8, growthRel);
    const trunkSteps = Math.round(lerp(12, 24, clamp(maxSteps / MAX_STEPS, 0, 1)));
    const minBranchStep = unguarded ? 1 : Math.max(2, Math.floor(trunkSteps * 0.2));
    const coneRad = 25 * (Math.PI / 180);
    let branchProb = lerp(0.08, 0.22, growthRel) * lerp(0.75, 1.35, sigCrownN);
    let maxDepth = 2;
    let baseBranchSteps = Math.round(lerp(10, 26, growthRel) * lerp(0.8, 1.35, sigTierN));
    const driftPhase = ((hashString(`${seedKey}|drift`) % 1000) / 1000) * Math.PI * 2;
    const driftPeriod = lerp(180, 320, growthRel);
    const driftAmp = lerp(0.008, 0.02, growthRel);
    const conePrimary = 50 * (Math.PI / 180);
    const coneTwig = 85 * (Math.PI / 180);
    const finalCone = 80 * (Math.PI / 180);
    const finalConeBranch = 95 * (Math.PI / 180);
    const wind = {
      baseTurnRate: 0.04,
      noiseAmp: 0.22,
      noiseScale: 16,
      headingInertiaK: 0.18,
      boundaryBand: 50,
      boundaryGain: 0.9,
      occCellSize: 12,
      occGain: 0.6,
      occDecay: 0.08
    };
    const canvasW = BLUEPRINT_CANVAS_W;
    const canvasH = BLUEPRINT_CANVAS_H;
    const baseX = canvasW * 0.5;
    const baseY = canvasH * 0.65;
    const canopyTop = canvasH * 0.18;
    const occ = makeOccGrid(canvasW, canvasH, wind.occCellSize);
    const trunkTierEveryBase = Math.round(10 + (14 - 10) * seededRandom(seedKey || "", "v01-trunk-tier"));
    const trunkTierEvery = unguarded ? 1 : Math.max(2, Math.round(trunkTierEveryBase * sig.tierSpacing));
    const tierEventsMax = unguarded ? 9999 : (isSimMax ? 0 : (growthRel >= 0.75 ? 2 : 1));
    const noSignal = unguarded ? false : (!!params.noSignal && !isSimMax);
    if (noSignal) {
      maxSteps = Math.min(maxSteps, 4);
      branchProb = 0.0;
      baseBranchSteps = 0;
    }

    const depthBins = 8;
    const yBins = 8;
    const spawnBins = 24;
    const spawnHistogram = spawnDebug ? Array(spawnBins).fill(0) : null;
    const spawnAttemptsByBin = spawnDebug ? Array(spawnBins).fill(0) : null;
    const spawnRejects = spawnDebug ? { cooldown: 0, tierCap: 0, budget: 0, tierDisabled: 0, coneClamp: 0, occ: 0, densityCap: 0 } : null;
    let spawnAccepted = 0;
    let spawnAttempts = 0;
    const spawnSeen = new Set();
    let spawnSeenCount = 0;
    let tierSpawnsBlocked = 0;
    const tasksN = clamp(params.tasksN ?? 0, 0, 1);
    const conceptsN = clamp(params.conceptsN ?? 0, 0, 1);
    const linkageN = clamp(params.linkageN ?? 0, 0, 1);
    const diversityN = clamp(params.diversityN ?? 0, 0, 1);
    const allowMicro = isSimMax || (growthRel > 0.45 && conceptsN > 0.25);
    maxDepth = allowMicro ? (isSimMax ? 4 : 3) : 2;
    let scaffoldBudget = Math.round(clamp(1 + 4 * (0.55 * growthRel + 0.25 * tasksN + 0.20 * linkageN), 1, 20));
    scaffoldBudget = Math.round(scaffoldBudget * lerp(0.85, 1.15, sigTierN));
    scaffoldBudget = clamp(scaffoldBudget, 1, 20);
    let twigBudget = Math.round(clamp(12 + 60 * (0.55 * conceptsN + 0.45 * diversityN), 60, 280));
    twigBudget = Math.round(twigBudget * lerp(0.80, 1.25, sigCrownN));
    twigBudget = clamp(twigBudget, 60, 280);
    if (noSignal) {
      scaffoldBudget = 0;
      twigBudget = 0;
    }
    if (!noSignal) {
      const minScaffold = isSimMax ? 14 : 8;
      const minTwig = isSimMax ? 260 : 160;
      scaffoldBudget = Math.max(scaffoldBudget, minScaffold);
      twigBudget = Math.max(twigBudget, minTwig);
    }
    let microTwigBudget = 0;
    if (allowMicro) {
      const t = isSimMax ? 1 : clamp((growthRel - 0.45) / 0.55, 0, 1);
      microTwigBudget = Math.round(lerp(10, 44, t));
    }
    let trunkStepsTotal = Math.round(maxSteps * (isSimMax ? 0.08 : 0.14));
    let scaffoldStepsTotal = Math.round(maxSteps * (isSimMax ? 0.46 : 0.44));
    let twigStepsTotal = Math.max(0, maxSteps - trunkStepsTotal - scaffoldStepsTotal);
    if (noSignal) {
      trunkStepsTotal = Math.min(maxSteps, trunkStepsTotal);
      scaffoldStepsTotal = 0;
      twigStepsTotal = 0;
    }
    if (scaffoldBudget === 0) {
      trunkStepsTotal += scaffoldStepsTotal;
      scaffoldStepsTotal = 0;
    }
    if (twigBudget === 0) {
      trunkStepsTotal += twigStepsTotal;
      twigStepsTotal = 0;
    }
    let trunkStepsLeft = trunkStepsTotal;
    let scaffoldStepsLeft = scaffoldStepsTotal;
    let twigStepsLeft = twigStepsTotal;
    let trunkStepsUsed = 0;
    let scaffoldStepsUsed = 0;
    let twigStepsUsed = 0;
    let microTwigBudgetLeft = microTwigBudget;
    const classDepthFor = (name) => {
      if (name === "trunk") return 0;
      if (name === "scaffold") return 1;
      if (name === "twig") return 2;
      if (name === "microTwig") return 3;
      return 0;
    };
    const scaffoldSchedule = new Set();
    if (scaffoldBudget > 0) {
      const scheduleSpan = Math.max(8, trunkStepsTotal);
      const baseSpacing = Math.max(4, Math.floor(scheduleSpan / (scaffoldBudget + 1)));
      for (let i = 0; i < scaffoldBudget; i++) {
        const jitter = Math.round((seededRandom(seedKey || "", `scaf-jit:${i}`) * 2 - 1) * Math.max(1, baseSpacing * 0.35));
        const idx = clamp(Math.round((i + 1) * baseSpacing + jitter), minBranchStep, Math.max(minBranchStep, scheduleSpan - 2));
        scaffoldSchedule.add(idx);
      }
    }
    const twigPerScaffold = Math.max(5, Math.round(twigBudget / Math.max(1, scaffoldBudget || 1)));
    const spawnKey = (depthVal, yVal) => {
      const dN = maxDepth > 0 ? clamp(depthVal / maxDepth, 0, 1) : 0;
      const yN = clamp(yVal / Math.max(1, canvasH), 0, 1);
      const db = Math.min(depthBins - 1, Math.floor(dN * depthBins));
      const yb = Math.min(yBins - 1, Math.floor(yN * yBins));
      return `${db}|${yb}`;
    };
    const markSpawn = (db, yb) => {
      if (db < 0 || db >= depthBins || yb < 0 || yb >= yBins) return;
      const key = `${db}|${yb}`;
      if (!spawnSeen.has(key)) {
        spawnSeen.add(key);
        spawnSeenCount += 1;
      }
    };
    const canSpawnHere = (depthVal, yVal, branchId, stepIndex) => {
      const key = spawnKey(depthVal, yVal);
      if (!key) return false;
      const [dbStr, ybStr] = key.split("|");
      const db = Number(dbStr);
      const yb = Number(ybStr);
      const dN = maxDepth > 0 ? clamp(depthVal / maxDepth, 0, 1) : 0;
      const overrideBase = isSimMax ? 0.55 : 0.45;
      const overrideMax = isSimMax ? 0.90 : 0.75;
      const overrideProb = lerp(overrideBase, overrideMax, Math.pow(dN, 0.7));
      if (disableCooldown) {
        markSpawn(db, yb);
        return true;
      }
      let blocked = spawnSeen.has(key);
      if (blocked) {
        const roll = stepRand(`${seedKey}|${branchId||0}`, stepIndex || 0, "spawn-override");
        if (roll >= overrideProb) return false;
        markSpawn(db, yb);
        return true;
      }
      markSpawn(db, yb);
      return true;
    };
    const recordSpawn = (yVal, depthVal, accepted, reasons = {}) => {
      if (!spawnDebug) return;
      if (!Number.isFinite(yVal)) return;
      const yN = clamp(yVal / Math.max(1, canvasH), 0, 1);
      const bin = Math.min(spawnBins - 1, Math.floor(yN * spawnBins));
      spawnAttempts += 1;
      if (spawnAttemptsByBin) spawnAttemptsByBin[bin] += 1;
      if (accepted) {
        spawnAccepted += 1;
        if (spawnHistogram) spawnHistogram[bin] += 1;
      } else if (spawnRejects) {
        Object.keys(reasons).forEach((k) => {
          if (reasons[k]) spawnRejects[k] = (spawnRejects[k] || 0) + 1;
        });
      }
    };

    const segments = [];
    let branchEvents = 0;
    let branchesPushed = 0;
    let branchSpawns = 0;
    let stackMax = 0;
    let depthMaxReached = 0;
    let pops = 0;
    let angVelSumSq = 0;
    let angVelCount = 0;
    let boundaryHits = 0;
    let occHits = 0;
    let boundaryAppliedCount = 0;
    let occAppliedCount = 0;
    let tierEventsFired = 0;
    let scaffoldEventsFired = 0;
    let twigEventsFired = 0;
    let scaffoldLenSum = 0;
    let scaffoldLenCount = 0;
    let twigLenSum = 0;
    let twigLenCount = 0;
    const classCounts = { trunk: 0, scaffold: 0, twig: 0 };

    const segGenCountByDepth = Array(depthBins).fill(0);
    const segGenLenSumByDepth = Array(depthBins).fill(0);
    const segGenSinSumByDepth = Array(depthBins).fill(0);
    const segGenCosSumByDepth = Array(depthBins).fill(0);

    const up = { x: 0, y: -1 };
    const baseDir = rotateVec(up, sig.lean);
    const jitterRad = (jitterDeg * Math.PI) / 180;
    let branchSerial = 0;
    let trunkStepIndex = 0;
    let budgetLeft = maxSteps;
    let stepIndex = 0;

    let state = { x: 0, y: 0, dir: { x: baseDir.x, y: baseDir.y }, depth: 0, stepsLeft: trunkStepsTotal, angVel: 0, branchId: 0, parentId: null, className: "trunk", localStep: 0, curvBias: 0, curvVel: 0 };
    const stack = [];

    while (budgetLeft > 0 && state) {
      if (state.stepsLeft <= 0) {
        pops += 1;
        state = stack.pop();
        continue;
      }
      const cls = state.className || "trunk";
      const classDepth = classDepthFor(cls);
      const depth = classDepth;
      state.depth = classDepth;
      if (cls === "trunk") {
        if (trunkStepsLeft <= 0) {
          state.stepsLeft = 0;
          continue;
        }
        if (state.stepsLeft > trunkStepsLeft) state.stepsLeft = trunkStepsLeft;
      } else if (cls === "scaffold") {
        if (scaffoldStepsLeft <= 0) {
          state.stepsLeft = 0;
          continue;
        }
        if (state.stepsLeft > scaffoldStepsLeft) state.stepsLeft = scaffoldStepsLeft;
      } else {
        if (twigStepsLeft <= 0) {
          state.stepsLeft = 0;
          continue;
        }
        if (state.stepsLeft > twigStepsLeft) state.stepsLeft = twigStepsLeft;
      }
      let dir = state.dir;
      dir = lerpVec(dir, up, tropism);
      const noise = (stepRand(`${seedKey}|${state.branchId}`, stepIndex + depth * 1000, "noise") * 2 - 1) * jitterRad;
      state.angVel = 0.85 * state.angVel + 0.15 * noise;
      dir = rotateVec(dir, state.angVel);
      const drift = Math.sin((stepIndex / driftPeriod) * Math.PI * 2 + driftPhase) * driftAmp;
      dir = rotateVec(dir, drift);
      let stepLen = baseLen * Math.pow(decay, depth);
      if (state.className === "scaffold") stepLen *= 1.2;
      if (state.className === "twig") stepLen *= 1.1;
      const dN = maxDepth > 0 ? clamp(classDepth / maxDepth, 0, 1) : 0;
      const stepBoost = isSimMax ? lerp(1.0, 1.8, Math.pow(dN, 1.1)) : lerp(1.0, 1.3, Math.pow(dN, 1.1));
      stepLen *= stepBoost;
      const minStep = isSimMax ? lerp(0.8, 2.0, dN) : lerp(0.6, 1.4, dN);
      stepLen = Math.max(stepLen, minStep);
      let dirAngle = Math.atan2(dir.y, dir.x);
      const xC = state.x + baseX;
      const yC = state.y + baseY;
      const baseTurn = (stepRand(`${seedKey}|${state.branchId}`, stepIndex, "baseTurn") * 2 - 1) * wind.baseTurnRate;
      const noiseTurn = noise1D(seedKey, state.branchId || 0, stepIndex, wind.noiseScale) * wind.noiseAmp;
      const topEdge = yC;
      const minDist = topEdge;
      const band = Math.max(1, wind.boundaryBand || 1);
      const mN = clamp((band - minDist) / band, 0, 1);
      const depthN = maxDepth > 0 ? clamp(classDepth / maxDepth, 0, 1) : 0;
      const steerGain = lerp(1.0, 0.35, Math.pow(depthN, 0.8));
      const maxSteer = (depth === 0 ? (6 * (Math.PI / 180)) : (10 * (Math.PI / 180)));
    let boundary = 0;
      if (!unguarded && !disableOcc && mN > 0.35) {
        boundary = boundaryTurn(dirAngle, xC, yC, canvasW, canvasH, wind.boundaryBand, wind.boundaryGain);
        const branchBoundaryScale = (depth === 0) ? 1 : 0.25;
        boundary = clamp(boundary, -maxSteer, maxSteer) * steerGain * 0.65 * branchBoundaryScale;
      }
      const boundaryAppliedThisStep = Math.abs(boundary) > 1e-4;
      if (boundaryAppliedThisStep) {
        boundaryHits += 1;
        boundaryAppliedCount += 1;
      }
      let densityBias = 0;
      if (!disableOcc) {
        const forward = occSample(occ, xC + Math.cos(dirAngle) * stepLen * 1.5, yC + Math.sin(dirAngle) * stepLen * 1.5);
        const left = occSample(occ, xC + Math.cos(dirAngle - Math.PI / 4) * stepLen * 1.2, yC + Math.sin(dirAngle - Math.PI / 4) * stepLen * 1.2);
        const right = occSample(occ, xC + Math.cos(dirAngle + Math.PI / 4) * stepLen * 1.2, yC + Math.sin(dirAngle + Math.PI / 4) * stepLen * 1.2);
        const occLevel = Math.max(forward, left, right);
        if (!unguarded && occLevel > 0.25) {
          const branchOccScale = (depth === 0) ? 1 : 0.25;
          densityBias = (right - left) * -wind.occGain * (1 + forward * 0.2);
          densityBias = clamp(densityBias, -maxSteer, maxSteer) * steerGain * branchOccScale;
        }
      }
      const occAppliedThisStep = Math.abs(densityBias) > 1e-4;
      if (occAppliedThisStep) {
        occHits += 1;
        occAppliedCount += 1;
      }
      if (cls === "scaffold") {
        const cb = state.curvBias || 0;
        state.curvVel = 0.9 * (state.curvVel || 0) + 0.1 * cb;
        dirAngle += state.curvVel;
      }
      let desiredAngle = dirAngle + baseTurn + noiseTurn + boundary + densityBias;
      if (!disableCone) {
        const coneUse = (depth === 0) ? finalCone : finalConeBranch;
        desiredAngle = clampAngleToCone(desiredAngle, coneUse);
      }
      const desiredDir = { x: Math.cos(desiredAngle), y: Math.sin(desiredAngle) };
      dir = lerpVec(dir, desiredDir, wind.headingInertiaK);
      dirAngle = Math.atan2(dir.y, dir.x);
      angVelSumSq += state.angVel * state.angVel;
      angVelCount += 1;
      if (!disableCone && stepIndex < trunkSteps && depth === 0) {
        dir = clampDirToCone(dir, coneRad);
        dirAngle = Math.atan2(dir.y, dir.x);
      }
      if (!unguarded && Math.abs(dir.y) < 0.15) {
        const horizBias = (depth === 0) ? 0.65 : 0.35;
        dir = lerpVec(dir, up, horizBias);
        dirAngle = Math.atan2(dir.y, dir.x);
      }

      let nx = state.x + dir.x * stepLen;
      let ny = state.y + dir.y * stepLen;
      const nxC = nx + baseX;
      const nyC = ny + baseY;
      if (!unguarded && (nxC < 8 || nxC > canvasW - 8 || nyC < 8 || nyC > canvasH - 8)) {
        const toward = Math.atan2(baseY - yC, baseX - xC);
        const adjust = angleDelta(dirAngle, toward) * 0.65;
        dir = rotateVec(dir, adjust);
        dirAngle = Math.atan2(dir.y, dir.x);
        nx = state.x + dir.x * stepLen * 0.75;
        ny = state.y + dir.y * stepLen * 0.75;
        boundaryHits += 1;
        boundaryAppliedCount += 1;
      }

      const len = Math.hypot(nx - state.x, ny - state.y);
      const clsUse = cls || (classDepth === 0 ? "trunk" : "scaffold");
      classCounts[clsUse] = (classCounts[clsUse] || 0) + 1;
      if (clsUse === "trunk") { trunkStepsLeft -= 1; trunkStepsUsed += 1; }
      else if (clsUse === "scaffold") { scaffoldStepsLeft -= 1; scaffoldStepsUsed += 1; }
      else { twigStepsLeft -= 1; twigStepsUsed += 1; }
      if (clsUse === "scaffold") { scaffoldLenSum += len; scaffoldLenCount += 1; }
      if (clsUse === "twig" || clsUse === "microTwig") { twigLenSum += len; twigLenCount += 1; }
      const taperBoost = (clsUse === "scaffold") ? 0.3 : (clsUse === "twig") ? 0.9 : (clsUse === "microTwig") ? 1.4 : 0;
      const depthRender = Math.min(maxDepth, classDepth + taperBoost);
      segments.push({ x1: state.x, y1: state.y, x2: nx, y2: ny, depth: depthRender, branchId: state.branchId, parentId: state.parentId, len, className: clsUse });
      const dbi = Math.min(depthBins - 1, Math.floor(dN * depthBins));
      segGenCountByDepth[dbi] += 1;
      segGenLenSumByDepth[dbi] += len;
      segGenSinSumByDepth[dbi] += Math.sin(dirAngle);
      segGenCosSumByDepth[dbi] += Math.cos(dirAngle);
      state.x = nx;
      state.y = ny;
      state.dir = dir;
      state.stepsLeft -= 1;
      budgetLeft -= 1;
      occStamp(occ, nx + baseX, ny + baseY, wind.occDecay);
      if (classDepth === 0) trunkStepIndex += 1;
      state.localStep = (state.localStep || 0) + 1;

      let branchedNow = false;
      if (!branchedNow && !noSignal && classDepth === 0 && scaffoldSchedule.has(trunkStepIndex) && scaffoldEventsFired < scaffoldBudget && budgetLeft > 6 && scaffoldStepsLeft > 0) {
        if (disableTier) {
          recordSpawn(yC, depth, false, { tierDisabled: true, occ: occAppliedThisStep, coneClamp: !disableCone });
        } else if (!canSpawnHere(classDepthFor("scaffold"), yC, state.branchId, stepIndex)) {
          tierSpawnsBlocked += 1;
          recordSpawn(yC, depth + 1, false, { cooldown: true, occ: occAppliedThisStep, coneClamp: !disableCone });
        } else {
          const dualRoll = seededRandom(seedKey || "", `scaf-dual:${scaffoldEventsFired}`);
          const dualChance = lerp(0.15, 0.55, clamp(1 - linkageN, 0, 1));
          const twoBranches = dualRoll < dualChance;
          const scafAngle = lerp(28, 52, seededRandom(seedKey || "", `scaf-ang:${scaffoldEventsFired}`)) * (Math.PI / 180) * sig.crownWidth * grammar.angleBias;
          const branchCone = conePrimary * 1.25;
          const trunkState = { x: state.x, y: state.y, dir, depth: classDepth, stepsLeft: state.stepsLeft, angVel: state.angVel, branchId: state.branchId, parentId: state.parentId, className: state.className, localStep: state.localStep };
          const spawnBranch = (sign) => {
            const bDirRaw = rotateVec(dir, sign * scafAngle);
            const bTheta = disableCone ? Math.atan2(bDirRaw.y, bDirRaw.x) : clampAngleToCone(Math.atan2(bDirRaw.y, bDirRaw.x), branchCone);
            const bDir = { x: Math.cos(bTheta), y: Math.sin(bTheta) };
            const bStepsRaw = Math.round(baseBranchSteps * 1.1);
            const bSteps = clamp(Math.min(bStepsRaw, scaffoldStepsLeft), 10, Math.floor(0.4 * maxSteps));
            const twigSchedule = [];
            const clusterCount = clamp(Math.round(lerp(2, 6, seededRandom(seedKey || "", `twig-cl:${branchSerial}`))), 2, 6);
            const clusterSizes = Array(clusterCount).fill(1);
            let remaining = Math.max(0, twigPerScaffold - clusterCount);
            let guard = 0;
            while (remaining > 0 && guard < 2000) {
              const idx = Math.floor(seededRandom(seedKey || "", `twig-cl-alloc:${branchSerial}:${guard}`) * clusterCount);
              if (clusterSizes[idx] < 9) {
                clusterSizes[idx] += 1;
                remaining -= 1;
              }
              guard += 1;
            }
            const spreadBase = Math.max(2, Math.floor((bSteps * 0.08) * grammar.clusterSpread));
            for (let c = 0; c < clusterCount; c++) {
              const centerJitter = Math.round((seededRandom(seedKey || "", `twig-cl-center:${branchSerial}:${c}`) * 2 - 1) * Math.max(1, spreadBase));
              const center = clamp(Math.round(((c + 1) / (clusterCount + 1)) * bSteps + centerJitter), 2, Math.max(2, bSteps - 1));
              const count = clusterSizes[c];
              const span = Math.max(1, Math.floor(spreadBase * 0.6));
              for (let j = 0; j < count; j++) {
                const offset = Math.round((j - (count - 1) / 2) * span);
                const jitter = Math.round((seededRandom(seedKey || "", `twig-jit:${branchSerial}:${c}:${j}`) * 2 - 1) * Math.max(1, span * 0.35));
                const idx = clamp(center + offset + jitter, 2, Math.max(2, bSteps - 1));
                twigSchedule.push(idx);
              }
            }
            const newBranchId = ++branchSerial;
            const branchState = {
              x: state.x,
              y: state.y,
              dir: bDir,
              depth: classDepthFor("scaffold"),
              stepsLeft: bSteps,
              angVel: state.angVel * 0.5,
              branchId: newBranchId,
              parentId: state.branchId,
              className: "scaffold",
              localStep: 0,
              curvBias: (seededRandom(seedKey || "", `scaf-curv:${newBranchId}`) * 2 - 1) * lerp(0.002, 0.01, grammar.curvScale),
              curvVel: 0,
              twigSchedule,
              twigIndex: 0
            };
            stack.push(trunkState);
            branchesPushed += 1;
            branchSpawns += 1;
            stackMax = Math.max(stackMax, stack.length);
            state = branchState;
          };
          spawnBranch(1);
          if (twoBranches) spawnBranch(-1);
          scaffoldEventsFired += 1;
          tierEventsFired = scaffoldEventsFired;
          branchEvents += twoBranches ? 2 : 1;
          depthMaxReached = Math.max(depthMaxReached, state.depth);
          branchedNow = true;
          recordSpawn(yC, classDepthFor("scaffold"), true);
        }
      }

      if (!branchedNow && !noSignal && state.className === "scaffold" && Array.isArray(state.twigSchedule) && state.twigIndex < state.twigSchedule.length && budgetLeft > 2 && twigStepsLeft > 0) {
        const targetStep = state.twigSchedule[state.twigIndex];
        if (state.localStep >= targetStep && classDepth < maxDepth) {
          const twigAngle = lerp(20, 38, stepRand(`${seedKey}|${state.branchId}`, stepIndex, "twig-ang")) * (Math.PI / 180) * sig.crownWidth;
          const sign = stepRand(`${seedKey}|${state.branchId}`, stepIndex, "twig-sign") < 0.5 ? -1 : 1;
          const tDirRaw = rotateVec(dir, sign * twigAngle);
          const branchCone = coneTwig * 1.2;
          const tTheta = disableCone ? Math.atan2(tDirRaw.y, tDirRaw.x) : clampAngleToCone(Math.atan2(tDirRaw.y, tDirRaw.x), branchCone);
          const tDir = { x: Math.cos(tTheta), y: Math.sin(tTheta) };
          const tStepsRaw = Math.round(baseBranchSteps * 0.55);
          const tSteps = clamp(Math.min(tStepsRaw, twigStepsLeft), 6, Math.floor(0.18 * maxSteps));
          const microSchedule = [];
          if (allowMicro && microTwigBudgetLeft > 0) {
            const microCount = Math.min(2, microTwigBudgetLeft);
            const microSpacing = Math.max(2, Math.floor(tSteps / (microCount + 1)));
            for (let i = 0; i < microCount; i++) {
              const jitter = Math.round((seededRandom(seedKey || "", `micro-jit:${branchSerial}:${i}`) * 2 - 1) * Math.max(1, microSpacing * 0.35));
              const idx = clamp(Math.round((i + 1) * microSpacing + jitter), 2, Math.max(2, tSteps - 1));
              microSchedule.push(idx);
            }
            microTwigBudgetLeft -= microCount;
          }
          const scaffoldState = { ...state };
          scaffoldState.twigIndex = (scaffoldState.twigIndex || 0) + 1;
          const newBranchId = ++branchSerial;
          state = {
            x: state.x,
            y: state.y,
            dir: tDir,
            depth: classDepthFor("twig"),
            stepsLeft: tSteps,
            angVel: state.angVel * 0.6,
            branchId: newBranchId,
            parentId: state.branchId,
            className: "twig",
            localStep: 0,
            microSchedule,
            microIndex: 0
          };
          stack.push(scaffoldState);
          branchesPushed += 1;
          branchSpawns += 1;
          branchEvents += 1;
          twigEventsFired += 1;
          depthMaxReached = Math.max(depthMaxReached, state.depth);
          branchedNow = true;
          recordSpawn(yC, classDepthFor("twig"), true);
        }
      }

      if (!branchedNow && !noSignal && state.className === "twig" && Array.isArray(state.microSchedule) && state.microIndex < state.microSchedule.length && budgetLeft > 1 && twigStepsLeft > 0) {
        const targetStep = state.microSchedule[state.microIndex];
        if (state.localStep >= targetStep && classDepth < maxDepth) {
          const microAngle = lerp(16, 32, stepRand(`${seedKey}|${state.branchId}`, stepIndex, "micro-ang")) * (Math.PI / 180);
          const sign = stepRand(`${seedKey}|${state.branchId}`, stepIndex, "micro-sign") < 0.5 ? -1 : 1;
          const mDirRaw = rotateVec(dir, sign * microAngle);
          const branchCone = coneTwig * 1.25;
          const mTheta = disableCone ? Math.atan2(mDirRaw.y, mDirRaw.x) : clampAngleToCone(Math.atan2(mDirRaw.y, mDirRaw.x), branchCone);
          const mDir = { x: Math.cos(mTheta), y: Math.sin(mTheta) };
          const mStepsRaw = Math.round(baseBranchSteps * 0.35);
          const mSteps = clamp(Math.min(mStepsRaw, twigStepsLeft), 4, Math.floor(0.08 * maxSteps));
          const twigState = { ...state };
          twigState.microIndex = (twigState.microIndex || 0) + 1;
          const newBranchId = ++branchSerial;
          state = {
            x: state.x,
            y: state.y,
            dir: mDir,
            depth: classDepthFor("microTwig"),
            stepsLeft: mSteps,
            angVel: state.angVel * 0.7,
            branchId: newBranchId,
            parentId: state.branchId,
            className: "microTwig",
            localStep: 0
          };
          stack.push(twigState);
          branchesPushed += 1;
          branchSpawns += 1;
          branchEvents += 1;
          twigEventsFired += 1;
          depthMaxReached = Math.max(depthMaxReached, state.depth);
          branchedNow = true;
          recordSpawn(yC, classDepthFor("microTwig"), true);
        }
      }

      if (!branchedNow && state.stepsLeft <= 0) {
        pops += 1;
        state = stack.pop();
      }
      stepIndex += 1;
    }

    const segGenAvgLenByDepth = segGenCountByDepth.map((count, i) => count ? (segGenLenSumByDepth[i] / count) : 0);
    const segGenAngleMeanByDepth = segGenCountByDepth.map((count, i) => count ? Math.atan2(segGenSinSumByDepth[i], segGenCosSumByDepth[i]) : 0);
    const segGenAngleStdByDepth = segGenCountByDepth.map((count, i) => {
      if (!count) return 0;
      const R = Math.hypot(segGenSinSumByDepth[i], segGenCosSumByDepth[i]) / count;
      return Math.sqrt(Math.max(0, -2 * Math.log(Math.max(1e-6, R))));
    });
    const spawnReport = spawnDebug ? {
      bins: spawnHistogram || [],
      attemptsByBin: spawnAttemptsByBin || [],
      rejects: spawnRejects || {},
      total: spawnAccepted,
      attempts: spawnAttempts,
      depthBins,
      yBins,
      spawnBins
    } : null;
    const totalSegs = (classCounts.trunk || 0) + (classCounts.scaffold || 0) + (classCounts.twig || 0) + (classCounts.microTwig || 0);
    const classShares = {
      trunk: totalSegs ? (classCounts.trunk || 0) / totalSegs : 0,
      scaffold: totalSegs ? (classCounts.scaffold || 0) / totalSegs : 0,
      twig: totalSegs ? (classCounts.twig || 0) / totalSegs : 0,
      microTwig: totalSegs ? (classCounts.microTwig || 0) / totalSegs : 0
    };

    return {
      segments,
      meta: {
        branchEvents,
        branchesPushed,
        branchSpawns,
        pops,
        stackMax,
        depthMaxReached,
        maxDepth,
        classDepthMax: depthMaxReached,
        trunkStepsTotal,
        scaffoldStepsTotal,
        twigStepsTotal,
        trunkStepsUsed,
        scaffoldStepsUsed,
        twigStepsUsed,
        angVelRMS: angVelCount ? Math.sqrt(angVelSumSq / angVelCount) : 0,
        boundaryHits,
        occHits,
        rng: "seeded",
        tierEventsFired,
        tierEventsMax,
        tierSpawnsBlocked,
        spawnSeenCount,
        spawnBlocked: tierSpawnsBlocked,
        boundaryAppliedCount,
        occAppliedCount,
        scaffoldBudget,
        twigBudget,
        scaffoldEventsFired,
        twigEventsFired,
        meanScaffoldLen: scaffoldLenCount ? (scaffoldLenSum / scaffoldLenCount) : 0,
        meanTwigLen: twigLenCount ? (twigLenSum / twigLenCount) : 0,
        classCounts,
        classShares,
        grammarType,
        sigLean: sig.lean,
        sigCrownWidth: sig.crownWidth,
        sigTierSpacing: sig.tierSpacing,
        sigTaper: sig.taper,
        segGenCountByDepth,
        segGenAvgLenByDepth,
        genCountByDepthBin: segGenCountByDepth,
        stepLenAvgByDepthBin: segGenAvgLenByDepth,
        segGenAngleMeanByDepth,
        segGenAngleStdByDepth,
        spawnReport
      }
    };
  }

  function generateGeomV01({ course, label, seedKey, signals, params, simulateMax }) {
    const gen = generateSegmentsTreeV01(seedKey, params);
    const rawSegments = gen.segments || [];
    const segmentsBeforeSanitize = rawSegments.length;
    let observedMaxDepth = 0;
    let missingDepth = false;
    rawSegments.forEach((s) => {
      if (!s || !Number.isFinite(s.depth)) missingDepth = true;
      else observedMaxDepth = Math.max(observedMaxDepth, s.depth);
    });
    if (missingDepth && DEBUG_FOREST?.enabled) {
      console.warn("[V01Depth] missing depth on segments", { seedKey, count: rawSegments.length });
    }
    const sanitized = sanitizeSegments(rawSegments, observedMaxDepth, { minLenBase: 0.6, minLenEnd: 1.8, densityCap: false });
    const clean = sanitized.segments;
    const segmentsAfterSanitize = clean.length;
    let minSegLenKept = Infinity;
    let segLenSum = 0;
    let missingBranchId = false;
    let missingLen = false;
    const branchIds = new Set();
    clean.forEach((s) => {
      const len = Number.isFinite(s.len) ? s.len : Math.hypot(s.x2 - s.x1, s.y2 - s.y1);
      if (!Number.isFinite(s.len)) missingLen = true;
      const bid = Number.isFinite(s.branchId) ? s.branchId : 0;
      if (!Number.isFinite(s.branchId)) missingBranchId = true;
      branchIds.add(bid);
      if (len < minSegLenKept) minSegLenKept = len;
      segLenSum += len;
    });
    if ((missingBranchId || missingLen) && DEBUG_FOREST?.enabled) {
      console.warn("[V01Segments] missing meta on segments", { seedKey, missingBranchId, missingLen });
    }
    const avgSegLen = clean.length ? (segLenSum / clean.length) : 0;
    const branchIdCount = branchIds.size;

    const metaBase = {
      maxStepsUsed: params.maxSteps,
      source: "regen",
      __simulateMax: !!(params.simulateMax || params.__simulateMax),
      branchEvents: gen.meta?.branchEvents ?? 0,
      branchesPushed: gen.meta?.branchesPushed ?? 0,
      branchSpawns: gen.meta?.branchSpawns ?? 0,
      pops: gen.meta?.pops ?? 0,
      stackMax: gen.meta?.stackMax ?? 0,
      depthMaxReached: gen.meta?.depthMaxReached ?? 0,
      maxDepth: gen.meta?.maxDepth ?? 0,
      classDepthMax: gen.meta?.classDepthMax ?? 0,
      trunkStepsTotal: gen.meta?.trunkStepsTotal ?? 0,
      scaffoldStepsTotal: gen.meta?.scaffoldStepsTotal ?? 0,
      twigStepsTotal: gen.meta?.twigStepsTotal ?? 0,
      trunkStepsUsed: gen.meta?.trunkStepsUsed ?? 0,
      scaffoldStepsUsed: gen.meta?.scaffoldStepsUsed ?? 0,
      twigStepsUsed: gen.meta?.twigStepsUsed ?? 0,
      observedMaxDepth,
      angVelRMS: gen.meta?.angVelRMS ?? 0,
      boundaryHits: gen.meta?.boundaryHits ?? 0,
      occHits: gen.meta?.occHits ?? 0,
      boundaryAppliedCount: gen.meta?.boundaryAppliedCount ?? gen.meta?.boundaryHits ?? 0,
      occAppliedCount: gen.meta?.occAppliedCount ?? gen.meta?.occHits ?? 0,
      rng: gen.meta?.rng ?? "seeded",
      tierEventsFired: gen.meta?.tierEventsFired ?? 0,
      tierEventsMax: gen.meta?.tierEventsMax ?? 0,
      tierSpawnsBlocked: gen.meta?.tierSpawnsBlocked ?? 0,
      spawnSeenCount: gen.meta?.spawnSeenCount ?? 0,
      spawnBlocked: gen.meta?.spawnBlocked ?? gen.meta?.tierSpawnsBlocked ?? 0,
      segGenCountByDepth: gen.meta?.segGenCountByDepth || [],
      segGenAvgLenByDepth: gen.meta?.segGenAvgLenByDepth || [],
      genCountByDepthBin: gen.meta?.genCountByDepthBin || gen.meta?.segGenCountByDepth || [],
      stepLenAvgByDepthBin: gen.meta?.stepLenAvgByDepthBin || gen.meta?.segGenAvgLenByDepth || [],
      segGenAngleMeanByDepth: gen.meta?.segGenAngleMeanByDepth || [],
      segGenAngleStdByDepth: gen.meta?.segGenAngleStdByDepth || [],
      spawnReport: gen.meta?.spawnReport || null,
      sigLean: gen.meta?.sigLean ?? 0,
      sigCrownWidth: gen.meta?.sigCrownWidth ?? 0,
      sigTierSpacing: gen.meta?.sigTierSpacing ?? 0,
      sigTaper: gen.meta?.sigTaper ?? 0,
      scaffoldBudget: gen.meta?.scaffoldBudget ?? 0,
      twigBudget: gen.meta?.twigBudget ?? 0,
      scaffoldEventsFired: gen.meta?.scaffoldEventsFired ?? 0,
      twigEventsFired: gen.meta?.twigEventsFired ?? 0,
      meanScaffoldLen: gen.meta?.meanScaffoldLen ?? 0,
      meanTwigLen: gen.meta?.meanTwigLen ?? 0,
      classCounts: gen.meta?.classCounts || {},
      classShares: gen.meta?.classShares || {},
      grammarType: gen.meta?.grammarType ?? 0,
      branchIdCount,
      segmentsBeforeSanitize,
      segmentsAfterSanitize,
      segBefore: segmentsBeforeSanitize,
      segAfter: segmentsAfterSanitize,
      avgSegLen,
      minSegLenKept: Number.isFinite(minSegLenKept) ? minSegLenKept : 0,
      segKept: segmentsAfterSanitize,
      segGen: segmentsBeforeSanitize,
      sanitizeRedo: !!sanitized.sanitizeRedo,
      redoTriggered: !!sanitized.redoTriggered,
      hardCapSegmentsUsed: !!sanitized.hardCapSegmentsUsed,
      densityCapApplied: !!sanitized.densityCapApplied,
      keptCount: sanitized.keptCount ?? segmentsAfterSanitize,
      genCount: sanitized.genCount ?? segmentsBeforeSanitize,
      segKeptCountByDepth: sanitized.segKeptCountByDepth || [],
      segKeptAvgLenByDepth: sanitized.segKeptAvgLenByDepth || [],
      minLenBaseUsed: sanitized.minLenBaseUsed ?? 0
    };
    if (metaBase.spawnReport) {
      metaBase.spawnReport.densityCapApplied = !!sanitized.densityCapApplied;
      if (metaBase.spawnReport.rejects) metaBase.spawnReport.rejects.densityCap = sanitized.densityCapApplied ? 1 : 0;
    }
    if (!clean.length) {
      return { segments: makeFallbackSegments(seedKey), meta: { ...metaBase, source: "fallback" } };
    }
    return { segments: clean, meta: metaBase };
  }

  function makeFallbackSegments(seedKey) {
    const rng = makeRng(seedKey || "fallback");
    const trunkLen = 70 + rng() * 40;
    const branchLen = 28 + rng() * 18;
    const twigLen = 18 + rng() * 12;
    const ang = 0.35 + rng() * 0.35;
    const ang2 = 0.45 + rng() * 0.35;
    const midY = -trunkLen * 0.55;
    const topY = -trunkLen;
    const segs = [
      { x1: 0, y1: 0, x2: 0, y2: -trunkLen },
      { x1: 0, y1: midY, x2: Math.cos(-Math.PI / 2 + ang) * branchLen, y2: Math.sin(-Math.PI / 2 + ang) * branchLen + midY },
      { x1: 0, y1: midY, x2: Math.cos(-Math.PI / 2 - ang2) * branchLen * 0.9, y2: Math.sin(-Math.PI / 2 - ang2) * branchLen * 0.9 + midY },
      { x1: 0, y1: topY, x2: Math.cos(-Math.PI / 2 + ang * 0.6) * twigLen, y2: Math.sin(-Math.PI / 2 + ang * 0.6) * twigLen + topY }
    ];
    return segs.map((s) => ({ ...s, depth: 0, branchId: 0, parentId: null, len: Math.hypot(s.x2 - s.x1, s.y2 - s.y1) }));
  }

  function drawGeomSegments(ctx, segments, scale, maxDepth = 0) {
    if (!segments.length) return;
    ctx.save();
    ctx.strokeStyle = "#000000";
    ctx.globalAlpha = 1;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    const basePx = 1;
    const baseLW = basePx / Math.max(1e-6, scale);
    segments.forEach((s) => {
      const depth = Math.max(0, Number.isFinite(s.depth) ? s.depth : 0);
      const dN = maxDepth > 0 ? clamp(depth / maxDepth, 0, 1) : 0;
      const lw = baseLW * lerp(1.0, 0.35, dN);
      ctx.lineWidth = lw;
      ctx.beginPath();
      ctx.moveTo(s.x1, s.y1);
      ctx.lineTo(s.x2, s.y2);
      ctx.stroke();
    });
    ctx.restore();
  }

  function getSimMaxSignals(base) {
    const s = { ...base };
    s.words = Math.max(2200, s.words || 0);
    s.tasks = Math.max(6, s.tasks || 0);
    s.recursion = 1; s.abstraction = 1; s.cohesion = 1; s.argument = 1; s.diversity = 1;
    s.wordsN = 1; s.tasksN = 1; s.recursionN = 1; s.abstractionN = 1; s.cohesionN = 1; s.argumentN = 1; s.diversityN = 1;
    s.weeklyScoreN = 1; s.weekendScoreN = 1;
    s.writingDays = 6;
    s.stress = 0;
    s.modeDaily = 1;
    s.modeWeekly = 1;
    s.__simulateMax = true;
    return s;
  }

  function getCourseNotes(course) {
    const ck = getCourseKey(course);
    return state.courseNotes?.[ck]?.notes || "";
  }

  function renderForestV01(opts = {}) {
    if (!forestCanvas) return;
    const simulateMax = !!state.forest.simulateMax;
    if (typeof window !== "undefined") {
      window.forestStats = window.forestStats || { blueprintBuilds: 0, drawCalls: 0, keystrokeRedraws: 0, regenCommits: 0, drawTreeCalls: 0, revealCalls: 0 };
      window.forestStats.drawCalls += 1;
    }
    const allowRegen = simulateMax || opts.allowRegen !== false || !lastForestGeom;
    const { ctx, w, h } = initCanvasHiDPI(forestCanvas, null, null, { willReadFrequently: true });
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = getCSSVar("--panel");
    ctx.fillRect(0, 0, w, h);
    lastScaleStats = {};

    const v01Store = getForestV01Store();
    let perCourse;
    let mode;
    let weekId;
    if (!allowRegen && v01Store.lastMetrics) {
      ({ perCourse, mode, weekId } = v01Store.lastMetrics);
    } else {
      ({ perCourse, mode, weekId } = computeForestMetrics());
      if (allowRegen) v01Store.lastMetrics = { perCourse, mode, weekId };
    }
    perCourse = perCourse || {};
    mode = mode || { dailyRatio: 0, weeklyRatio: 0 };
    if (v01Store.weekId !== weekId) {
      v01Store.weekId = weekId;
      geomCacheV01.clear();
      saveStateSoon();
    }
    const courses = state.courses || [];
    if (!courses.length) {
      ctx.fillStyle = "#8b8c9b";
      ctx.font = "12px " + getCSSVar("--sans");
      ctx.textAlign = "center";
      ctx.fillText("No courses yet to render forest.", w / 2, h / 2);
      lastForestGeom = { width: w, height: h, trees: [] };
      renderForestLegend(perCourse, courses, weekId);
      return;
    }

    const seedSalt = getUserSeedSalt();
    const weekStartKey = isoWeekStartKey(weekId);
    const dayKey = etDateKey();
    const modeKey = focusMode || "grid";

    const padL = 50;
    const padR = 50;
    const padT = 30;
    const padB = 70;
    const labelBand = 24;
    const cells = buildCourseCells(w, h, courses, padL, padR, padT, padB, labelBand);

    // max metrics for normalization
    const maxSource = perCourse;
    const currentMax = {
      words: Math.max(1, ...Object.values(maxSource).map(m => m.words || 0)),
      recursion: Math.max(0.1, ...Object.values(maxSource).map(m => m.recursion || 0)),
      abstraction: Math.max(0.1, ...Object.values(maxSource).map(m => m.abstraction || 0)),
      cohesion: Math.max(0.1, ...Object.values(maxSource).map(m => m.cohesion || 0)),
      argument: Math.max(0.1, ...Object.values(maxSource).map(m => m.argument || 0)),
      diversity: Math.max(0.1, ...Object.values(maxSource).map(m => m.diversity || 0)),
      tasks: Math.max(1, ...Object.values(maxSource).map(m => m.tasks || 0))
    };

    const didDrawByCourse = {};

    courses.forEach((course, idx) => {
      const ck = getCourseKey(course);
      const cell = cells[idx];
      if (!cell) return;
      const metrics = perCourse[course] || perCourse[ck] || { words: 0, recursion: 0, abstraction: 0, cohesion: 0, argument: 0, diversity: 0, tasks: 0, stress: 0 };
      const wordsN = clamp((metrics.words || 0) / currentMax.words, 0, 1);
      const recursionN = clamp((metrics.recursion || 0) / currentMax.recursion, 0, 1);
      const abstractionN = clamp((metrics.abstraction || 0) / currentMax.abstraction, 0, 1);
      const cohesionN = clamp((metrics.cohesion || 0) / currentMax.cohesion, 0, 1);
      const argumentN = clamp((metrics.argument || 0) / currentMax.argument, 0, 1);
      const diversityN = clamp((metrics.diversity || 0) / currentMax.diversity, 0, 1);
      const tasksN = clamp((metrics.tasks || 0) / currentMax.tasks, 0, 1);
      const noteText = getCourseNotes(course);
      const keywordCount = courseKeywords(ck).size;
      const phraseCount = keyPhrases(noteText, 6).length;
      const conceptsN = clamp((keywordCount / 12 + phraseCount / 6 + cohesionN) / 3, 0, 1);
      const linkageN = clamp((conceptsN + cohesionN) / 2, 0, 1);
      const weeklyScore = weeklyScoreForCourse(course, weekId);
      const weeklyScoreN = clamp(weeklyScore.score || 0, 0, 1);
      const weekendDone = state.weekendTasks.filter(t => getCourseKey(t.course) === ck && t.done).length;
      const weekendTotal = Math.max(1, state.weekendTasks.filter(t => getCourseKey(t.course) === ck).length);
      const weekendScoreN = clamp(weekendDone / weekendTotal, 0, 1);
      const writingDays = weeklyScore.sessions || 0;
      const baseSignals = {
        words: metrics.words || 0,
        recursion: metrics.recursion || 0,
        abstraction: metrics.abstraction || 0,
        cohesion: metrics.cohesion || 0,
        argument: metrics.argument || 0,
        diversity: metrics.diversity || 0,
        tasks: metrics.tasks || 0,
        stress: metrics.stress || 0,
        wordsN,
        recursionN,
        abstractionN,
        cohesionN,
        argumentN,
        diversityN,
        tasksN,
        weeklyScoreN,
        weekendScoreN,
        writingDays,
        noteText,
        modeDaily: mode?.dailyRatio ?? 0,
        modeWeekly: mode?.weeklyRatio ?? 0
      };
      const effectiveSignals = simulateMax ? getSimMaxSignals(baseSignals) : baseSignals;
      if (simulateMax) effectiveSignals.noteText = "";
      const weekendRel = simulateMax ? 1 : clamp(effectiveSignals.weekendScoreN ?? 0, 0, 1);
      const growthRel = simulateMax ? 1 : clamp(getGrowthN(effectiveSignals).value ?? 0, 0, 1);
      const targetFrac = lerp(0.18, 0.78, smoothstep(0, 1, growthRel));
      const maxSteps = simulateMax ? MAX_STEPS : Math.round(MIN_STEPS + (MAX_STEPS - MIN_STEPS) * growthRel);
      const noSignal = simulateMax ? false : (((metrics.words | 0) === 0) && ((metrics.tasks | 0) === 0));
      const seedKey = `${ck}|${weekStartKey}|${dayKey}|v01|${seedSalt}`;
      const signalsHash = forestSignalsHash({ ...effectiveSignals, weekendRel, growthRel, effortAbs: computeEffortAbs(effectiveSignals.tasks || 0, effectiveSignals.writingDays || 0, effectiveSignals.words || 0) });

      let params = {
        growthRel,
        targetFrac,
        maxSteps,
        weekendRel,
        noSignal,
        simulateMax,
        __simulateMax: effectiveSignals.__simulateMax,
        tasksN,
        conceptsN,
        linkageN,
        diversityN
      };
      let snapshot = null;
      let geomSource = "fallback";
      let regenNeeded = false;
      if (!simulateMax) {
        snapshot = getV01Snapshot(weekId, ck, dayKey);
        regenNeeded = !snapshot || snapshot.signalsHash !== signalsHash;
        if (allowRegen && regenNeeded) {
          const snap = { signalsHash, seed: seedKey, params };
          setV01Snapshot(weekId, ck, dayKey, snap);
          snapshot = snap;
          saveStateSoon();
        }
        if (snapshot?.params) params = snapshot.params;
      }

      if (simulateMax) {
        params.growthRel = 1;
        params.weekendRel = 1;
        params.maxSteps = MAX_STEPS;
      }

      const cacheSignalsHash = (!simulateMax && snapshot?.signalsHash) ? snapshot.signalsHash : signalsHash;
      const cacheKey = getGeomCacheKeyV01({ ck, weekId, dayKey, modeKey, simulateMax, signalsHash: cacheSignalsHash });
      const forceRegen = allowRegen && getV01DebugFlag("V01_DEBUG_SPAWN_HISTO");
      let geom = forceRegen ? null : geomCacheV01.get(cacheKey);
      if (!geom && allowRegen) {
        geom = generateGeomV01({ course, label: ck, seedKey, signals: { ...effectiveSignals, weekendRel }, params, simulateMax });
        geomCacheV01.set(cacheKey, geom);
        geomSource = geom?.meta?.source || "regen";
      } else if (geom) {
        geomSource = "cache";
      }
      if (!geom) {
        geom = { segments: makeFallbackSegments(seedKey), meta: { maxStepsUsed: params.maxSteps, source: "fallback" } };
        geomSource = "fallback";
      }

      const geomMeta = geom.meta || {};
      const maxDepthForRender = geomMeta.observedMaxDepth ?? geomMeta.depthMaxReached ?? geomMeta.maxDepth ?? 0;
      const sanitized = sanitizeSegments(geom.segments || [], maxDepthForRender, { minLenBase: 0.6, minLenEnd: 1.8, densityCap: false });
      let segments = sanitized.segments;
      if (!segments.length) {
        segments = makeFallbackSegments(seedKey);
        geomSource = "fallback";
      }
      const bounds = computeSegmentsBounds(segments);
      const segStats = computeSegmentStats(segments);
      const availH = Math.max(1, cell.h - TOP_PAD - BOTTOM_PAD);
      const minTargetPx = simulateMax ? 220 : 70;
      let targetH = Math.max(availH * params.targetFrac, minTargetPx);
      if (simulateMax) {
        const headroom = 50;
        const sigCrownN = clamp(((geomMeta.sigCrownWidth ?? 1.0) - 0.6) / 1.0, 0, 1);
        const heightMul = lerp(0.92, 1.06, sigCrownN);
        targetH = Math.min(targetH * heightMul, Math.max(1, availH - headroom));
      }
      const maxBoundsDim = 2400;
      const effBoundsW = Math.min(bounds.width, maxBoundsDim);
      const effBoundsH = Math.min(bounds.height, maxBoundsDim);
      const xScaleCap = (0.90 * cell.w) / Math.max(1e-6, effBoundsW);
      const yScaleRaw = targetH / Math.max(1e-6, effBoundsH);
      const widthLimited = xScaleCap < yScaleRaw;
      let s = Math.min(xScaleCap, yScaleRaw);
      const heightWins = widthLimited && xScaleCap < (yScaleRaw * 0.2);
      if (heightWins) s = yScaleRaw;
      const targetX = cell.x + cell.w / 2;
      const targetY = cell.y + cell.h - 10;
      const anchorX = (bounds.minX + bounds.maxX) / 2;
      const anchorY = bounds.maxY;

      ctx.save();
      try {
        ctx.translate(targetX, targetY);
        ctx.scale(s, s);
        ctx.translate(-anchorX, -anchorY);
        drawGeomSegments(ctx, segments, s, maxDepthForRender);
      } finally {
        ctx.restore();
      }

      lastScaleStats[ck] = {
        courseKey: ck,
        geomSource,
        growthRel: simulateMax ? 1 : growthRel,
        targetFrac,
        maxStepsUsed: simulateMax ? MAX_STEPS : params.maxSteps,
        bounds,
        effBoundsW,
        effBoundsH,
        scale: s,
        targetH,
        availH,
        heightFill: (bounds.height * s) / Math.max(1e-6, availH),
        widthLimited,
        heightWins,
        xScaleCap,
        yScaleRaw,
        spawnReport: geomMeta.spawnReport || null,
        segBefore: geomMeta.segBefore ?? geomMeta.segmentsBeforeSanitize ?? segments.length,
        segAfter: geomMeta.segAfter ?? geomMeta.segmentsAfterSanitize ?? segments.length,
        densityCapApplied: geomMeta.densityCapApplied ?? sanitized.densityCapApplied ?? false,
        redoTriggered: !!(geomMeta.redoTriggered ?? sanitized.redoTriggered),
        observedMaxDepth: geomMeta.observedMaxDepth ?? geomMeta.depthMaxReached ?? 0,
        classDepthMax: geomMeta.classDepthMax ?? 0,
        trunkStepsUsed: geomMeta.trunkStepsUsed ?? 0,
        scaffoldStepsUsed: geomMeta.scaffoldStepsUsed ?? 0,
        twigStepsUsed: geomMeta.twigStepsUsed ?? 0,
        trunkStepsTotal: geomMeta.trunkStepsTotal ?? 0,
        scaffoldStepsTotal: geomMeta.scaffoldStepsTotal ?? 0,
        twigStepsTotal: geomMeta.twigStepsTotal ?? 0,
        tierEventsFired: geomMeta.tierEventsFired ?? 0,
        branchSpawns: geomMeta.branchSpawns ?? 0,
        spawnBlocked: geomMeta.spawnBlocked ?? 0,
        occAppliedCount: geomMeta.occAppliedCount ?? 0,
        boundaryAppliedCount: geomMeta.boundaryAppliedCount ?? 0,
        sigLean: geomMeta.sigLean ?? 0,
        sigCrownWidth: geomMeta.sigCrownWidth ?? 0,
        sigTierSpacing: geomMeta.sigTierSpacing ?? 0,
        sigTaper: geomMeta.sigTaper ?? 0,
        scaffoldBudget: geomMeta.scaffoldBudget ?? 0,
        twigBudget: geomMeta.twigBudget ?? 0,
        scaffoldEventsFired: geomMeta.scaffoldEventsFired ?? 0,
        twigEventsFired: geomMeta.twigEventsFired ?? 0,
        meanScaffoldLen: geomMeta.meanScaffoldLen ?? 0,
        meanTwigLen: geomMeta.meanTwigLen ?? 0,
        classCounts: geomMeta.classCounts || {},
        classShares: geomMeta.classShares || {},
        grammarType: geomMeta.grammarType ?? 0,
        genCountByDepthBin: geomMeta.genCountByDepthBin || geomMeta.segGenCountByDepth || [],
        stepLenAvgByDepthBin: geomMeta.stepLenAvgByDepthBin || geomMeta.segGenAvgLenByDepth || [],
        keptCount: geomMeta.keptCount ?? sanitized.keptCount ?? segments.length,
        genCount: geomMeta.genCount ?? sanitized.genCount ?? segments.length,
        segKeptCountByDepth: geomMeta.segKeptCountByDepth || [],
        segKeptAvgLenByDepth: geomMeta.segKeptAvgLenByDepth || [],
        horizFrac: segStats.horizFrac,
        upFrac: segStats.upFrac,
        didDraw: true,
        rect: { x: cell.x, y: cell.y, w: cell.w, h: cell.h }
      };

      if (geomMeta.spawnReport && typeof window !== "undefined") {
        window.forestStats = window.forestStats || { blueprintBuilds: 0, drawCalls: 0, keystrokeRedraws: 0, regenCommits: 0, drawTreeCalls: 0, revealCalls: 0 };
        window.forestStats.v01SpawnReport = window.forestStats.v01SpawnReport || {};
        window.forestStats.v01SpawnReport[ck] = geomMeta.spawnReport;
      }
      didDrawByCourse[ck] = true;
    });

    lastForestGeom = { width: w, height: h, trees: [] };
    renderForestLegend(perCourse, courses, weekId);
  }

  function renderForestFrame(opts = {}) {
    if (FOREST_ENGINE !== "v01" && FOREST_ENGINE !== "legacy") {
      throw new Error("Unknown FOREST_ENGINE: " + FOREST_ENGINE);
    }
    if (FOREST_ENGINE === "v01") {
      return renderForestV01(opts);
    }
    return renderForest(opts);
  }

  let forestFastFramePending = false;
  function markForestDirty() {
    if (forestFastFramePending) return;
    forestFastFramePending = true;
    requestAnimationFrame(() => {
      forestFastFramePending = false;
      try {
        renderForestFrame({ allowRegen: false });
      } catch (err) {
        console.error("renderForest failed", err);
      }
    });
  }

  if (typeof window !== "undefined") {
    window.dumpV01SpawnHistogram = function dumpV01SpawnHistogram(courseKey = null) {
      const reportMap = window.forestStats?.v01SpawnReport || {};
      const keys = Object.keys(reportMap);
      if (!keys.length) {
        console.warn("[V01Spawn] no spawn report available (enable V01_DEBUG_SPAWN_HISTO and rerender)");
        return;
      }
      const list = courseKey ? [courseKey] : keys;
      list.forEach((ck) => {
        const rep = reportMap[ck];
        if (!rep) return;
        const total = rep.total || 0;
        const attempts = rep.attempts || 0;
        const bins = rep.bins || [];
        const rows = bins.map((count, i) => ({ bin: i, count, pct: total ? Number(((count / total) * 100).toFixed(1)) : 0 }));
        console.log("[V01Spawn] course", ck, { total, attempts, rejects: rep.rejects || {} });
        console.table(rows);
      });
    };

    window.dumpForestStateSizes = function dumpForestStateSizes() {
      const byteSize = (val) => {
        try {
          if (typeof Blob !== "undefined") return new Blob([String(val)]).size;
        } catch {}
        return String(val).length;
      };
      const keys = [];
      let total = 0;
      let forestTotal = 0;
      for (let i = 0; i < localStorage.length; i++) {
        const k = localStorage.key(i);
        if (!k) continue;
        const v = localStorage.getItem(k) || "";
        const sz = byteSize(v);
        total += sz;
        const isForest = k.includes("forest") || k.includes("semester_dashboard");
        if (isForest) forestTotal += sz;
        keys.push({ key: k, bytes: sz, forest: isForest });
      }
      keys.sort((a, b) => b.bytes - a.bytes);
      const forest = state?.forest || {};
      const v01Store = state?.forest?.v01 || null;
      const legacy = state?.forest?.legacy || {};
      const sizes = {
        localStorageTotalBytes: total,
        localStorageForestBytes: forestTotal,
        storageKeys: keys
      };
      const inMemory = {
        v01GeomCache: forestRuntime?.v01?.geomCache ? forestRuntime.v01.geomCache.size : 0,
        legacyGeomCache: forestRuntime?.legacy?.geomCache ? forestRuntime.legacy.geomCache.size : 0
      };
      const jsonSizes = {
        forestBytes: byteSize(JSON.stringify(forest)),
        legacyBytes: byteSize(JSON.stringify(legacy)),
        v01Bytes: v01Store ? byteSize(JSON.stringify(v01Store)) : 0
      };
      console.log("[ForestStateSizes]", { ...sizes, inMemory, jsonSizes });
      console.table(keys.filter(k => k.forest));
      return { ...sizes, inMemory, jsonSizes };
    };

    window.forestV01QA = function forestV01QA() {
      const rows = Object.values(lastScaleStats || {}).map((s) => {
        const segGen = s.genCount ?? s.segBefore ?? 0;
        const segKept = s.keptCount ?? s.segAfter ?? 0;
        const keepRatio = segGen > 0 ? (segKept / segGen) : 0;
        return {
          course: s.courseKey || s.course || "",
          segGen,
          segKept,
          keepRatio: Number(keepRatio.toFixed(3)),
          observedMaxDepth: s.observedMaxDepth ?? 0,
          classDepthMax: s.classDepthMax ?? 0,
          trunkSteps: `${s.trunkStepsUsed ?? 0}/${s.trunkStepsTotal ?? 0}`,
          scaffoldSteps: `${s.scaffoldStepsUsed ?? 0}/${s.scaffoldStepsTotal ?? 0}`,
          twigSteps: `${s.twigStepsUsed ?? 0}/${s.twigStepsTotal ?? 0}`,
          scaffoldBudget: s.scaffoldBudget ?? 0,
          twigBudget: s.twigBudget ?? 0,
          scaffoldEventsFired: s.scaffoldEventsFired ?? 0,
          twigEventsFired: s.twigEventsFired ?? 0,
          meanScaffoldLen: Number((s.meanScaffoldLen ?? 0).toFixed(1)),
          meanTwigLen: Number((s.meanTwigLen ?? 0).toFixed(1)),
          classCounts: JSON.stringify(s.classCounts || {}),
          classShares: JSON.stringify(s.classShares || {}),
          grammarType: s.grammarType ?? 0,
          branchSpawns: s.branchSpawns ?? 0,
          spawnBlocked: s.spawnBlocked ?? 0,
          occAppliedCount: s.occAppliedCount ?? 0,
          boundaryAppliedCount: s.boundaryAppliedCount ?? 0,
          redoTriggered: !!s.redoTriggered,
          densityCapApplied: !!s.densityCapApplied,
          sigLean: Number((s.sigLean ?? 0).toFixed(2)),
          sigCrownWidth: Number((s.sigCrownWidth ?? 0).toFixed(2)),
          sigTierSpacing: Number((s.sigTierSpacing ?? 0).toFixed(2)),
          sigTaper: Number((s.sigTaper ?? 0).toFixed(2))
        };
      });
      console.table(rows);
      const toggles = [
        window.V01_DEBUG_DISABLE_OCC ? "occ" : "",
        window.V01_DEBUG_DISABLE_TIER ? "tier" : "",
        window.V01_DEBUG_DISABLE_CONE ? "cone" : "",
        window.V01_DEBUG_DISABLE_DENSITYCAP ? "density" : "",
        window.V01_DEBUG_DISABLE_SANITIZE_REDO ? "redo" : ""
      ].filter(Boolean).join("|") || "none";
      console.log("[V01QA] toggles:", toggles);
      console.log("[V01QA] To isolate: set all V01_DEBUG_DISABLE_* = true; then re-enable one-by-one.");
      return rows;
    };
  }
  function renderForest(...args) {
    if (FOREST_ENGINE === "v01") {
      throw new Error("Legacy render blocked (FOREST_ENGINE=v01)");
    }
    return _renderForest_impl(...args);
  }

  function _renderForest_impl() {
    if (FOREST_ENGINE === "v01") {
      renderForestV01({ allowRegen: true });
      return;
    }
    if (!forestCanvas) return;
    const { ctx, w, h } = initCanvasHiDPI(forestCanvas, null, null, { willReadFrequently: true });
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = getCSSVar("--panel");
    ctx.fillRect(0, 0, w, h);
    lastScaleStats = {};

    const { perCourse, mode, weekId } = computeForestMetrics();
    const simulateMax = !!state.forest.simulateMax;
    const legacy = getLegacyForest();
    const courses = state.courses || [];
    if (!courses.length) {
      ctx.fillStyle = "#8b8c9b";
      ctx.font = "12px " + getCSSVar("--sans");
      ctx.textAlign = "center";
      ctx.fillText("No courses yet to render forest.", w / 2, h / 2);
      lastForestGeom = { width: w, height: h, trees: [] };
      renderForestLegend(perCourse, courses, weekId);
      return;
    }

    if (legacy.weekId !== weekId) {
      legacy.weekId = weekId;
      saveStateSoon();
      invalidateForestCaches();
    }

    const seedSalt = getUserSeedSalt();
    const weekStartKey = isoWeekStartKey(weekId);
    const dayKey = etDateKey();
    const flags = { simulateMax };
    const effortAbsByCourse = {};
    let effortTotal = 0;

    legacy.perCourseMax = legacy.perCourseMax || {};
    let maxChanged = false;
    courses.forEach((course) => {
      const cur = perCourse[course] || {};
      const max = legacy.perCourseMax[course] || {};
      const updateMax = (key, val) => {
        const v = val || 0;
        if ((max[key] || 0) < v) {
          max[key] = v;
          maxChanged = true;
        }
      };
      updateMax("words", cur.words);
      updateMax("recursion", cur.recursion);
      updateMax("abstraction", cur.abstraction);
      updateMax("cohesion", cur.cohesion);
      updateMax("argument", cur.argument);
      updateMax("diversity", cur.diversity);
      updateMax("tasks", cur.tasks);
      legacy.perCourseMax[course] = max;
    });
    if (maxChanged) saveStateSoon();

    const maxSource = simulateMax ? (legacy.perCourseMax || {}) : perCourse;
    const currentMax = {
      words: Math.max(1, ...Object.values(maxSource).map(m => m.words || 0)),
      recursion: Math.max(0.1, ...Object.values(maxSource).map(m => m.recursion || 0)),
      abstraction: Math.max(0.1, ...Object.values(maxSource).map(m => m.abstraction || 0)),
      cohesion: Math.max(0.1, ...Object.values(maxSource).map(m => m.cohesion || 0)),
      argument: Math.max(0.1, ...Object.values(maxSource).map(m => m.argument || 0)),
      diversity: Math.max(0.1, ...Object.values(maxSource).map(m => m.diversity || 0)),
      tasks: Math.max(1, ...Object.values(maxSource).map(m => m.tasks || 0))
    };

    const padL = 50;
    const padR = 50;
    const padT = 30;
    const padB = 70;
    const labelBand = 24;
    const baseY = clamp(h * 0.62, padT + 140, h - 140);
    const forestGeom = { width: w, height: h, trees: [], cells: [] };
    const cells = buildCourseCells(w, h, courses, padL, padR, padT, padB, labelBand);
    forestGeom.cells = cells;
    lastCourseCells = cells.map((cell, idx) => ({
      course: courses[idx],
      x: cell.x,
      y: cell.y,
      w: cell.w,
      h: cell.h + labelBand
    }));

    const courseSignals = {};
    const effectiveSignalsByCourse = {};
    courses.forEach((course) => {
      const metrics = perCourse[course] || { words: 0, recursion: 0, abstraction: 0, cohesion: 0, argument: 0, diversity: 0, tasks: 0, stress: 0 };
      const maxMetrics = (legacy.perCourseMax || {})[course] || {};
      const wordsN = clamp((metrics.words || 0) / currentMax.words, 0, 1);
      const recursionN = clamp((metrics.recursion || 0) / currentMax.recursion, 0, 1);
      const abstractionN = clamp((metrics.abstraction || 0) / currentMax.abstraction, 0, 1);
      const cohesionN = clamp((metrics.cohesion || 0) / currentMax.cohesion, 0, 1);
      const argumentN = clamp((metrics.argument || 0) / currentMax.argument, 0, 1);
      const diversityN = clamp((metrics.diversity || 0) / currentMax.diversity, 0, 1);
      const tasksN = clamp((metrics.tasks || 0) / currentMax.tasks, 0, 1);
      const weeklyScore = weeklyScoreForCourse(course, weekId);
      const weeklyScoreN = clamp(weeklyScore.score || 0, 0, 1);
      const weekendDone = state.weekendTasks.filter(t => t.course === course && t.done).length;
      const weekendTotal = Math.max(1, state.weekendTasks.filter(t => t.course === course).length);
      const weekendScoreN = clamp(weekendDone / weekendTotal, 0, 1);
      const writingDays = weeklyScore.sessions || 0;
      const baseSignals = {
        words: metrics.words || 0,
        recursion: metrics.recursion || 0,
        abstraction: metrics.abstraction || 0,
        cohesion: metrics.cohesion || 0,
        argument: metrics.argument || 0,
        diversity: metrics.diversity || 0,
        tasks: metrics.tasks || 0,
        stress: metrics.stress || 0,
        wordsN,
        recursionN,
        abstractionN,
        cohesionN,
        argumentN,
        diversityN,
        tasksN,
        weeklyScoreN,
        weekendScoreN,
        writingDays,
        maxWords: maxMetrics.words ?? metrics.words,
        maxRecursion: maxMetrics.recursion ?? metrics.recursion,
        maxAbstraction: maxMetrics.abstraction ?? metrics.abstraction,
        maxCohesion: maxMetrics.cohesion ?? metrics.cohesion,
        maxArgument: maxMetrics.argument ?? metrics.argument,
        maxDiversity: maxMetrics.diversity ?? metrics.diversity,
        maxTasks: maxMetrics.tasks ?? metrics.tasks
      };
      const effectiveSignals = getEffectiveCourseSignals(course, baseSignals, flags);
      const effortAbs = computeEffortAbs(effectiveSignals.tasks || 0, effectiveSignals.writingDays || 0, effectiveSignals.words || 0);
      effortAbsByCourse[course] = effortAbs;
      effortTotal += effortAbs;
      const growthInfo = getGrowthN(effectiveSignals);
      courseSignals[course] = {
        growthInfo,
        ...effectiveSignals,
        effortAbs
      };
      effectiveSignalsByCourse[course] = effectiveSignals;
    });
    const idleMode = effortTotal < IDLE_EPS;
    const growthRelByCourse = {};
    courses.forEach((course) => {
      if (simulateMax) {
        growthRelByCourse[course] = 1;
        return;
      }
      growthRelByCourse[course] = (idleMode || effortTotal <= 0)
        ? 0
        : clamp((effortAbsByCourse[course] || 0) / effortTotal, 0, 1);
    });
    const growthNorm = computeGrowthNormalization(courses, courseSignals);
    const growthRelFinalByCourse = {};
    courses.forEach((course) => {
      if (simulateMax) {
        growthRelFinalByCourse[course] = 1;
        return;
      }
      growthRelFinalByCourse[course] = growthNorm.flat
        ? (growthNorm.byCourseId.get(course)?.growthRel ?? 0)
        : (growthRelByCourse[course] ?? 0);
    });
    const normalizationSnapshot = {
      minRaw: growthNorm.minRaw,
      maxRaw: growthNorm.maxRaw,
      spread: (growthNorm.maxRaw - growthNorm.minRaw),
      effortTotal,
      idleMode,
      byCourse: {}
    };
    growthNorm.byCourseId.forEach((val, key) => {
      normalizationSnapshot.byCourse[key] = {
        rawGrowth: val.rawGrowth ?? 0,
        growthRel: growthRelFinalByCourse[key] ?? 0,
        effortAbs: effortAbsByCourse[key] ?? 0
      };
    });
    const courseMetricRows = [];

    if (focusMode !== "grid" && (!focusedCourse || !courses.includes(focusedCourse))) {
      focusMode = "grid";
      focusedCourse = null;
      updateFocusUi();
    }

    const isFocus = focusMode === "focus";
    const isHybrid = focusMode === "hybrid";
    const focusCourse = (isFocus || isHybrid) ? focusedCourse : null;
    if (!focusCourse && state.forest.showFullGhost) {
      const fullGhost = buildFullGhost(w, h, padL, padR, padT, baseY, perCourse, mode, weekId);
      fullGhost.trees.forEach((tree, idx) => {
        const bounds = computeGeomBounds(tree);
        const cell = cells[idx];
        if (!cell) return;
        const transform = fitBoundsToCell(bounds, cell, DEBUG_FOREST.cellPadding || 18);
        applyTransformToGeom(tree, transform);
      });
      drawGhostForest(ctx, w, h, padL, padR, baseY, fullGhost);
    } else if (!focusCourse) {
      drawGhostForest(ctx, w, h, padL, padR, baseY);
    }

    if (!focusCourse && DEBUG_FOREST.enabled && DEBUG_FOREST.showCells) {
      ctx.save();
      ctx.strokeStyle = "rgba(0,0,0,0.18)";
      ctx.setLineDash([6, 6]);
      cells.forEach((cell) => {
        ctx.strokeRect(cell.x, cell.y, cell.w, cell.h);
      });
      ctx.restore();
    }

    if (isFocus && focusCourse) {
      const idx = courses.indexOf(focusCourse);
      const cell = cells[idx];
      if (cell) {
        const metrics = perCourse[focusCourse] || { words: 0, recursion: 0, abstraction: 0, cohesion: 0, argument: 0, diversity: 0, tasks: 0, stress: 0 };
        const eff = effectiveSignalsByCourse[focusCourse] || {};
        const wordsN = eff.wordsN ?? 0;
        const recursionN = eff.recursionN ?? 0;
        const abstractionN = eff.abstractionN ?? 0;
        const cohesionN = eff.cohesionN ?? 0;
        const argumentN = eff.argumentN ?? 0;
        const diversityN = eff.diversityN ?? 0;
        const tasksN = eff.tasksN ?? 0;
        const stress = clamp(eff.stress ?? metrics.stress ?? 0, 0, 1);

        const growthEntry = growthNorm.byCourseId.get(focusCourse) || {};
        const growthRel = growthRelFinalByCourse[focusCourse] ?? 0;
        const sproutN = clamp(smoothstep(0.0, 0.18, growthRel), 0, 1);
        const isSprout = !simulateMax && growthRel < 0.18;
        const seedBase = `${focusCourse}|${weekStartKey}|${seedSalt}`;
        const effortAbs = effortAbsByCourse[focusCourse] || 0;
        const noteText = state.courseNotes?.[focusCourse]?.notes || "";
        const keywordCount = courseKeywords(focusCourse).size;
        const phraseCount = keyPhrases(noteText, 8).length;
        const conceptN = clamp((keywordCount / 12 + phraseCount / 6 + cohesionN) / 3, 0, 1);

        const weeklyScoreN = eff.weeklyScoreN ?? 0;
        const weekendScoreN = eff.weekendScoreN ?? 0;

        const isGcas = /gcas/i.test(focusCourse);
        const heightScale = isGcas ? 1 : 0.7;
        const canopyBoost = isGcas ? 1 : 1.2;
        const maxHeight = Math.max(40, baseY - padT - 70);
        const height = Math.min(
          maxHeight * 0.6 * heightScale,
          (12 + 40 * weeklyScoreN + 16 * (wordsN * weeklyScoreN) + 10 * (tasksN * weeklyScoreN)) * heightScale
        );
        const complexityN = clamp((wordsN + recursionN + abstractionN + cohesionN + argumentN + diversityN + weeklyScoreN) / 7, 0, 1);
        const leaves = weekendScoreN > 0
          ? clamp(0.4 + 1.6 * weekendScoreN * canopyBoost + 0.8 * abstractionN * weeklyScoreN + 0.3 * mode.weeklyRatio * weeklyScoreN, 0.3, 3.2)
          : 0;
        const dayLight = clamp(0.45 + 0.7 * mode.dailyRatio, 0.3, 1.1);
        const x0 = cell.x + cell.w * 0.5;

        const focusKey = getGeomCacheKey(focusCourse, flags, eff, growthRel, weekId, dayKey, "focus", seedSalt);
        let treeGeom = geomCache.get(focusKey);
        if (!treeGeom) {
          treeGeom = drawTree(ctx, {
            x0,
            baseY,
            height,
            trunkW: 0.4 + 1.4 * argumentN,
            branchiness: 0,
            leaves,
            crownSpread: 0,
            stress,
            padT,
            padL,
            padR,
            w,
            dayLight,
            recursionN,
            abstractionN,
            cohesionN,
            argumentN,
            diversityN,
            tasksN,
            wordsN,
            conceptN,
            weeklyScoreN,
            weekendScoreN,
            noteText,
            recursion: eff.recursion ?? metrics.recursion ?? 0,
            abstraction: eff.abstraction ?? metrics.abstraction ?? 0,
            cohesion: eff.cohesion ?? metrics.cohesion ?? 0,
            argument: eff.argument ?? metrics.argument ?? 0,
            diversity: eff.diversity ?? metrics.diversity ?? 0,
            complexityN,
            seedKey: seedBase,
            course: focusCourse,
            mode,
            captureOnly: true,
            courseId: focusCourse,
            debug: DEBUG_FOREST,
            growthRel,
            effortAbs,
            effortTotal,
            idleMode,
            sproutN,
            isSprout
          });
          geomCache.set(focusKey, treeGeom);
        }

        const bounds = computeGeomBounds(treeGeom);
        const trunkMetrics = treeGeom.trunkMetrics || {};
        const morphStats = treeGeom.morphStats || {};
        const focusCell = { x: padL, y: padT, w: w - padL - padR, h: h - padT - padB - labelBand };
        const growthInfo = growthEntry.growthInfo || getGrowthN({});
        const growthN = growthInfo.value;
        const rel = growthEntry.rel ?? 0;
        const targetFrac = targetFracForGrowth(growthRel, idleMode);
        const availH = Math.max(1, focusCell.h - 16 - 10);
        const targetH = availH * targetFrac;
        const yScaleRaw = targetH / Math.max(1e-6, bounds.height);
        const xScaleCap = (0.92 * focusCell.w) / Math.max(1e-6, bounds.width);
        const minS = 0.9;
        const maxS = 6.5;
        const widthLimited = yScaleRaw > xScaleCap;
        const xScale = clamp(Math.min(yScaleRaw, xScaleCap), minS, maxS);
        const yScale = xScale;
        const appliedAniso = 1;
        lastScaleStats[focusCourse] = {
          course: focusCourse,
          growthN,
          rel,
          growthRel,
          minRaw: growthNorm.minRaw,
          maxRaw: growthNorm.maxRaw,
          rawGrowth: growthInfo.rawGrowth,
          weekly: growthInfo.weekly,
          tasksTerm: growthInfo.tasksTerm,
          wordsTerm: growthInfo.wordsTerm,
          recursion: growthInfo.recursion,
          cohesion: growthInfo.cohesion,
          trunkBudgetSteps: trunkMetrics.trunkBudgetSteps,
          trunkStep: trunkMetrics.trunkStep,
          trunkLenMult: trunkMetrics.trunkLenMult,
          effortAbs,
          effortTotal,
          idleMode: !!idleMode,
          isSprout,
          sproutN,
          desiredPx: Math.min(STROKE_BASE_PX, isSprout ? 0.9 : 1.6),
          recDepth: morphStats.recDepth,
        branchProb: morphStats.branchProb,
        clusterProb: morphStats.clusterProb,
        segmentsDrawn: morphStats.segmentsDrawn,
        branchEvents: morphStats.branchEvents,
        flatNorm: !!growthNorm.flat,
        normRange: growthNorm.range,
        normMode: growthNorm.flat ? "absolute-fallback" : "relative",
        targetFrac,
          availH,
          bboxH: bounds.height,
          targetH,
          yScaleRaw,
          xScale,
          yScale,
          appliedAniso,
          widthLimited,
          anchorX: bounds.minX + bounds.width / 2,
          anchorY: bounds.maxY,
          targetX: focusCell.x + focusCell.w * 0.5,
          targetY: focusCell.y + focusCell.h - 10,
          scaleFinal: Math.min(xScale, yScale),
          widthCapScale: xScaleCap
        };
      courseMetricRows.push({
        name: focusCourse,
        rawGrowth: growthInfo.rawGrowth,
        growthRel,
        targetFrac,
        targetH,
        availH,
        bbox: { w: bounds.width, h: bounds.height },
        scale: {
          yScaleRaw,
          widthCapScale: xScaleCap,
          xScale,
          yScale,
          appliedAniso,
          widthLimited,
          scaleFinal: Math.min(xScale, yScale)
        },
        trunk: {
          trunkBudgetSteps: trunkMetrics.trunkBudgetSteps,
          trunkStep: trunkMetrics.trunkStep,
          trunkLenMult: trunkMetrics.trunkLenMult
        }
      });
        if (DEBUG_SCALE) {
          console.log("focus-scale", {
            course: focusCourse,
            growthN,
            bboxH: bounds.height,
            targetH,
            scaleRaw,
            scaleFinal: scale
          });
        }
        const anchorX = bounds.minX + bounds.width / 2;
        const anchorY = bounds.maxY;
        const targetX = focusCell.x + focusCell.w * 0.5;
        const targetY = focusCell.y + focusCell.h - 10;

        ctx.save();
        try {
          ctx.translate(targetX, targetY);
          ctx.scale(xScale, yScale);
          ctx.translate(-anchorX, -anchorY);
          if (state.forest.showFullGhost) {
            const prevGeom = prevGeomByKey.get(focusKey);
            if (prevGeom) {
              ctx.save();
              ctx.globalAlpha = 0.12;
              renderGeom(ctx, prevGeom, xScale, yScale);
              ctx.restore();
            }
          }
          renderGeom(ctx, treeGeom, xScale, yScale);
          renderLeaves(ctx, treeGeom, treeGeom.seedKey || `${weekId}|${focusCourse}`, treeGeom.leafSettings);
          if (DEBUG_FOREST.showBBoxes) {
            ctx.save();
            ctx.strokeStyle = "rgba(0,0,0,0.35)";
            ctx.setLineDash([4, 4]);
            ctx.strokeRect(bounds.minX, bounds.minY, bounds.width, bounds.height);
            ctx.restore();
          }
        } finally {
          ctx.restore();
        }

        prevGeomByKey.set(focusKey, treeGeom);
        forestGeom.trees.push(treeGeom);
      }

      const topByGrowthRel = courseMetricRows
        .slice()
        .sort((a, b) => (b.growthRel || 0) - (a.growthRel || 0))
        .slice(0, 3)
        .map((c) => ({ name: c.name, growthRel: c.growthRel }));
      const topByScaleFinal = courseMetricRows
        .slice()
        .sort((a, b) => (b.scale?.scaleFinal || 0) - (a.scale?.scaleFinal || 0))
        .slice(0, 3)
        .map((c) => ({ name: c.name, scaleFinal: c.scale?.scaleFinal || 0 }));

      MetricsReporter.report({
        mode: focusMode,
        selectedCourse: focusCourse || null,
        canvas: { w: forestCanvas.width, h: forestCanvas.height },
        normalization: normalizationSnapshot,
        courses: courseMetricRows,
        top: { byGrowthRel: topByGrowthRel, byScaleFinal: topByScaleFinal }
      });

      applyOrderedDither(ctx, w, h, 0.035);
      lastForestGeom = forestGeom;
      renderForestLegend(perCourse, courses, weekId);
      renderScaleDebug(focusCourse);
      return;
    }

    if (isHybrid && focusCourse) {
      const thumbStripH = clamp(Math.round(h * 0.22), 80, 160);
      const stripY = h - padB - thumbStripH;
      const mainCell = {
        x: padL,
        y: padT,
        w: w - padL - padR,
        h: Math.max(1, stripY - padT)
      };
      lastCourseCells = [{
        course: focusCourse,
        x: mainCell.x,
        y: mainCell.y,
        w: mainCell.w,
        h: mainCell.h
      }];

      const metrics = perCourse[focusCourse] || { words: 0, recursion: 0, abstraction: 0, cohesion: 0, argument: 0, diversity: 0, tasks: 0, stress: 0 };
      const eff = effectiveSignalsByCourse[focusCourse] || {};
      const wordsN = eff.wordsN ?? 0;
      const recursionN = eff.recursionN ?? 0;
      const abstractionN = eff.abstractionN ?? 0;
      const cohesionN = eff.cohesionN ?? 0;
      const argumentN = eff.argumentN ?? 0;
      const diversityN = eff.diversityN ?? 0;
      const tasksN = eff.tasksN ?? 0;
      const stress = clamp(eff.stress ?? metrics.stress ?? 0, 0, 1);

      const growthEntry = growthNorm.byCourseId.get(focusCourse) || {};
      const growthRel = growthRelFinalByCourse[focusCourse] ?? 0;
      const sproutN = clamp(smoothstep(0.0, 0.18, growthRel), 0, 1);
      const isSprout = !simulateMax && growthRel < 0.18;
      const seedBase = `${focusCourse}|${weekStartKey}|${seedSalt}`;
      const effortAbs = effortAbsByCourse[focusCourse] || 0;
      const noteText = state.courseNotes?.[focusCourse]?.notes || "";
      const keywordCount = courseKeywords(focusCourse).size;
      const phraseCount = keyPhrases(noteText, 8).length;
      const conceptN = clamp((keywordCount / 12 + phraseCount / 6 + cohesionN) / 3, 0, 1);

      const weeklyScoreN = eff.weeklyScoreN ?? 0;
      const weekendScoreN = eff.weekendScoreN ?? 0;

      const isGcas = /gcas/i.test(focusCourse);
      const heightScale = isGcas ? 1 : 0.7;
      const canopyBoost = isGcas ? 1 : 1.2;
      const maxHeight = Math.max(40, baseY - padT - 70);
      const height = Math.min(
        maxHeight * 0.6 * heightScale,
        (12 + 40 * weeklyScoreN + 16 * (wordsN * weeklyScoreN) + 10 * (tasksN * weeklyScoreN)) * heightScale
      );
      const complexityN = clamp((wordsN + recursionN + abstractionN + cohesionN + argumentN + diversityN + weeklyScoreN) / 7, 0, 1);
      const leaves = weekendScoreN > 0
        ? clamp(0.4 + 1.6 * weekendScoreN * canopyBoost + 0.8 * abstractionN * weeklyScoreN + 0.3 * mode.weeklyRatio * weeklyScoreN, 0.3, 3.2)
        : 0;
      const dayLight = clamp(0.45 + 0.7 * mode.dailyRatio, 0.3, 1.1);
      const x0 = mainCell.x + mainCell.w * 0.5;

      const mainKey = getGeomCacheKey(focusCourse, flags, eff, growthRel, weekId, dayKey, "hybrid-main", seedSalt);
      let treeGeom = geomCache.get(mainKey);
      if (!treeGeom) {
        treeGeom = drawTree(ctx, {
          x0,
          baseY,
          height,
          trunkW: 0.4 + 1.4 * argumentN,
          branchiness: 0,
          leaves,
          crownSpread: 0,
          stress,
          padT,
          padL,
          padR,
          w,
          dayLight,
          recursionN,
          abstractionN,
          cohesionN,
          argumentN,
          diversityN,
          tasksN,
          wordsN,
          conceptN,
          weeklyScoreN,
          weekendScoreN,
          noteText,
          recursion: eff.recursion ?? metrics.recursion ?? 0,
          abstraction: eff.abstraction ?? metrics.abstraction ?? 0,
          cohesion: eff.cohesion ?? metrics.cohesion ?? 0,
          argument: eff.argument ?? metrics.argument ?? 0,
          diversity: eff.diversity ?? metrics.diversity ?? 0,
          complexityN,
          seedKey: seedBase,
          course: focusCourse,
          mode,
          captureOnly: true,
          courseId: focusCourse,
          debug: DEBUG_FOREST,
          growthRel,
          effortAbs,
          effortTotal,
          idleMode,
          sproutN,
          isSprout
        });
        geomCache.set(mainKey, treeGeom);
      }
      const bounds = computeGeomBounds(treeGeom);
      const trunkMetrics = treeGeom.trunkMetrics || {};
      const morphStats = treeGeom.morphStats || {};
      const growthInfo = growthEntry.growthInfo || getGrowthN({});
      const growthN = growthInfo.value;
      const rel = growthEntry.rel ?? 0;
      const targetFrac = targetFracForGrowth(growthRel, idleMode);
      const availH = Math.max(1, mainCell.h - 16 - 10);
      const targetH = availH * targetFrac;
      const yScaleRaw = targetH / Math.max(1e-6, bounds.height);
      const xScaleCap = (0.92 * mainCell.w) / Math.max(1e-6, bounds.width);
      const minS = 0.9;
      const maxS = 6.5;
      const widthLimited = yScaleRaw > xScaleCap;
      const xScale = clamp(Math.min(yScaleRaw, xScaleCap), minS, maxS);
      const yScale = xScale;
      const appliedAniso = 1;
      lastScaleStats[focusCourse] = {
        course: focusCourse,
        growthN,
        rel,
        growthRel,
        minRaw: growthNorm.minRaw,
        maxRaw: growthNorm.maxRaw,
        rawGrowth: growthInfo.rawGrowth,
        weekly: growthInfo.weekly,
        tasksTerm: growthInfo.tasksTerm,
        wordsTerm: growthInfo.wordsTerm,
        recursion: growthInfo.recursion,
        cohesion: growthInfo.cohesion,
        trunkBudgetSteps: trunkMetrics.trunkBudgetSteps,
        trunkStep: trunkMetrics.trunkStep,
        trunkLenMult: trunkMetrics.trunkLenMult,
        effortAbs,
        effortTotal,
        idleMode: !!idleMode,
        isSprout,
        sproutN,
        desiredPx: Math.min(STROKE_BASE_PX, isSprout ? 0.9 : 1.6),
        recDepth: morphStats.recDepth,
        branchProb: morphStats.branchProb,
        clusterProb: morphStats.clusterProb,
        segmentsDrawn: morphStats.segmentsDrawn,
        branchEvents: morphStats.branchEvents,
        flatNorm: !!growthNorm.flat,
        normRange: growthNorm.range,
        normMode: growthNorm.flat ? "absolute-fallback" : "relative",
        targetFrac,
        availH,
        bboxH: bounds.height,
        targetH,
        yScaleRaw,
        xScale,
        yScale,
        appliedAniso,
        widthLimited,
        anchorX: bounds.minX + bounds.width / 2,
        anchorY: bounds.maxY,
        targetX: mainCell.x + mainCell.w * 0.5,
        targetY: mainCell.y + mainCell.h - 10,
        scaleFinal: Math.min(xScale, yScale),
        widthCapScale: xScaleCap
      };
      courseMetricRows.push({
        name: focusCourse,
        rawGrowth: growthInfo.rawGrowth,
        growthRel,
        targetFrac,
        targetH,
        availH,
        bbox: { w: bounds.width, h: bounds.height },
        scale: {
          yScaleRaw,
          widthCapScale: xScaleCap,
          xScale,
          yScale,
          appliedAniso,
          widthLimited,
          scaleFinal: Math.min(xScale, yScale)
        },
        trunk: {
          trunkBudgetSteps: trunkMetrics.trunkBudgetSteps,
          trunkStep: trunkMetrics.trunkStep,
          trunkLenMult: trunkMetrics.trunkLenMult
        }
      });
      if (DEBUG_SCALE) {
        console.log("hybrid-scale", {
          course: focusCourse,
          growthN,
          bboxH: bounds.height,
          targetH,
          scaleRaw,
          scaleFinal: scale
        });
      }
      const anchorX = bounds.minX + bounds.width / 2;
      const anchorY = bounds.maxY;
      const targetX = mainCell.x + mainCell.w * 0.5;
      const targetY = mainCell.y + mainCell.h - 10;

      ctx.save();
      try {
        ctx.translate(targetX, targetY);
        ctx.scale(xScale, yScale);
        ctx.translate(-anchorX, -anchorY);
        if (state.forest.showFullGhost) {
          const prevGeom = prevGeomByKey.get(mainKey);
          if (prevGeom) {
            ctx.save();
            ctx.globalAlpha = 0.12;
            renderGeom(ctx, prevGeom, xScale, yScale);
            ctx.restore();
          }
        }
        renderGeom(ctx, treeGeom, xScale, yScale);
        renderLeaves(ctx, treeGeom, treeGeom.seedKey || `${weekId}|${focusCourse}`, treeGeom.leafSettings);
        if (DEBUG_FOREST.showBBoxes) {
          ctx.save();
          ctx.strokeStyle = "rgba(0,0,0,0.35)";
          ctx.setLineDash([4, 4]);
          ctx.strokeRect(bounds.minX, bounds.minY, bounds.width, bounds.height);
          ctx.restore();
        }
      } finally {
        ctx.restore();
      }

      prevGeomByKey.set(mainKey, treeGeom);
      forestGeom.trees.push(treeGeom);

      const others = courses.filter(c => c !== focusCourse);
      const thumbCount = Math.max(1, others.length);
      const thumbW = (w - padL - padR) / thumbCount;
      others.forEach((course, i) => {
        const cell = {
          x: padL + i * thumbW,
          y: stripY,
          w: thumbW,
          h: thumbStripH
        };
        lastCourseCells.push({
          course,
          x: cell.x,
          y: cell.y,
          w: cell.w,
          h: cell.h
        });
        const metrics = perCourse[course] || { words: 0, recursion: 0, abstraction: 0, cohesion: 0, argument: 0, diversity: 0, tasks: 0, stress: 0 };
        const eff = effectiveSignalsByCourse[course] || {};
        const wordsN = eff.wordsN ?? 0;
        const recursionN = eff.recursionN ?? 0;
        const abstractionN = eff.abstractionN ?? 0;
        const cohesionN = eff.cohesionN ?? 0;
        const argumentN = eff.argumentN ?? 0;
        const diversityN = eff.diversityN ?? 0;
        const tasksN = eff.tasksN ?? 0;
        const stress = clamp(eff.stress ?? metrics.stress ?? 0, 0, 1);

        const noteText = state.courseNotes?.[course]?.notes || "";
        const seedBase = `${course}|${weekStartKey}|${seedSalt}`;
        const effortAbs = effortAbsByCourse[course] || 0;
        const sproutN = clamp(smoothstep(0.0, 0.18, growthRelFinalByCourse[course] ?? 0), 0, 1);
        const isSprout = !simulateMax && (growthRelFinalByCourse[course] ?? 0) < 0.18;
        const keywordCount = courseKeywords(course).size;
        const phraseCount = keyPhrases(noteText, 8).length;
        const conceptN = clamp((keywordCount / 12 + phraseCount / 6 + cohesionN) / 3, 0, 1);

        const weeklyScoreN = eff.weeklyScoreN ?? 0;
        const weekendScoreN = eff.weekendScoreN ?? 0;

        const isGcas = /gcas/i.test(course);
        const heightScale = isGcas ? 1 : 0.7;
        const canopyBoost = isGcas ? 1 : 1.2;
        const maxHeight = Math.max(40, baseY - padT - 70);
        const height = Math.min(
          maxHeight * 0.6 * heightScale,
          (12 + 40 * weeklyScoreN + 16 * (wordsN * weeklyScoreN) + 10 * (tasksN * weeklyScoreN)) * heightScale
        );
        const complexityN = clamp((wordsN + recursionN + abstractionN + cohesionN + argumentN + diversityN + weeklyScoreN) / 7, 0, 1);
        const leaves = weekendScoreN > 0
          ? clamp(0.4 + 1.6 * weekendScoreN * canopyBoost + 0.8 * abstractionN * weeklyScoreN + 0.3 * mode.weeklyRatio * weeklyScoreN, 0.3, 3.2)
          : 0;
        const dayLight = clamp(0.45 + 0.7 * mode.dailyRatio, 0.3, 1.1);
        const x0 = cell.x + cell.w * 0.5;

        const growthRel = growthRelFinalByCourse[course] ?? 0;
        const thumbKey = getGeomCacheKey(course, flags, eff, growthRel, weekId, dayKey, "hybrid-thumb", seedSalt);
        let treeGeom = geomCache.get(thumbKey);
        if (!treeGeom) {
          treeGeom = drawTree(ctx, {
            x0,
            baseY,
            height,
            trunkW: 0.4 + 1.4 * argumentN,
            branchiness: 0,
            leaves,
            crownSpread: 0,
            stress,
            padT,
            padL,
            padR,
            w,
            dayLight,
            recursionN,
            abstractionN,
            cohesionN,
            argumentN,
            diversityN,
            tasksN,
            wordsN,
            conceptN,
            weeklyScoreN,
            weekendScoreN,
            noteText,
            recursion: eff.recursion ?? metrics.recursion ?? 0,
            abstraction: eff.abstraction ?? metrics.abstraction ?? 0,
            cohesion: eff.cohesion ?? metrics.cohesion ?? 0,
            argument: eff.argument ?? metrics.argument ?? 0,
            diversity: eff.diversity ?? metrics.diversity ?? 0,
            complexityN,
            seedKey: seedBase,
            course,
            mode,
            captureOnly: true,
            courseId: course,
            debug: DEBUG_FOREST,
            growthRel,
            effortAbs,
            effortTotal,
            idleMode,
            sproutN,
            isSprout
          });
          geomCache.set(thumbKey, treeGeom);
        }

        const bounds = computeGeomBounds(treeGeom);
        const growthEntry = growthNorm.byCourseId.get(course) || {};
        const growthInfo = growthEntry.growthInfo || getGrowthN({});
        const targetFrac = targetFracForGrowth(growthRel, idleMode);
        const availH = Math.max(1, cell.h - 16 - 10);
        const targetH = availH * targetFrac;
        const yScaleRaw = targetH / Math.max(1e-6, bounds.height);
        const xScaleCap = (0.92 * cell.w) / Math.max(1e-6, bounds.width);
        const thumbBaseScale = clamp(Math.min(yScaleRaw, xScaleCap), 0.5, 3.0);
        const thumbScale = clamp(thumbBaseScale * (0.7 + 0.3 * growthRel), 0.4, 3.0);

        ctx.save();
        try {
          ctx.globalAlpha = 0.16;
          const anchorX = bounds.minX + bounds.width / 2;
          const anchorY = bounds.maxY;
          const targetX = cell.x + cell.w * 0.5;
          const targetY = cell.y + cell.h - 10;
          if (state.forest.showFullGhost) {
            const prevGeom = prevGeomByKey.get(thumbKey);
            if (prevGeom) {
              ctx.save();
              ctx.globalAlpha = 0.08;
              ctx.translate(targetX, targetY);
              ctx.scale(thumbScale, thumbScale);
              ctx.translate(-anchorX, -anchorY);
              renderGeom(ctx, prevGeom, thumbScale, thumbScale);
              ctx.restore();
            }
          }
          ctx.translate(targetX, targetY);
          ctx.scale(thumbScale, thumbScale);
          ctx.translate(-anchorX, -anchorY);
          renderGeom(ctx, treeGeom, thumbScale, thumbScale);
          if (DEBUG_FOREST.showBBoxes) {
            ctx.save();
            ctx.strokeStyle = "rgba(0,0,0,0.25)";
            ctx.setLineDash([4, 4]);
            ctx.strokeRect(cell.x, cell.y, cell.w, cell.h);
            ctx.restore();
          }
        } finally {
          ctx.restore();
        }
        prevGeomByKey.set(thumbKey, treeGeom);
        forestGeom.trees.push(treeGeom);
        courseMetricRows.push({
          name: course,
          rawGrowth: growthInfo.rawGrowth,
          growthRel,
          targetFrac,
          targetH,
          availH,
          bbox: { w: bounds.width, h: bounds.height },
          scale: {
            yScaleRaw,
            widthCapScale: xScaleCap,
            scaleFinal: thumbScale
          }
        });
      });

      const topByGrowthRel = courseMetricRows
        .slice()
        .sort((a, b) => (b.growthRel || 0) - (a.growthRel || 0))
        .slice(0, 3)
        .map((c) => ({ name: c.name, growthRel: c.growthRel }));
      const topByScaleFinal = courseMetricRows
        .slice()
        .sort((a, b) => (b.scale?.scaleFinal || 0) - (a.scale?.scaleFinal || 0))
        .slice(0, 3)
        .map((c) => ({ name: c.name, scaleFinal: c.scale?.scaleFinal || 0 }));

      MetricsReporter.report({
        mode: focusMode,
        selectedCourse: focusCourse || null,
        canvas: { w: forestCanvas.width, h: forestCanvas.height },
        normalization: normalizationSnapshot,
        courses: courseMetricRows,
        top: { byGrowthRel: topByGrowthRel, byScaleFinal: topByScaleFinal }
      });

      applyOrderedDither(ctx, w, h, 0.035);
      lastForestGeom = forestGeom;
      renderForestLegend(perCourse, courses, weekId);
      renderScaleDebug(focusCourse);
      return;
    }

    courses.forEach((course, idx) => {
      const cell = cells[idx];
      const x0 = cell ? (cell.x + cell.w * 0.5) : (w / (courses.length + 1)) * (idx + 1);
      const metrics = perCourse[course] || { words: 0, recursion: 0, abstraction: 0, cohesion: 0, argument: 0, diversity: 0, tasks: 0, stress: 0 };
      const eff = effectiveSignalsByCourse[course] || {};
      const wordsN = eff.wordsN ?? 0;
      const recursionN = eff.recursionN ?? 0;
      const abstractionN = eff.abstractionN ?? 0;
      const cohesionN = eff.cohesionN ?? 0;
      const argumentN = eff.argumentN ?? 0;
      const diversityN = eff.diversityN ?? 0;
      const tasksN = eff.tasksN ?? 0;
      const stress = clamp(eff.stress ?? metrics.stress ?? 0, 0, 1);

      const noteText = state.courseNotes?.[course]?.notes || "";
      const seedBase = `${course}|${weekStartKey}|${seedSalt}`;
      const effortAbs = effortAbsByCourse[course] || 0;
      const keywordCount = courseKeywords(course).size;
      const phraseCount = keyPhrases(noteText, 8).length;
      const conceptN = clamp((keywordCount / 12 + phraseCount / 6 + cohesionN) / 3, 0, 1);

      const weeklyScoreN = eff.weeklyScoreN ?? 0;
      const weekendScoreN = eff.weekendScoreN ?? 0;

      const isGcas = /gcas/i.test(course);
      const heightScale = isGcas ? 1 : 0.7;
      const canopyBoost = isGcas ? 1 : 1.2;
      const maxHeight = Math.max(40, baseY - padT - 70);
      const height = Math.min(
        maxHeight * 0.6 * heightScale,
        (12 + 40 * weeklyScoreN + 16 * (wordsN * weeklyScoreN) + 10 * (tasksN * weeklyScoreN)) * heightScale
      );
      const complexityN = clamp((wordsN + recursionN + abstractionN + cohesionN + argumentN + diversityN + weeklyScoreN) / 7, 0, 1);
      const branchiness = clamp(0.25 + 0.9 * recursionN * weeklyScoreN + 0.2 * tasksN * weeklyScoreN, 0.2, 1.8);
      const leaves = weekendScoreN > 0
        ? clamp(0.4 + 1.6 * weekendScoreN * canopyBoost + 0.8 * abstractionN * weeklyScoreN + 0.3 * mode.weeklyRatio * weeklyScoreN, 0.3, 3.2)
        : 0;
      const crownSpread = clamp(1.0 + 1.4 * weekendScoreN * canopyBoost + 0.7 * abstractionN, 1.0, 4.0);
      const dayLight = clamp(0.45 + 0.7 * mode.dailyRatio, 0.3, 1.1);
      const growthEntry = growthNorm.byCourseId.get(course) || {};
      const growthInfo = growthEntry.growthInfo || getGrowthN({});
      const growthN = growthInfo.value;
      const growthRel = growthRelFinalByCourse[course] ?? 0;
      const sproutN = clamp(smoothstep(0.0, 0.18, growthRel), 0, 1);
      const isSprout = !simulateMax && growthRel < 0.18;
      const rel = growthEntry.rel ?? 0;

      const gridKey = getGeomCacheKey(course, flags, eff, growthRel, weekId, dayKey, "grid", seedSalt);
      let treeGeom = geomCache.get(gridKey);
      if (!treeGeom) {
        treeGeom = drawTree(ctx, {
          x0,
          baseY,
          height,
          trunkW: 0.4 + 1.4 * argumentN,
          branchiness,
          leaves,
          crownSpread,
          stress,
          padT,
          padL,
          padR,
          w,
          dayLight,
          recursionN,
          abstractionN,
          cohesionN,
          argumentN,
          diversityN,
          tasksN,
          wordsN,
          conceptN,
          weeklyScoreN,
          weekendScoreN,
          noteText,
          recursion: eff.recursion ?? metrics.recursion ?? 0,
          abstraction: eff.abstraction ?? metrics.abstraction ?? 0,
          cohesion: eff.cohesion ?? metrics.cohesion ?? 0,
          argument: eff.argument ?? metrics.argument ?? 0,
          diversity: eff.diversity ?? metrics.diversity ?? 0,
          complexityN,
          seedKey: seedBase,
          course,
          mode,
          captureOnly: true,
          courseId: course,
          debug: DEBUG_FOREST,
          growthRel,
          effortAbs,
          effortTotal,
          idleMode,
          sproutN,
          isSprout
        });
        geomCache.set(gridKey, treeGeom);
      }

      if (!cell) return;
      treeGeom.courseId = course;
      const trunkMetrics = treeGeom.trunkMetrics || {};
      const morphStats = treeGeom.morphStats || {};
      const bounds = computeGeomBounds(treeGeom);
      treeGeom.bounds = bounds;
      treeGeom.cell = cell;

      const targetFrac = targetFracForGrowth(growthRel, idleMode);
      const availH = Math.max(1, cell.h - 16 - 10);
      const targetH = availH * targetFrac;
      const yScaleRaw = targetH / Math.max(1e-6, bounds.height);
      const xScaleCap = (0.92 * cell.w) / Math.max(1e-6, bounds.width);
      const minS = 0.7;
      const maxS = 3.4;
      const widthLimited = yScaleRaw > xScaleCap;
      const xScale = clamp(Math.min(yScaleRaw, xScaleCap), minS, maxS);
      const yScale = xScale;
      const appliedAniso = 1;
      const scaleFinal = Math.min(xScale, yScale);
      lastScaleStats[course] = {
        course,
        growthN,
        rel,
        growthRel,
        minRaw: growthNorm.minRaw,
        maxRaw: growthNorm.maxRaw,
        rawGrowth: growthInfo.rawGrowth,
        weekly: growthInfo.weekly,
        tasksTerm: growthInfo.tasksTerm,
        wordsTerm: growthInfo.wordsTerm,
        recursion: growthInfo.recursion,
        cohesion: growthInfo.cohesion,
        trunkBudgetSteps: trunkMetrics.trunkBudgetSteps,
        trunkStep: trunkMetrics.trunkStep,
        trunkLenMult: trunkMetrics.trunkLenMult,
        effortAbs,
        effortTotal,
        idleMode: !!idleMode,
        isSprout,
        sproutN,
        desiredPx: Math.min(STROKE_BASE_PX, isSprout ? 0.9 : 1.6),
        recDepth: morphStats.recDepth,
        branchProb: morphStats.branchProb,
        clusterProb: morphStats.clusterProb,
        segmentsDrawn: morphStats.segmentsDrawn,
        branchEvents: morphStats.branchEvents,
        flatNorm: !!growthNorm.flat,
        normRange: growthNorm.range,
        normMode: growthNorm.flat ? "absolute-fallback" : "relative",
        targetFrac,
        availH,
        bboxH: bounds.height,
        targetH,
        yScaleRaw,
        xScale,
        yScale,
        appliedAniso,
        widthLimited,
        anchorX: bounds.minX + bounds.width / 2,
        anchorY: bounds.maxY,
        targetX: cell.x + cell.w * 0.5,
        targetY: cell.y + cell.h - 10,
        scaleFinal,
        widthCapScale: xScaleCap
      };
      courseMetricRows.push({
        name: course,
        rawGrowth: growthInfo.rawGrowth,
        growthRel,
        targetFrac,
        targetH,
        availH,
        bbox: { w: bounds.width, h: bounds.height },
        scale: {
          yScaleRaw,
          widthCapScale: xScaleCap,
          xScale,
          yScale,
          appliedAniso,
          widthLimited,
          scaleFinal
        },
        trunk: {
          trunkBudgetSteps: trunkMetrics.trunkBudgetSteps,
          trunkStep: trunkMetrics.trunkStep,
          trunkLenMult: trunkMetrics.trunkLenMult
        }
      });
      if (DEBUG_SCALE) {
        console.log("grid-scale", {
          course,
          growthN,
          bboxH: bounds.height,
          targetH,
          scaleRaw,
          scaleFinal
        });
      }

      const anchorX = bounds.minX + bounds.width / 2;
      const anchorY = bounds.maxY;
      const targetX = cell.x + cell.w * 0.5;
      const targetY = cell.y + cell.h - 10;
      ctx.save();
      try {
        ctx.translate(targetX, targetY);
        ctx.scale(xScale, yScale);
        ctx.translate(-anchorX, -anchorY);
        if (state.forest.showFullGhost) {
          const prevGeom = prevGeomByKey.get(gridKey);
          if (prevGeom) {
            ctx.save();
            ctx.globalAlpha = 0.12;
            renderGeom(ctx, prevGeom, xScale, yScale);
            ctx.restore();
          }
        }
        renderGeom(ctx, treeGeom, xScale, yScale);
        renderLeaves(ctx, treeGeom, treeGeom.seedKey || `${weekId}|${course}`, treeGeom.leafSettings);
        if (DEBUG_FOREST.showBBoxes) {
          ctx.save();
          ctx.strokeStyle = "rgba(0,0,0,0.35)";
          ctx.setLineDash([4, 4]);
          ctx.strokeRect(bounds.minX, bounds.minY, bounds.width, bounds.height);
          ctx.restore();
        }
      } finally {
        ctx.restore();
      }
      prevGeomByKey.set(gridKey, treeGeom);
      forestGeom.trees.push(treeGeom);

      if (cell) {
        ctx.save();
        ctx.fillStyle = "#000000";
        ctx.globalAlpha = 1;
        ctx.font = "600 12px " + getCSSVar("--sans");
        ctx.textAlign = "center";
        const labelX = cell.x + cell.w / 2;
        const labelY = Math.min(h - 8, cell.labelY);
        ctx.fillText(course, labelX, labelY);
        ctx.restore();
      }
    });

    const topByGrowthRel = courseMetricRows
      .slice()
      .sort((a, b) => (b.growthRel || 0) - (a.growthRel || 0))
      .slice(0, 3)
      .map((c) => ({ name: c.name, growthRel: c.growthRel }));
    const topByScaleFinal = courseMetricRows
      .slice()
      .sort((a, b) => (b.scale?.scaleFinal || 0) - (a.scale?.scaleFinal || 0))
      .slice(0, 3)
      .map((c) => ({ name: c.name, scaleFinal: c.scale?.scaleFinal || 0 }));

    MetricsReporter.report({
      mode: focusMode,
      selectedCourse: focusCourse || null,
      canvas: { w: forestCanvas.width, h: forestCanvas.height },
      normalization: normalizationSnapshot,
      courses: courseMetricRows,
      top: { byGrowthRel: topByGrowthRel, byScaleFinal: topByScaleFinal }
    });

    applyOrderedDither(ctx, w, h, 0.035);
    lastForestGeom = forestGeom;
    renderForestLegend(perCourse, courses, weekId);
    renderScaleDebug();
  }

  function drawGhostForest(ctx, w, h, padL, padR, baseY, overrideGhost = null) {
    if (!overrideGhost && isMondayAfterNoonET()) return;
    const current = currentWeekId();
    const prev = prevIsoWeekId(current);
    const ghost = overrideGhost || loadGhostSnapshot(prev);
    if (!ghost) return;

    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.strokeStyle = "#000000";
    ctx.lineWidth = 0.5;

    ghost.trees.forEach((tree) => {
      tree.paths.forEach((p) => {
        if (p.type === "circle") {
          ctx.beginPath();
          ctx.arc(p.cx, p.cy, p.r, 0, Math.PI * 2);
          ctx.stroke();
        } else if (p.d) {
          ctx.beginPath();
          const path = new Path2D(p.d);
          ctx.stroke(path);
        } else {
          ctx.beginPath();
          ctx.strokeStyle = "#000000";
          ctx.lineWidth = 0.5;
          ctx.moveTo(p.x1, p.y1);
          ctx.lineTo(p.x2, p.y2);
          ctx.stroke();
        }
      });
    });

    ctx.restore();
  }

  function saveGhostSnapshot(weekId) {
    if (!lastForestGeom) return;
    try {
      const data = {
        version: GEN_VERSION,
        simulateMax: !!state.forest.simulateMax,
        weekId,
        trees: lastForestGeom.trees.map(tree => ({
          course: tree.course,
          paths: tree.paths.map(p => ({ ...p }))
        }))
      };
      localStorage.setItem(`${STORAGE_KEY}_ghost_${weekId}`, JSON.stringify(data));
    } catch {}
  }

  function loadGhostSnapshot(weekId) {
    try {
      const raw = localStorage.getItem(`${STORAGE_KEY}_ghost_${weekId}`);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed || parsed.weekId !== weekId) return null;
      if (parsed.version !== GEN_VERSION) return null;
      if (!!parsed.simulateMax !== !!state.forest.simulateMax) return null;
      return parsed;
    } catch {
      return null;
    }
  }

  function clearGhostSnapshot(weekId) {
    try { localStorage.removeItem(`${STORAGE_KEY}_ghost_${weekId}`); } catch {}
  }

  function buildLSystemParams(features, height, maxRise, signature) {
    const recursionN = features.recursionScore || 0;
    const abstractionN = features.abstractionScore || 0;
    const cohesionN = features.cohesionScore || 0;
    const argumentN = features.argumentScore || 0;
    const diversityN = features.diversityScore || 0;
    const tasksN = features.tasksN || 0;
    const stressN = features.stressN || 0;
    const wordsN = features.wordsN || 0;

    const baseHash = hashString(String(signature || ""));
    const isGcas = /gcas/i.test(signature || "");
    const sigJitter = ((baseHash % 23) - 11) * 0.7 + (isGcas ? -1.2 : 0);

    const angleBase = 24 + 22 * (1 - cohesionN) + 10 * (1 - recursionN) + 8 * diversityN + 10 * stressN;
    const angleDeg = clamp(angleBase + sigJitter, 14, 65);
    const iterations = Math.max(3, Math.round(6 + recursionN * 10 + abstractionN * 4 - stressN * 4));

    let step = clamp(7 + height * (0.04 + 0.03 * argumentN), 5, 16);
    step += 6 * tasksN;
    const stepScale = 0.85 + ((baseHash % 31) / 100) + (isGcas ? 0.06 : 0);
    step *= stepScale;
    if (maxRise) {
      const stepCap = Math.max(3, maxRise / (iterations * 2.6));
      step = Math.min(step, stepCap);
    }

    const grammarSet = [
      { "F": "F[+F]F[-F]F" },
      { "F": "FF[-F]F[+F]" },
      { "F": "F[+F]F" },
      { "F": "F[-F]F[+F]FF" },
      { "F": "F[+F]F[+F]F" },
      { "F": "F[-F]FF" },
      { "F": "FF[+F]F[-F]" },
      { "F": "F[+F][-F]F" },
      { "F": "F[+F]F[+F][-F]F" },
      { "F": "F[+F]FF[-F]F" },
      { "F": "F[+F]F[+F]FF[-F]F" },
      { "F": "FF[+F][-F]FF" }
    ];
    const key = [
      Math.round(recursionN * 10),
      Math.round(abstractionN * 10),
      Math.round(cohesionN * 10),
      Math.round(argumentN * 10),
      Math.round(diversityN * 10),
      Math.round(tasksN * 10),
      Math.round(wordsN * 10),
      baseHash
    ].join("|");
    const branchBias = Math.round(abstractionN * (grammarSet.length - 1));
    const rules = grammarSet[(hashString(key) + branchBias) % grammarSet.length];

    return {
      axiom: "F",
      rules,
      iterations,
      angle: angleDeg * (Math.PI / 180),
      step,
      sigHash: baseHash,
      seedKey: String(signature || ""),
      leavesEnabled: true,
      leafBasePx: 1.4,
      leafBurstMult: 1.6,
      leafTrunkMult: 0.7,
      leafMinDist: 8,
      leafCoreSuppression: 0.5,
      leafMaxPerTree: 900,
      features: {
        recursionN,
        abstractionN,
        cohesionN,
        argumentN,
        diversityN,
        tasksN,
        wordsN
      },
      jitter: (0.08 + 0.35 * diversityN) * (1 - 0.6 * cohesionN),
      gravityBias: 0.2 + 0.6 * argumentN,
      taperRate: 0.06 + 0.08 * recursionN,
      winding: {
        baseTurnRate: 0.04, // persistent gentle turn to avoid straight runs
        curvatureFloor: 0.08, // minimum heading variance across window
        curvatureWindow: 16, // window length for variance check
        noiseAmp: 0.25, // correlated bend amplitude
        noiseScale: 14, // correlation length in px
        headingInertiaK: 0.16, // smoothing factor for heading updates
        boundaryBand: 50, // soft edge repulsion band
        boundaryGain: 0.9, // edge steering strength
        occCellSize: 12, // occupancy grid cell size
        occGain: 0.6, // avoidance turn gain
        occDecay: 0.08, // per-step local decay
        maxInternodePx: 22, // cap for internode length
        // BEGIN PATCH: node cadence uses distance not substep count
        nodeSpacingPx: 20, // base node spacing for branch events
        // END PATCH
        recursionBudgetBase: 2600, // total segment budget per tree
        clusterProbability: 0.14, // probability to start a cluster burst
        clusterBurstSteps: 28, // steps for burst mode
        minBranchEverySteps: 4, // enforce node event cadence
        symmetryZoneMin: 40, // min steps per symmetry/exploration zone
        symmetryZoneMax: 120, // max steps per symmetry/exploration zone
        symmetryStrengthBase: 0.7, // baseline symmetry strength
        symmetryAnglesDeg: [12, 18, 24, 33], // discrete symmetry angles
        defectCountMin: 2, // symmetry breakpoints per zone
        defectCountMax: 5, // symmetry breakpoints per zone
        defectWindow: 8, // steps a defect lasts
        exploratoryNoiseBoost: 1.35, // higher noise in exploratory zones
        symmetryNoiseScale: 0.8, // tighter noise in symmetric zones
        clusterStepScale: 0.82, // shorter steps during cluster bursts
        twigEveryMin: 2, // twigging cadence min
        twigEveryMax: 4, // twigging cadence max
        twigLenScale: 0.55 // twig length scale
      }
    };
  }

  function expandLSystem(axiom, rules, iterations, maxLen = 9000, maxRun = 2200) {
    let str = axiom;
    for (let i = 0; i < iterations; i++) {
      let next = "";
      for (let j = 0; j < str.length; j++) {
        const ch = str[j];
        next += rules[ch] || ch;
        if (next.length > maxLen) break;
      }
      str = next.slice(0, maxLen);
    }
    return str.slice(0, maxRun);
  }

      function noise1D(seedKey, branchId, s, scale) {
    const t = s / Math.max(1, scale);
    const i0 = Math.floor(t);
    const f = t - i0;
    const h0 = hashString(`${seedKey}|${branchId}|${i0}`);
    const h1 = hashString(`${seedKey}|${branchId}|${i0 + 1}`);
    const v0 = (h0 % 2000) / 1000 - 1;
    const v1 = (h1 % 2000) / 1000 - 1;
    const smooth = f * f * (3 - 2 * f);
    return v0 + (v1 - v0) * smooth;
  }

  function angleDelta(a, b) {
    return Math.atan2(Math.sin(b - a), Math.cos(b - a));
  }

  function lerpAngle(a, b, k) {
    return a + angleDelta(a, b) * k;
  }

  function makeOccGrid(w, h, cellSize) {
    const cols = Math.max(1, Math.ceil(w / cellSize));
    const rows = Math.max(1, Math.ceil(h / cellSize));
    return { cols, rows, cellSize, data: new Float32Array(cols * rows) };
  }

  function occIndex(grid, x, y) {
    const cx = Math.max(0, Math.min(grid.cols - 1, Math.floor(x / grid.cellSize)));
    const cy = Math.max(0, Math.min(grid.rows - 1, Math.floor(y / grid.cellSize)));
    return cy * grid.cols + cx;
  }

  function occSample(grid, x, y) {
    return grid.data[occIndex(grid, x, y)] || 0;
  }

  function occStamp(grid, x, y, decay) {
    const idx = occIndex(grid, x, y);
    const prev = grid.data[idx] || 0;
    grid.data[idx] = prev * (1 - decay) + 1;
  }

  function boundaryTurn(dir, x, y, w, h, band, gain) {
    if (band <= 0) return 0;
    const left = x;
    const right = w - x;
    const top = y;
    const bottom = h - y;
    const minDist = Math.min(left, right, top, bottom);
    if (minDist >= band) return 0;
    const t = (band - minDist) / band;
    const strength = t * t;
    const toward = Math.atan2(h / 2 - y, w / 2 - x);
    return angleDelta(dir, toward) * strength * gain;
  }

  function drawLSystem(ctx, start, angle, spec, leafPoints, ink, geom, minY, runScale = 1, collision = null, captureOnly = false) {
    const stack = [];
    let x = start.x;
    let y = start.y;
    let dir = angle;
    let s = 0;
    let step = spec.step;
    const maxRun = Math.max(200, Math.round(5000 * clamp(runScale, 0.1, 1)));
    const seq = expandLSystem(spec.axiom, spec.rules, spec.iterations, 20000, maxRun);
    const shouldDraw = !captureOnly;

    const wind = spec.winding || {
      baseTurnRate: 0.04,
      curvatureFloor: 0.08,
      curvatureWindow: 16,
      noiseAmp: 0.25,
      noiseScale: 14,
      headingInertiaK: 0.16,
      boundaryBand: 50,
      boundaryGain: 0.9,
      occCellSize: 12,
      occGain: 0.6,
      occDecay: 0.08,
      maxInternodePx: 22,
      // BEGIN PATCH: node cadence uses distance not substep count
      nodeSpacingPx: 20,
      // END PATCH
      recursionBudgetBase: 2600,
      clusterProbability: 0.14,
      clusterBurstSteps: 28,
      minBranchEverySteps: 4,
      symmetryZoneMin: 40,
      symmetryZoneMax: 120,
      symmetryStrengthBase: 0.7,
      symmetryAnglesDeg: [12, 18, 24, 33],
      defectCountMin: 2,
      defectCountMax: 5,
      defectWindow: 8,
      exploratoryNoiseBoost: 1.35,
      symmetryNoiseScale: 0.8,
      clusterStepScale: 0.82,
      twigEveryMin: 2,
      twigEveryMax: 4,
      twigLenScale: 0.55
    };

    const features = spec.features || {
      recursionN: 0.5,
      abstractionN: 0.5,
      cohesionN: 0.5,
      argumentN: 0.5,
      diversityN: 0.5
    };
    const effortAbs = clamp(spec.effortAbs ?? 0, 0, 1);
    const effortGate = clamp(spec.effortGate ?? effortAbs, 0, 1);
    const idleMode = !!spec.idleMode;
    const sproutMode = !!spec.sproutMode;
    const isSprout = !!spec.isSprout;
    const sproutN = clamp(spec.sproutN ?? 0, 0, 1);
    const growthRel = clamp(spec.growthRel ?? 0, 0, 1);
    const sproutT = clamp(growthRel / 0.18, 0, 1);
    const branchGate = clamp(spec.branchGate ?? effortGate, 0.01, 1);
    const clusterGate = clamp(spec.clusterGate ?? effortGate, 0.005, 1);
    const trunkBudgetSteps = isSprout
      ? clamp(lerpInt(10, 18, sproutT), 8, 22)
      : Math.round(40 + (95 - 40) * effortGate) + Math.round(25 * (features.recursionN || 0) * effortGate);
    const trunkLenMult = isSprout
      ? lerp(0.55, 0.85, sproutN)
      : (1.05 + (1.55 - 1.05) * effortGate);
    const trunkTierEvery = Math.round(10 + (14 - 10) * seededRandom(spec.seedKey || "", "trunk-tier"));
    const courseId = spec.courseId || "";
    const conceptId = spec.conceptId ?? null;
    // BEGIN PATCH: trunk → burst → trunk state machine
    const stateMachine = spec.stateMachine || null;
    let state = stateMachine?.startState || "BURST";
    if (isSprout) state = "TRUNK";
    let burstRemaining = state === "BURST" ? (stateMachine?.burstDurationSteps ?? 160) : 0;
    let burstBudgetApplied = false;
    let stepDecay = 1;
    let recoveryRemaining = (stateMachine?.startState === "TRUNK" && stateMachine?.recoverySteps) ? stateMachine.recoverySteps : 0;
    let austerityRemaining = 0;
    const burstSchedule = Array.isArray(stateMachine?.burstSchedule) ? [...stateMachine.burstSchedule].sort((a,b)=>a-b) : null;
    let burstIndex = 0;
    const burstAxisFallback = seededRandom(spec.seedKey || "", "burst-axis") * Math.PI * 2;
    const trunkHeading = (typeof spec.trunkHeading === "number") ? spec.trunkHeading : angle;
    const burstAxisAngle = lerpAngle(stateMachine?.burstAxisAngle ?? burstAxisFallback, trunkHeading, 0.4);
    const enterBurst = () => {
      if (isSprout) return;
      state = "BURST";
      burstRemaining = stateMachine?.burstDurationSteps ?? 160;
      burstBudgetApplied = false;
      stepDecay = 1;
    };
    // END PATCH

    // Metric mapping (transparent):
    // - expositionScore uses cohesion + abstraction + recursion -> symmetric zones, higher symmetryStrength, denser clustering
    // - transitionScore uses diversity + (1 - cohesion) + argument -> exploratory zones, higher noiseAmp/noiseScale
    const expoBase = clamp(0.45 * features.cohesionN + 0.35 * features.abstractionN + 0.2 * features.recursionN, 0, 1);
    const transBase = clamp(0.5 * features.diversityN + 0.3 * (1 - features.cohesionN) + 0.2 * features.argumentN, 0, 1);

    const canvasW = ctx.canvas.width / (window.devicePixelRatio || 1);
    const canvasH = ctx.canvas.height / (window.devicePixelRatio || 1);
    const occ = makeOccGrid(canvasW, canvasH, wind.occCellSize);
    const symAngles = (wind.symmetryAnglesDeg || [12, 18, 24, 33]).map(d => d * (Math.PI / 180));

    let branchId = 0;
    let branchSign = seededRandom(spec.seedKey || "", `branch:${branchId}`) < 0.5 ? -1 : 1;
    let branchSerial = 0;
    // BEGIN PATCH: node cadence uses distance not substep count
    let distSinceNode = 0;
    let distSinceTwig = 0;
    let stepsSinceBranch = 0;
    let subStepCount = 0;
    let burstBandNorm = 1;
    const recentAngles = [];
    let lastBranchOrigin = null;
    // END PATCH
    const headingHistory = [];
    let trunkStepIndex = 0;
    const trunkStepsTotal = Math.max(1, stateMachine?.trunkStepsTotal || maxRun);

    // BEGIN PATCH: leaf points for post-pass leaves
    const pushLeafPoint = (lx, ly, weight = 1) => {
      if (!Array.isArray(leafPoints)) return;
      const leafState = stateMachine ? (state === "BURST" ? "BURST" : "TRUNK") : "TRUNK";
      if (leafState === "TRUNK" && austerityRemaining > 0) return;
      leafPoints.push({
        x: lx,
        y: ly,
        w: clamp(weight, 0.5, 1.5),
        state: leafState,
        bandNorm: (leafState === "BURST" && stateMachine?.burstOrigin && stateMachine?.burstMaxRadiusPx)
          ? clamp(Math.hypot(lx - stateMachine.burstOrigin.x, ly - stateMachine.burstOrigin.y) / Math.max(1, stateMachine.burstMaxRadiusPx), 0, 1)
          : null
      });
    };
    // END PATCH

    if (isSprout) step *= 0.55;
    let segmentBudget = Math.max(200, Math.round((wind.recursionBudgetBase || 2600) * (0.7 + 0.6 * runScale) * (0.55 + 0.45 * features.recursionN)));
    if (sproutMode || isSprout) segmentBudget = Math.min(segmentBudget, 180);
    let segmentsDrawn = 0;
    let branchEvents = 0;
    let sproutBranchEvents = 0;

    const zone = {
      type: "exploratory",
      index: 0,
      step: 0,
      remaining: 0,
      symmetryAxisAngle: -Math.PI / 2,
      symmetryStrength: wind.symmetryStrengthBase || 0.7,
      breakpoints: [],
      defectSteps: 0,
      defectType: 0,
      defectSide: 1,
      twigEvery: 3
    };

    function startZone(type, dirNow, sNow) {
      zone.type = type;
      zone.index += 1;
      zone.step = 0;
      const lenSeed = seededRandom(spec.seedKey || "", `zone-len:${zone.index}`);
      const zmin = wind.symmetryZoneMin || 40;
      const zmax = wind.symmetryZoneMax || 120;
      zone.remaining = Math.round(zmin + (zmax - zmin) * lenSeed);
      const axisSeed = seededRandom(spec.seedKey || "", `zone-axis:${zone.index}`) - 0.5;
      zone.symmetryAxisAngle = lerpAngle(dirNow, -Math.PI / 2 + axisSeed * 0.8, 0.5);
      const strengthJitter = seededRandom(spec.seedKey || "", `zone-strength:${zone.index}`) * 0.2 - 0.1;
      zone.symmetryStrength = clamp((wind.symmetryStrengthBase || 0.7) + strengthJitter, 0.35, 0.95);
      const twigSeed = seededRandom(spec.seedKey || "", `zone-twig:${zone.index}`);
      const twigMin = wind.twigEveryMin || 2;
      const twigMax = wind.twigEveryMax || 4;
      zone.twigEvery = Math.round(twigMin + (twigMax - twigMin) * twigSeed);

      const breaks = [];
      const bcountSeed = seededRandom(spec.seedKey || "", `zone-breaks:${zone.index}`);
      const bmin = wind.defectCountMin || 2;
      const bmax = wind.defectCountMax || 5;
      const bcount = Math.round(bmin + (bmax - bmin) * bcountSeed);
      for (let i = 0; i < bcount; i++) {
        const t = seededRandom(spec.seedKey || "", `zone-break:${zone.index}:${i}`);
        breaks.push(Math.max(4, Math.floor(t * zone.remaining)));
      }
      zone.breakpoints = breaks;
      zone.defectSteps = 0;
      zone.defectType = 0;
      zone.defectSide = seededRandom(spec.seedKey || "", `zone-side:${zone.index}`) < 0.5 ? -1 : 1;
    }

    function updateZone(dirNow, sNow) {
      const expoNoise = 0.2 * noise1D(spec.seedKey || "", "expo", sNow, 90);
      const transNoise = 0.2 * noise1D(spec.seedKey || "", "trans", sNow, 80);
      const expositionScore = clamp(expoBase + expoNoise, 0, 1);
      const transitionScore = clamp(transBase + transNoise, 0, 1);
      const prefer = transitionScore > 0.62 ? "exploratory" : (expositionScore > 0.62 ? "symmetric" : zone.type);

      if (zone.remaining <= 0 || (prefer !== zone.type && (transitionScore > 0.75 || expositionScore > 0.75))) {
        startZone(prefer, dirNow, sNow);
      }

      zone.step += 1;
      zone.remaining -= 1;
      if (zone.breakpoints.includes(zone.step)) {
        zone.defectSteps = wind.defectWindow || 8;
        zone.defectType = Math.floor(seededRandom(spec.seedKey || "", `zone-defect:${zone.index}:${zone.step}`) * 4);
      }
      if (zone.defectSteps > 0) zone.defectSteps -= 1;

      return { expositionScore, transitionScore };
    }

    function drawBranchlet(originX, originY, baseDir, lenScale, stepCount, localBranchId, zoneType, defectSide = 0) {
      let bx = originX;
      let by = originY;
      let bdir = baseDir;
      let bs = 0;
      const suppressTrunk = (stateMachine && state === "TRUNK" && !TRUNK_VISIBLE);
      const stateNoiseScale = stateMachine
        ? (state === "BURST" ? (stateMachine?.burstNoiseScale ?? 0.55) : (stateMachine?.trunkNoiseScale ?? 0.45))
        : 1;
      const burstTwigScale = (stateMachine && state === "BURST") ? (stateMachine?.burstTwigStepScale ?? 0.55) : 1;
      const localNoiseScale = (zoneType === "symmetric" ? wind.noiseScale * (wind.symmetryNoiseScale || 0.8) : wind.noiseScale) * (wind.exploratoryNoiseBoost || 1.1) * stateNoiseScale;
      const localNoiseAmp = wind.noiseAmp * (zoneType === "symmetric" ? 0.6 : 1.1) * (defectSide ? 1.35 : 1) * stateNoiseScale;
      const localMaxInternode = (stateMachine && state === "BURST" && typeof stateMachine.burstMaxInternodePx === "number")
        ? stateMachine.burstMaxInternodePx
        : ((stateMachine && state === "TRUNK" && typeof stateMachine.trunkMaxInternodePx === "number")
          ? stateMachine.trunkMaxInternodePx
          : (wind.maxInternodePx || step));
      const branchStep = Math.min(step * lenScale * burstTwigScale, localMaxInternode);

      for (let j = 0; j < stepCount && segmentBudget > 0; j++) {
        const baseTurn = branchSign * wind.baseTurnRate * 1.2;
        const noiseTurn = noise1D(spec.seedKey || "", localBranchId, bs, localNoiseScale) * localNoiseAmp;
        const boundary = boundaryTurn(bdir, bx, by, canvasW, canvasH, wind.boundaryBand, wind.boundaryGain);
        const desired = bdir + baseTurn + noiseTurn + boundary;
        bdir = lerpAngle(bdir, desired, wind.headingInertiaK);

        const nx = bx + Math.cos(bdir) * branchStep;
        const ny = by + Math.sin(bdir) * branchStep;

        if (shouldDraw && !suppressTrunk) {
          ctx.beginPath();
          ctx.moveTo(bx, by);
          ctx.lineTo(nx, ny);
          ctx.stroke();
        }
        if (geom) {
          geom.paths.push({
            x1: bx, y1: by, x2: nx, y2: ny,
            stroke: ink,
            sw: suppressTrunk ? 0 : (ctx.lineWidth * 0.75),
            alpha: suppressTrunk ? 0 : 1,
            type: "branchlet",
            courseId,
            conceptId,
            zoneType
          });
        }
        segmentsDrawn += 1;
        occStamp(occ, nx, ny, wind.occDecay);
        bx = nx; by = ny; bs += branchStep;
        segmentBudget -= 1;
      }
      // terminal point -> leaf candidate
      const leafWeight = clamp(0.6 + lenScale * 0.8, 0.5, 1.5);
      pushLeafPoint(bx, by, leafWeight);
    }

    const cluster = { remaining: 0, queue: [], sideBias: 0 };

    function startCluster(sideBias = 0) {
      const burstSeed = seededRandom(spec.seedKey || "", `cluster:${branchId}:${Math.floor(s)}`);
      const burstSteps = Math.max(8, Math.round((wind.clusterBurstSteps || 28) * (0.7 + burstSeed * 0.6)));
      cluster.remaining = burstSteps;
      cluster.queue = [];
      cluster.sideBias = sideBias;
      const count = 2 + Math.floor(seededRandom(spec.seedKey || "", `cluster-count:${branchId}:${Math.floor(s)}`) * 3);
      for (let i = 0; i < count; i++) {
        const delay = 1 + Math.floor(seededRandom(spec.seedKey || "", `cluster-delay:${branchId}:${i}:${Math.floor(s)}`) * 3);
        cluster.queue.push({ delay, count: 1 + Math.floor(seededRandom(spec.seedKey || "", `cluster-child:${branchId}:${i}`) * 2) });
      }
    }

    const noteBranchEvent = (theta = null, origin = null) => {
      if (stateMachine && state === "BURST") {
        stepsSinceBranch = 0;
        if (typeof theta === "number" && isFinite(theta)) {
          recentAngles.push(Math.abs(theta));
          if (recentAngles.length > 6) recentAngles.shift();
        }
        if (origin && typeof origin.x === "number" && typeof origin.y === "number") {
          lastBranchOrigin = { x: origin.x, y: origin.y };
        }
      }
    };

    const pickRecentAngle = (salt) => {
      if (!recentAngles.length) return null;
      const total = recentAngles.reduce((sum, _, i) => sum + (i + 1), 0);
      let r = seededRandom(spec.seedKey || "", `mem:${salt}:${Math.floor(s)}`) * total;
      for (let i = 0; i < recentAngles.length; i++) {
        r -= (i + 1);
        if (r <= 0) return recentAngles[i];
      }
      return recentAngles[recentAngles.length - 1];
    };

    function spawnClusterQueue(dirNow) {
      cluster.queue.forEach((item) => { item.delay -= 1; });
      const ready = cluster.queue.filter(item => item.delay <= 0);
      cluster.queue = cluster.queue.filter(item => item.delay > 0);
      ready.forEach((item) => {
        for (let i = 0; i < item.count; i++) {
          const side = cluster.sideBias || (seededRandom(spec.seedKey || "", `cluster-side:${branchId}:${i}:${Math.floor(s)}`) < 0.5 ? -1 : 1);
          const alpha = symAngles[Math.floor(seededRandom(spec.seedKey || "", `cluster-angle:${branchId}:${i}:${Math.floor(s)}`) * symAngles.length)] || (18 * Math.PI / 180);
          const branchDir = dirNow + side * alpha;
          branchSerial += 1;
          drawBranchlet(x, y, branchDir, 0.85, 6 + Math.floor(seededRandom(spec.seedKey || "", `cluster-len:${branchSerial}`) * 6), branchSerial, zone.type, side);
        }
        noteBranchEvent(null, { x, y });
        // BEGIN PATCH: node cadence uses distance not substep count
        distSinceNode = 0;
        distSinceTwig = 0;
        // END PATCH
      });
    }

    function spawnBranchEvent(dirNow, force, sideBias = 0) {
      if (segmentBudget <= 0) return;
      branchEvents += 1;
      if (isSprout) sproutBranchEvents += 1;
      if (stateMachine && state === "BURST") {
        const axis = burstAxisAngle;
        const thetaSet = (burstBandNorm < 0.45 ? [18, 27] : [18, 27, 36]).map(d => d * (Math.PI / 180));
        let thetaPick = thetaSet[Math.floor(seededRandom(spec.seedKey || "", `burst-theta:${branchId}:${Math.floor(s)}`) * thetaSet.length)] || (18 * Math.PI / 180);
        if (recentAngles.length && seededRandom(spec.seedKey || "", `burst-theta-bias:${branchId}:${Math.floor(s)}`) < 0.8) {
          thetaPick = pickRecentAngle(`burst-theta-mem:${branchId}`) || thetaPick;
        }
        const jitter = ((seededRandom(spec.seedKey || "", `burst-theta-jitter:${branchId}:${Math.floor(s)}`) - 0.5) * 2) * (1 * (Math.PI / 180));
        const theta = thetaPick + jitter;
        const defectSeed = seededRandom(spec.seedKey || "", `burst-defect:${branchId}:${Math.floor(s)}`);
        const skipLeft = defectSeed < 0.04;
        const skewRight = defectSeed >= 0.04 && defectSeed < 0.08;
        const leftDir = axis - theta;
        const rightDir = axis + theta + (skewRight ? (2 * (Math.PI / 180)) : 0);
        if (!skipLeft) {
          branchSerial += 1;
          drawBranchlet(x, y, leftDir, 0.75, 6, branchSerial, "symmetric", -1);
        }
        if (defectSeed >= 0.02) {
          branchSerial += 1;
          drawBranchlet(x, y, rightDir, 0.75, 6, branchSerial, "symmetric", 1);
        }
        noteBranchEvent(thetaPick, { x, y });
        return;
      }
      const axis = lerpAngle(dirNow, zone.symmetryAxisAngle, zone.symmetryStrength);
      const alpha = symAngles[Math.floor(seededRandom(spec.seedKey || "", `alpha:${branchId}:${Math.floor(s)}`) * symAngles.length)] || (18 * Math.PI / 180);
      const pair = zone.type === "symmetric";
      const defectActive = zone.defectSteps > 0 && zone.type === "symmetric";
      const suppressSide = defectActive && zone.defectType === 0 ? zone.defectSide : 0;
      const noiseDefect = defectActive && zone.defectType === 1 ? zone.defectSide : 0;
      const clusterDefect = defectActive && zone.defectType === 2 ? zone.defectSide : 0;

      if (pair) {
        const leftDir = axis - alpha;
        const rightDir = axis + alpha;
        if (suppressSide >= 0) {
          branchSerial += 1;
          drawBranchlet(x, y, rightDir, 0.75, 6, branchSerial, zone.type, noiseDefect > 0 ? 1 : 0);
        }
        if (suppressSide <= 0) {
          branchSerial += 1;
          drawBranchlet(x, y, leftDir, 0.75, 6, branchSerial, zone.type, noiseDefect < 0 ? -1 : 0);
        }
        if (clusterDefect != 0) startCluster(clusterDefect);
      } else {
        const side = sideBias || (seededRandom(spec.seedKey || "", `branch-side:${branchId}:${Math.floor(s)}`) < 0.5 ? -1 : 1);
        branchSerial += 1;
        drawBranchlet(x, y, dirNow + side * alpha, 0.8, 6, branchSerial, zone.type, side);
      }
      noteBranchEvent();
    }

    startZone(zone.type, dir, s);

    ctx.save();
    ctx.strokeStyle = ink;
    ctx.globalAlpha = 1;

    for (let i = 0; i < seq.length && segmentBudget > 0; i++) {
      const ch = seq[i];
      if (ch === "F") {
        const depth = stack.length;
        const taper = Math.max(0.2, 0.9 - depth * (spec.taperRate || 0.06));
        const baseStrokeW = 0.6 * taper * (zone.type === "symmetric" ? 1.05 : 0.9);

        const stepCap = wind.maxInternodePx || step;
        const subSteps = Math.max(1, Math.ceil(step / stepCap));
        const baseSubStep = step / subSteps;

        for (let sub = 0; sub < subSteps && segmentBudget > 0; sub++) {
          subStepCount += 1;
          const scores = updateZone(dir, s);
          // BEGIN PATCH: trunk → burst → trunk state machine
          if (burstSchedule && state === "TRUNK" && burstIndex < burstSchedule.length && s >= burstSchedule[burstIndex] && trunkStepIndex >= trunkBudgetSteps) {
            enterBurst();
            burstIndex += 1;
          }
          const isBurst = state === "BURST";
          if (!isBurst) burstBandNorm = 1;
          if (isBurst && !burstBudgetApplied) {
            segmentBudget += stateMachine?.burstBudgetBonus ?? 240;
            burstBudgetApplied = true;
          }
          if (stateMachine) {
            zone.type = isBurst ? "symmetric" : "exploratory";
          }
          const expoBoost = 0.6 + 0.8 * scores.expositionScore;
          const transBoost = 0.6 + 0.8 * scores.transitionScore;
          let branchProbScale = stateMachine
            ? (isBurst ? (stateMachine?.burstBranchProbScale ?? 2.6) : (stateMachine?.trunkBranchProbScale ?? 0.2))
            : 1;
          let clusterProbScale = stateMachine
            ? (isBurst ? (stateMachine?.burstClusterProbScale ?? 1.6) : (stateMachine?.trunkClusterProbScale ?? 0.2))
            : 1;
          if (isSprout) {
            branchProbScale *= 0.25 * 1.35;
            branchProbScale = Math.min(branchProbScale, 0.55);
            clusterProbScale *= 0.15;
          }
          let trunkLenScale = 1;
          // END PATCH

          let noiseScaleFactor = stateMachine
            ? (isBurst ? (stateMachine?.burstNoiseScale ?? 0.6) : (stateMachine?.trunkNoiseScale ?? 0.45))
            : 1;
          let turnScaleFactor = stateMachine
            ? (isBurst ? (stateMachine?.burstTurnScale ?? 0.7) : (stateMachine?.trunkTurnScale ?? 0.4))
            : 1;
          if (stateMachine && !isBurst) {
            noiseScaleFactor *= 0.82;
            turnScaleFactor *= 0.78;
            trunkStepIndex += 1;
            const trunkProgress = clamp(trunkStepIndex / Math.max(1, trunkBudgetSteps), 0, 1) * effortGate;
            const trunkRamp = smoothstep(0.70, 1.0, trunkProgress);
            branchProbScale *= (0.15 + (1.0 - 0.15) * trunkRamp);
            clusterProbScale *= (0.10 + (1.0 - 0.10) * trunkRamp);
            const trunkLenJitter = 0.9 + 0.2 * seededRandom(spec.seedKey || "", `trunk-len:${trunkStepIndex}:${subStepCount}`);
            trunkLenScale = trunkLenMult * trunkLenJitter;
          }
          if (stateMachine && isBurst) {
            noiseScaleFactor *= 0.7;
            turnScaleFactor *= 0.75;
          }
          if (stateMachine && !isBurst && austerityRemaining > 0) {
            noiseScaleFactor *= 0.7;
            turnScaleFactor *= 0.7;
            branchProbScale *= 0.55;
            clusterProbScale *= 0.55;
          }
          branchProbScale *= branchGate;
          clusterProbScale *= clusterGate;
          const localNoiseAmp = wind.noiseAmp * (zone.type === "symmetric" ? 0.6 : (wind.exploratoryNoiseBoost || 1.35)) * (cluster.remaining > 0 ? 1.2 : 1) * noiseScaleFactor;
          const localNoiseScale = wind.noiseScale * (zone.type === "symmetric" ? (wind.symmetryNoiseScale || 0.8) : 1.15) * (cluster.remaining > 0 ? 1.15 : 1) * noiseScaleFactor;
          const baseTurn = branchSign * wind.baseTurnRate * (zone.type === "symmetric" ? 0.9 : 1.1) * turnScaleFactor;
          const noiseTurn = noise1D(spec.seedKey || "", branchId, s, localNoiseScale) * localNoiseAmp;
          const gravityTurn = angleDelta(dir, -Math.PI / 2) * (spec.gravityBias || 0.3) * 0.03;

          const boundary = boundaryTurn(dir, x, y, canvasW, canvasH, wind.boundaryBand, wind.boundaryGain);

          const forward = occSample(occ, x + Math.cos(dir) * baseSubStep * 1.5, y + Math.sin(dir) * baseSubStep * 1.5);
          const left = occSample(occ, x + Math.cos(dir - Math.PI / 4) * baseSubStep * 1.2, y + Math.sin(dir - Math.PI / 4) * baseSubStep * 1.2);
          const right = occSample(occ, x + Math.cos(dir + Math.PI / 4) * baseSubStep * 1.2, y + Math.sin(dir + Math.PI / 4) * baseSubStep * 1.2);
          const densityBias = (right - left) * -wind.occGain * (1 + forward * 0.2);

          headingHistory.push(dir);
          if (headingHistory.length > wind.curvatureWindow) headingHistory.shift();
          const cosAvg = headingHistory.reduce((sum, a) => sum + Math.cos(a), 0) / headingHistory.length;
          const sinAvg = headingHistory.reduce((sum, a) => sum + Math.sin(a), 0) / headingHistory.length;
          const variance = 1 - Math.sqrt(cosAvg * cosAvg + sinAvg * sinAvg);
          const curvatureTurn = variance < wind.curvatureFloor
            ? branchSign * (wind.curvatureFloor - variance) * 0.6
            : 0;

          // base + noise + boundary + avoidance + curvature floor (smooth winding)
          let desiredDir = dir + baseTurn + noiseTurn + gravityTurn + boundary + densityBias + curvatureTurn;
          // BEGIN PATCH: burst radius constraint + symmetry axis
          let burstBandScale = 1;
          let burstTwigEveryOverride = null;
          if (stateMachine && isBurst) {
            zone.symmetryAxisAngle = burstAxisAngle;
            zone.symmetryStrength = Math.max(0.9, zone.symmetryStrength);
          }
          if (stateMachine && isBurst && stateMachine.burstOrigin && stateMachine.burstMaxRadiusPx) {
            const ox = stateMachine.burstOrigin.x;
            const oy = stateMachine.burstOrigin.y;
            const dx = x - ox;
            const dy = y - oy;
            const dist = Math.hypot(dx, dy);
            const radius = stateMachine.burstMaxRadiusPx;
            const band = dist / Math.max(1, radius);
            burstBandNorm = band;
            if (band < 0.4) {
              burstBandScale = 1.4;
              burstTwigEveryOverride = 1;
            } else if (band < 0.75) {
              burstBandScale = 0.8;
              burstTwigEveryOverride = 2;
            } else {
              burstBandScale = 0.2;
              burstTwigEveryOverride = 5;
            }
            const survivalScale = clamp(0.35 + 0.65 * (1 - Math.pow(band, 1.4)), 0.35, 1);
            clusterProbScale *= survivalScale;
            branchProbScale *= (0.85 + 0.15 * survivalScale);
            const toward = Math.atan2(oy - y, ox - x);
            if (band > 0.65) {
              const desiredRadius = radius * 0.55;
              const radialError = dist - desiredRadius;
              const radialPull = clamp(radialError / Math.max(1, radius), -1, 1);
              const w = clamp((band - 0.65) / 0.35, 0, 1);
              desiredDir += angleDelta(dir, toward) * (0.22 * radialPull * (w * w));
            }
            if (dist > radius) {
              const pull = clamp((dist - radius) / radius, 0, 1);
              const pull2 = pull * pull;
              const outerBoost = band >= 0.75 ? 1.55 : 1;
              desiredDir += angleDelta(dir, toward) * (0.35 + 0.95 * pull2) * outerBoost;
            }
          }
          // END PATCH
          if (stateMachine && isBurst) {
            branchProbScale *= burstBandScale;
            clusterProbScale *= burstBandScale;
          }
          if (stateMachine && !isBurst) {
            const trunkGrav = TRUNK_GRAV + 0.06 * effortGate;
            desiredDir = lerpAngle(desiredDir, -Math.PI / 2, trunkGrav);
          }
          if (stateMachine && isBurst && burstBandNorm < 0.45 && (subStepCount % 11 === 0)) {
            desiredDir += angleDelta(dir, burstAxisAngle) * 0.1;
          }
          // BEGIN PATCH: burst angle quantization
          if (stateMachine && isBurst) {
            const delta = angleDelta(dir, desiredDir);
            const mags = (burstBandNorm < 0.45 ? [18, 27] : [18, 27, 36]).map(d => d * (Math.PI / 180));
            const abs = Math.abs(delta);
            let closest = mags[0];
            for (let mi = 1; mi < mags.length; mi++) {
              if (Math.abs(abs - mags[mi]) < Math.abs(abs - closest)) closest = mags[mi];
            }
            const sign = delta === 0 ? (seededRandom(spec.seedKey || "", `burst-qd:${branchId}:${Math.floor(s)}`) < 0.5 ? -1 : 1) : Math.sign(delta);
            const jitter = ((seededRandom(spec.seedKey || "", `burst-qj:${branchId}:${Math.floor(s)}`) - 0.5) * 2) * (1 * (Math.PI / 180));
            desiredDir = dir + sign * closest + jitter;
          }
          // END PATCH
          dir = lerpAngle(dir, desiredDir, wind.headingInertiaK);

          if (typeof minY === "number" && y < minY + 12) {
            dir += 0.25;
          }

          const clusterScale = cluster.remaining > 0 ? (wind.clusterStepScale || 0.82) : 1;
          // BEGIN PATCH: trunk → burst → trunk state machine
          const stateStepScale = stateMachine
            ? (isBurst ? (stateMachine?.burstStepScale ?? 0.5) : (stateMachine?.trunkStepScale ?? 1.2))
            : 1;
          if (stateMachine) {
            if (isBurst) {
              const decay = stateMachine?.burstDecay ?? 0.99;
              stepDecay = Math.max(0.5, stepDecay * decay);
            } else {
              stepDecay = Math.min(1, stepDecay + 0.02);
            }
          }
          const burstMaxInternodePx = stateMachine?.burstMaxInternodePx;
          const trunkMaxInternodePx = stateMachine?.trunkMaxInternodePx;
          const localMaxInternode = (stateMachine && isBurst && typeof burstMaxInternodePx === "number")
            ? burstMaxInternodePx
            : ((stateMachine && !isBurst && typeof trunkMaxInternodePx === "number")
              ? trunkMaxInternodePx
              : (wind.maxInternodePx || baseSubStep));
          const minLen = (stateMachine && isBurst) ? (stateMachine?.burstMinLen ?? 2.2) : 1.2;
          let subStep = Math.min(
            baseSubStep * clusterScale * stateStepScale * stepDecay * trunkLenScale,
            localMaxInternode
          );
          subStep = Math.max(minLen, subStep);
          // END PATCH

          // BEGIN PATCH: enforce net upward progress in TRUNK
          if (stateMachine && !isBurst) {
            const dyStep = Math.sin(dir) * subStep;
            if (dyStep > 0 || Math.abs(dyStep) < 0.2) {
              dir = lerpAngle(dir, -Math.PI / 2, 0.12);
            }
          }
          // END PATCH

          const isTrunkState = stateMachine && !isBurst;
          const strokeW = isTrunkState
            ? (TRUNK_VISIBLE ? baseStrokeW * 1.2 : 0)
            : baseStrokeW;
          ctx.lineWidth = strokeW;
          let nx = x + Math.cos(dir) * subStep;
          let ny = y + Math.sin(dir) * subStep;

          // soften boundary if we would exit: shorten step + stronger boundary turn
          if (nx < 0 || nx > canvasW || ny < 0 || ny > canvasH) {
            const extraTurn = boundaryTurn(dir, x, y, canvasW, canvasH, wind.boundaryBand, wind.boundaryGain * 1.6);
            dir = lerpAngle(dir, dir + extraTurn, wind.headingInertiaK);
            nx = x + Math.cos(dir) * subStep * 0.6;
            ny = y + Math.sin(dir) * subStep * 0.6;
          }

          if (shouldDraw && strokeW > 0) {
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(nx, ny);
            ctx.stroke();
          }
          if (geom) {
            geom.paths.push({
              x1: x, y1: y, x2: nx, y2: ny,
              stroke: ink,
              sw: strokeW,
              alpha: strokeW > 0 ? 1 : 0,
              type: "branch",
              courseId,
              conceptId,
              zoneType: zone.type
            });
          }
          segmentsDrawn += 1;

          const ds = Math.hypot(nx - x, ny - y);
          occStamp(occ, nx, ny, wind.occDecay);
          x = nx; y = ny; s += ds; segmentBudget -= 1;

          // BEGIN PATCH: node cadence uses distance not substep count
          distSinceNode += ds;
          distSinceTwig += ds;
          // END PATCH
          if (isSprout) {
            stepsSinceBranch += 1;
          } else if (stateMachine && isBurst) {
            stepsSinceBranch += 1;
          } else if (stateMachine && !isBurst) {
            stepsSinceBranch = 0;
          }

          if (cluster.remaining > 0) {
            cluster.remaining -= 1;
            spawnClusterQueue(dir);
          }

          let clusterChance = wind.clusterProbability * (zone.type === "symmetric" ? expoBoost : transBoost) * clusterProbScale;
          if (stateMachine && isBurst) {
            clusterChance *= (0.7 + 0.6 * features.recursionN);
          }
          if (sproutMode || isSprout) clusterChance = 0;
          const clusterSeed = seededRandom(spec.seedKey || "", `cluster-trigger:${branchId}:${Math.floor(s)}`);
          if (cluster.remaining <= 0 && clusterSeed < clusterChance && segmentBudget > 60) {
            startCluster();
          }

          // BEGIN PATCH: node cadence uses distance not substep count
          const baseNodeSpacing = wind.nodeSpacingPx || 20;
          let nodeSpacingPx = baseNodeSpacing;
          const hasExplicitNodeSpacing = stateMachine && (
            (isBurst && typeof stateMachine.burstNodeSpacingPx === "number") ||
            (!isBurst && typeof stateMachine.trunkNodeSpacingPx === "number")
          );
          if (stateMachine) {
            if (isBurst && typeof stateMachine.burstNodeSpacingPx === "number") {
              nodeSpacingPx = stateMachine.burstNodeSpacingPx;
            } else if (!isBurst && typeof stateMachine.trunkNodeSpacingPx === "number") {
              nodeSpacingPx = stateMachine.trunkNodeSpacingPx;
            } else {
              nodeSpacingPx *= isBurst ? 0.7 : 1.4;
            }
          }
          if (!hasExplicitNodeSpacing) {
            if (zone.type === "symmetric") nodeSpacingPx *= 0.45;
            if (cluster.remaining > 0) nodeSpacingPx *= 0.8;
          }
          const maxNodeSpacing = (stateMachine && !isBurst) ? 26 : baseNodeSpacing;
          nodeSpacingPx = clamp(nodeSpacingPx, 4, maxNodeSpacing);
          const twigEvery = (stateMachine && isBurst) ? (burstTwigEveryOverride ?? 1) : 999;
          const twigSpacingPx = Math.max(4, nodeSpacingPx * Math.max(1, twigEvery));
          if (isSprout) nodeSpacingPx = clamp(nodeSpacingPx, 6, 12);

          if (zone.type === "symmetric") {
            while (distSinceTwig >= twigSpacingPx) {
              spawnBranchEvent(dir, false, 0);
              distSinceTwig -= twigSpacingPx;
            }
          }

          let spawnedNode = false;
          if (!sproutMode || isSprout) {
            while (distSinceNode >= nodeSpacingPx) {
              spawnBranchEvent(dir, true, 0);
              distSinceNode -= nodeSpacingPx;
              spawnedNode = true;
            }
          }
          if (!spawnedNode) {
            const spawnSeed = seededRandom(spec.seedKey || "", `spawn:${branchId}:${Math.floor(s)}`);
            const spawnProb = (zone.type === "symmetric" ? 0.06 * expoBoost : 0.08 * transBoost) * branchProbScale;
            if ((!sproutMode || isSprout) && spawnSeed < spawnProb && segmentBudget > 40) {
              spawnBranchEvent(dir, false, 0);
            }
          }
          if (isSprout && stepsSinceBranch >= 4 && segmentBudget > 20) {
            if (sproutBranchEvents === 0) {
              spawnBranchEvent(dir, true, 1);
              spawnBranchEvent(dir, true, -1);
            } else {
              spawnBranchEvent(dir, true, 0);
            }
            stepsSinceBranch = 0;
          }
          // BEGIN PATCH: trunk stacked tiers
          if (stateMachine && !isBurst && !sproutMode && trunkTierEvery > 0 && trunkStepIndex > 0 && (trunkStepIndex % trunkTierEvery === 0) && segmentBudget > 20) {
            const tierTheta = (18 + 12 * seededRandom(spec.seedKey || "", `trunk-tier-theta:${trunkStepIndex}`)) * (Math.PI / 180);
            const tierLenScale = 0.35 + 0.2 * seededRandom(spec.seedKey || "", `trunk-tier-len:${trunkStepIndex}`);
            const tierSteps = 2 + Math.floor(seededRandom(spec.seedKey || "", `trunk-tier-steps:${trunkStepIndex}`) * 2);
            branchSerial += 1;
            drawBranchlet(x, y, dir + tierTheta, tierLenScale, tierSteps, branchSerial, "exploratory", 0);
            branchSerial += 1;
            drawBranchlet(x, y, dir - tierTheta, tierLenScale, tierSteps, branchSerial, "exploratory", 0);
          }
          // END PATCH
          if (stateMachine && isBurst && (subStepCount % 9 === 0)) {
            const microThetaSet = (burstBandNorm < 0.45 ? [18, 27] : [18, 27, 36]).map(d => d * (Math.PI / 180));
            let microTheta = microThetaSet[Math.floor(seededRandom(spec.seedKey || "", `micro-theta:${branchId}:${subStepCount}`) * microThetaSet.length)] || (18 * (Math.PI / 180));
            if (recentAngles.length && seededRandom(spec.seedKey || "", `micro-theta-bias:${branchId}:${subStepCount}`) < 0.8) {
              microTheta = pickRecentAngle(`micro-theta-mem:${branchId}:${subStepCount}`) || microTheta;
            }
            const microLenScale = 0.45 + 0.2 * seededRandom(spec.seedKey || "", `micro-len:${branchId}:${subStepCount}`);
            const microSide = (subStepCount % 2 === 0) ? 1 : -1;
            const microDir = burstAxisAngle + microSide * microTheta;
            branchSerial += 1;
            drawBranchlet(x, y, microDir, microLenScale, 1, branchSerial, "symmetric", microSide);
            noteBranchEvent(microTheta, { x, y });
            if (lastBranchOrigin) {
              const crossProb = burstBandNorm < 0.45 ? 1.0 : (burstBandNorm < 0.75 ? 0.6 : 0.2);
              if (seededRandom(spec.seedKey || "", `micro-cross:${branchId}:${subStepCount}`) < crossProb) {
                const towardPrev = Math.atan2(lastBranchOrigin.y - y, lastBranchOrigin.x - x);
                const crossDir = lerpAngle(towardPrev, burstAxisAngle, 0.35);
                const crossLenScale = 0.35 + 0.2 * seededRandom(spec.seedKey || "", `micro-cross-len:${branchId}:${subStepCount}`);
                branchSerial += 1;
                drawBranchlet(x, y, crossDir, crossLenScale, 1, branchSerial, "symmetric", 0);
                noteBranchEvent();
              }
            }
          }
          if (stateMachine && isBurst) {
            const floorSteps = Math.round(18 + (8 - 18) * features.recursionN);
            if (stepsSinceBranch > floorSteps) {
              spawnBranchEvent(dir, true, 0);
              stepsSinceBranch = 0;
            }
          }
          if (stateMachine && state === "TRUNK" && recoveryRemaining > 0) {
            recoveryRemaining -= 1;
            if (recoveryRemaining <= 0) {
              return spec.returnEnd ? { x, y, dir } : null;
            }
          }
          if (state === "BURST") {
            burstRemaining -= ds;
            if (burstRemaining <= 0) {
              state = "TRUNK";
              stepDecay = 1;
              austerityRemaining = stateMachine?.postBurstSteps ?? 22;
            }
          }
          if (stateMachine && state === "TRUNK" && austerityRemaining > 0) {
            austerityRemaining -= 1;
          }
          // END PATCH
        }
      } else if (ch === "+") {
        dir += spec.angle;
      } else if (ch === "-") {
        dir -= spec.angle;
      } else if (ch === "[") {
        // BEGIN PATCH: node cadence uses distance not substep count
        stack.push({ x, y, dir, branchId, branchSign, distSinceNode, distSinceTwig });
        // END PATCH
        branchId += 1;
        branchSign = seededRandom(spec.seedKey || "", `branch:${branchId}`) < 0.5 ? -1 : 1;
        // BEGIN PATCH: node cadence uses distance not substep count
        distSinceNode = 0;
        distSinceTwig = 0;
        // END PATCH
        headingHistory.length = 0;
      } else if (ch === "]") {
        if (stack.length) {
          const s0 = stack.pop();
          x = s0.x; y = s0.y; dir = s0.dir;
          branchId = s0.branchId;
          branchSign = s0.branchSign;
          // BEGIN PATCH: node cadence uses distance not substep count
          distSinceNode = s0.distSinceNode || 0;
          distSinceTwig = s0.distSinceTwig || 0;
          // END PATCH
          pushLeafPoint(x, y, 0.9);
          headingHistory.length = 0;
        }
      }
    }
    pushLeafPoint(x, y, 0.9);
    if (geom && spec.isMainTrunk) {
      geom.trunkMetrics = {
        trunkBudgetSteps,
        trunkStep: trunkStepIndex,
        trunkLenMult
      };
    }
    if (geom?.morphStats) {
      geom.morphStats.segmentsDrawn = (geom.morphStats.segmentsDrawn || 0) + segmentsDrawn;
      geom.morphStats.branchEvents = (geom.morphStats.branchEvents || 0) + branchEvents;
    }
    ctx.restore();
    if (spec.returnEnd) return { x, y, dir };
    return null;
  }

  function drawTree(ctx, opts, forestGeom) {
    const {
      x0, baseY, height, trunkW, branchiness, leaves, crownSpread,
      stress, padT, padL, padR, w, dayLight, recursionN, abstractionN, cohesionN, argumentN, diversityN, tasksN, wordsN, conceptN, weeklyScoreN, weekendScoreN, noteText, recursion, abstraction, cohesion, argument, diversity,
      complexityN,
      seedKey, course, mode,
      effortAbs: effortAbsIn,
      effortTotal: effortTotalIn,
      idleMode: idleModeIn,
      isSprout: isSproutIn,
      sproutN: sproutNIn
    } = opts;

    const captureOnly = !!opts.captureOnly;
    const growthRel = typeof opts.growthRel === "number" ? opts.growthRel : 0;
    const effortAbs = clamp(effortAbsIn || 0, 0, 1);
    const effortTotal = Math.max(0, effortTotalIn || 0);
    const idleMode = !!idleModeIn;
    const effortGate = effortGateFor(effortAbs, idleMode);
    const sproutN = clamp(sproutNIn ?? 0, 0, 1);
    const isSprout = !!isSproutIn;
    const sproutMode = idleMode || isSprout || effortGate <= 0.001;
    const branchGate = clamp(idleMode ? 0.02 : (0.08 + 0.92 * effortGate), 0.01, 1);
    const clusterGate = clamp(idleMode ? 0.01 : (0.06 + 0.94 * effortGate), 0.005, 1);
    // BEGIN PATCH: debug anchor toggle (press "a")
    if (typeof drawTree._debugAnchorsInit === "undefined" && typeof window !== "undefined") {
      drawTree._debugAnchorsInit = true;
      drawTree._debugAnchors = false;
      window.addEventListener("keydown", (e) => {
        if (String(e.key || "").toLowerCase() === "a") {
          drawTree._debugAnchors = !drawTree._debugAnchors;
          try { toast(drawTree._debugAnchors ? "Anchors on" : "Anchors off"); } catch {}
        }
      });
    }
    // END PATCH
    const shouldDraw = !captureOnly;
    const courseId = opts.courseId || course;
    const conceptId = opts.conceptId ?? null;
    const ink = "#000000";
    const geom = {
      course,
      paths: [],
      leafPoints: []
    };
    geom.seedKey = seedKey;
    if (forestGeom?.trees) forestGeom.trees.push(geom);

    // No per-tree background fill to keep forest minimal

      // Draw trunk
      ctx.save();
      if (shouldDraw) {
        ctx.strokeStyle = ink;
        ctx.globalAlpha = 1;
        ctx.lineWidth = trunkW;
        ctx.setLineDash([]);
      }

      const leafPoints = geom.leafPoints;
      const maxRise = Math.min(220, Math.max(60, baseY - padT - 20));
      const effRecursionN = recursionN * effortGate;
      const effAbstractionN = abstractionN * (0.25 + 0.75 * effortGate);
      const effCohesionN = cohesionN * (0.35 + 0.65 * effortGate);
      const effArgumentN = argumentN * (0.35 + 0.65 * effortGate);
      const effDiversityN = diversityN * (0.35 + 0.65 * effortGate);
      const effTasksN = tasksN * effortGate;
      const effWordsN = wordsN * effortGate;
      const lsys = buildLSystemParams({
        recursionScore: effRecursionN,
        abstractionScore: effAbstractionN,
        cohesionScore: effCohesionN,
        argumentScore: effArgumentN,
        diversityScore: effDiversityN,
        tasksN: effTasksN,
        stressN: stress,
        wordsN: effWordsN
      }, height, maxRise, `${seedKey}|${course}`);
      if (sproutMode) {
        lsys.iterations = Math.min(lsys.iterations, 2);
        lsys.rules = { "F": "F[+F]F[-F]F" };
      }
      geom.morphStats = {
        effortAbs,
        effortTotal,
        idleMode,
        isSprout,
        sproutN,
        recDepth: lsys.iterations,
        branchProb: branchGate,
        clusterProb: clusterGate
      };
      geom.leafSettings = {
        enabled: lsys.leavesEnabled !== false,
        leafBasePx: lsys.leafBasePx ?? 1.4,
        leafBurstMult: lsys.leafBurstMult ?? 1.6,
        leafTrunkMult: lsys.leafTrunkMult ?? 0.7,
        leafMinDist: lsys.leafMinDist ?? 8,
        leafCoreSuppression: lsys.leafCoreSuppression ?? 0.5,
        leafMaxPerTree: lsys.leafMaxPerTree ?? 900
      };
      lsys.courseId = courseId;
      lsys.conceptId = conceptId;
      if (opts.debug?.enabled) {
        lsys.winding = lsys.winding || {};
        if (typeof opts.debug.maxInternodePx === "number") lsys.winding.maxInternodePx = opts.debug.maxInternodePx;
        if (typeof opts.debug.nodeSpacingPx === "number") lsys.winding.nodeSpacingPx = opts.debug.nodeSpacingPx;
      }
      const growthN = clamp(effortGate, 0, 1);
      const runScale = 0.08 + 0.92 * growthN;
      const fitScale = clamp((baseY - padT - 20) / Math.max(1, height * 1.6), 0.4, 1);
      const stepJitter = 0.9 + (seededRandom(seedKey, "step") - 0.5) * 0.18;
      lsys.step *= runScale * fitScale * stepJitter;
      const heightScale = clamp(1 - (lsys.iterations - 2) * 0.12, 0.55, 1);
      const trunkLenScale = sproutMode ? 0.25 : (0.35 + 0.65 * effortGate);
      const trunkLen = height * dayLight * heightScale * trunkLenScale;
      const angleBias = 0.28 + 0.45 * (1 - weeklyScoreN);
      const angleSign = (tasksN - 0.5) >= 0 ? 1 : -1;
      const angleJitter = (seededRandom(seedKey, "angle") - 0.5) * 0.4;
      const trunkAngle = -Math.PI / 2 + angleSign * angleBias + angleJitter;
      const trunkJitter = (seededRandom(seedKey, "trunk") - 0.5) * 12;
      const trunkBaseX = clamp(x0 + trunkJitter, padL + 4, w - padR - 4);
      // BEGIN PATCH: trunk uses internode stepping polyline
      const trunkWind = lsys.winding || {};
      const trunkMaxStep = Math.max(2, trunkWind.maxInternodePx || lsys.step || 12);
      const trunkStep = Math.max(2, Math.min(lsys.step || trunkMaxStep, trunkMaxStep));
      const trunkNodeSpacing = trunkWind.nodeSpacingPx || 20;
      let trunkDistSinceNode = 0;
      const trunkNodes = [];
      let tx = trunkBaseX;
      let ty = baseY;
      let remaining = trunkLen;
      let trunkSegments = 0;
      const trunkMaxSegments = 1200;
      while (remaining > 0.001 && trunkSegments < trunkMaxSegments) {
        let ds = Math.min(trunkStep, trunkMaxStep, remaining);
        let nx = tx + Math.cos(trunkAngle) * ds;
        let ny = ty + Math.sin(trunkAngle) * ds;
        if (ny < padT + 8) {
          ny = padT + 8;
          ds = Math.hypot(nx - tx, ny - ty);
          remaining = 0;
        }
        const t = trunkLen ? (1 - remaining / trunkLen) : 1;
        const trunkWNow = trunkW * (0.95 - 0.45 * t);
        if (shouldDraw && TRUNK_VISIBLE) {
          ctx.beginPath();
          ctx.moveTo(tx, ty);
          ctx.lineTo(nx, ny);
          ctx.lineWidth = trunkWNow;
          ctx.stroke();
        }
        geom.paths.push({
          x1: tx, y1: ty, x2: nx, y2: ny,
          stroke: ink,
          sw: TRUNK_VISIBLE ? trunkWNow : 0,
          alpha: TRUNK_VISIBLE ? (0.33 + 0.22 * stress) : 0,
          type: "trunk",
          courseId,
          conceptId,
          zoneType: "trunk"
        });
        const dsActual = Math.hypot(nx - tx, ny - ty);
        trunkDistSinceNode += dsActual;
        if (trunkDistSinceNode >= trunkNodeSpacing) {
          trunkNodes.push({ x: nx, y: ny });
          trunkDistSinceNode -= trunkNodeSpacing;
        }
        tx = nx; ty = ny;
        remaining -= ds;
        trunkSegments += 1;
      }
      const trunkTop = { x: tx, y: ty };
      geom.trunkNodes = trunkNodes;
      ctx.restore();
      // END PATCH
      const lean = clamp((tasksN - 0.5) * 0.12 + (stress - 0.5) * 0.08 + (argumentN - 0.5) * 0.05 + angleJitter * 0.35, -0.25, 0.25);
      const collision = new Set();
      // BEGIN PATCH: trunk → burst → trunk anchors
      const normNote = normalizeText(noteText || "");
      const conceptTokens = normNote
        ? Array.from(new Set([
          ...topNWords(normNote, 6).map((x) => x.w),
          ...keyPhrases(noteText, 6).map((p) => p.replace(/[^a-z0-9\s]/gi, "").trim()).filter(Boolean)
        ].filter(Boolean)))
        : [];
      const tokenAnchorCount = normNote ? conceptTokens.length : 0;
      const fallbackCount = clamp(5 + Math.floor(recursionN * 6), 5, 10);
      const conceptCount = tokenAnchorCount >= 3 ? tokenAnchorCount : (trunkNodes.length ? fallbackCount : 0);
      const anchors = [];
      if (conceptCount && trunkNodes.length) {
        const n = trunkNodes.length;
        const startIdx = Math.max(0, Math.floor(n * 0.1));
        const endIdx = Math.max(startIdx + 1, Math.floor(n * 0.9));
        const courseCount = Math.max(1, (state?.courses || []).length || 1);
        const cellW = w / courseCount;
        const minAnchorDistPx = clamp(35 + cellW * 0.08, 35, 60);
        const used = new Set();
        let last = null;
        let minDist = minAnchorDistPx;
        for (let pass = 0; pass < 2 && anchors.length < conceptCount; pass++) {
          for (let i = 0; i < conceptCount; i++) {
            const t = (i + 1) / (conceptCount + 1);
            const idx = Math.max(startIdx, Math.min(endIdx, Math.round(startIdx + (endIdx - startIdx) * t)));
            if (used.has(idx)) continue;
            const candidate = trunkNodes[idx];
            if (!candidate) continue;
            if (last) {
              const d = Math.hypot(candidate.x - last.x, candidate.y - last.y);
              if (d < minDist) continue;
            }
            used.add(idx);
            anchors.push({
              ...candidate,
              nodeIndex: idx,
              conceptId: tokenAnchorCount >= 3 ? (conceptTokens[i] || `concept-${i + 1}`) : `anchor-${anchors.length + 1}`
            });
            last = candidate;
            if (anchors.length >= conceptCount) break;
          }
          minDist *= 0.7;
        }
      } else if (conceptCount) {
        anchors.push({ x: trunkTop.x, y: trunkTop.y, nodeIndex: 0, conceptId: "anchor-1" });
      }

      if (sproutMode) {
        const sproutSpec = {
          ...lsys,
          iterations: Math.min(lsys.iterations, 2),
          rules: lsys.rules,
          stateMachine: null,
          growthRel,
          effortAbs,
          effortGate,
          branchGate,
          clusterGate,
          idleMode,
          sproutMode,
          isSprout,
          sproutN
        };
        sproutSpec.step = Math.max(3, sproutSpec.step);
        drawLSystem(ctx, trunkTop, -Math.PI / 2 + lean, sproutSpec, leafPoints, ink, geom, padT + 8, runScale * fitScale * 0.4, collision, captureOnly);
      } else if (growthN > 0.05) {
        const trunkSpec = {
          ...lsys,
          stateMachine: {
            startState: "TRUNK",
            trunkStepScale: 1.35,
            trunkBranchProbScale: 0.2,
            trunkClusterProbScale: 0.15,
            trunkMaxInternodePx: 15,
            trunkNodeSpacingPx: 22,
            trunkNoiseScale: 0.4,
            trunkTurnScale: 0.35,
            burstDurationSteps: 0
          },
          growthRel,
          effortAbs,
          effortGate,
          branchGate,
          clusterGate,
          idleMode,
          sproutMode,
          isSprout,
          sproutN,
          isMainTrunk: true
        };
        drawLSystem(ctx, trunkTop, -Math.PI / 2 + lean, trunkSpec, leafPoints, ink, geom, padT + 8, runScale * fitScale * 0.7, collision, captureOnly);

        const burstDuration = Math.round(140 + 180 * recursionN);
        const burstBudgetBonus = Math.round(250 + 350 * recursionN);
        const burstDecay = 0.995 - 0.01 * recursionN;
        const burstMinLen = Math.max(1.2, lsys.step * (0.8 - 0.2 * recursionN));
        const burstMaxInternodePx = clamp(7 - 4 * recursionN, 3, 7);
        const burstNodeSpacingPx = clamp(10 - 5 * recursionN, 5, 10);
        const burstMaxRadiusPx = clamp(110 - 55 * recursionN, 55, 110);
        anchors.forEach((anchor, i) => {
          // debug anchor overlay
          if (drawTree._debugAnchors) {
            geom.paths.push({
              type: "circle",
              cx: anchor.x,
              cy: anchor.y,
              r: 3.2,
              stroke: "#111111",
              sw: 1.2,
              alpha: 0.9,
              fill: "rgba(0,0,0,0.08)",
              fillAlpha: 1,
              courseId,
              conceptId: anchor.conceptId,
              zoneType: "debug-anchor"
            });
            geom.paths.push({
              type: "circle",
              cx: anchor.x,
              cy: anchor.y,
              r: burstMaxRadiusPx,
              stroke: "rgba(0,0,0,0.25)",
              sw: 0.8,
              alpha: 0.4,
              fill: "none",
              fillAlpha: 0,
              courseId,
              conceptId: anchor.conceptId,
              zoneType: "debug-burst-radius"
            });
          }
          // compute tangent + kick-out heading
          const nodeIdx = Math.max(0, Math.min(trunkNodes.length - 1, anchor.nodeIndex || 0));
          const prev = trunkNodes[Math.max(0, nodeIdx - 1)] || anchor;
          const next = trunkNodes[Math.min(trunkNodes.length - 1, nodeIdx + 1)] || anchor;
          const tan = Math.atan2((next.y - prev.y) || Math.sin(trunkAngle), (next.x - prev.x) || Math.cos(trunkAngle));
          const kickSign = i % 2 === 0 ? 1 : -1;
          const kickDeg = 25 + 30 * seededRandom(seedKey, `kick:${i}`);
          const burstAngle = tan + kickSign * (kickDeg * (Math.PI / 180));

          // short kick phase to push off trunk
          let kx = anchor.x;
          let ky = anchor.y;
          const kickSteps = 4 + Math.floor(seededRandom(seedKey, `kick-steps:${i}`) * 5);
          const kickStep = Math.max(2, (burstMaxInternodePx || 6) * 0.45);
          for (let k = 0; k < kickSteps; k++) {
            const nx = kx + Math.cos(burstAngle) * kickStep;
            const ny = ky + Math.sin(burstAngle) * kickStep;
            if (!captureOnly) {
              ctx.beginPath();
              ctx.moveTo(kx, ky);
              ctx.lineTo(nx, ny);
              ctx.strokeStyle = ink;
              ctx.lineWidth = 0.7;
              ctx.stroke();
            }
            geom.paths.push({
              x1: kx, y1: ky, x2: nx, y2: ny,
              stroke: ink,
              sw: 0.7,
              alpha: 1,
              type: "kick",
              courseId,
              conceptId: anchor.conceptId,
              zoneType: "burst-kick"
            });
            kx = nx; ky = ny;
          }

          const burstSpec = {
            ...lsys,
            seedKey: `${lsys.seedKey}|burst:${i}`,
            conceptId: anchor.conceptId,
            returnEnd: true,
            growthRel,
            effortAbs,
            effortGate,
            branchGate,
            clusterGate,
            idleMode,
            sproutMode,
            isSprout,
            sproutN,
            stateMachine: {
              startState: "BURST",
              burstDurationSteps: burstDuration,
              burstBudgetBonus,
              burstDecay,
              burstMinLen,
              burstStepScale: 0.55,
              trunkStepScale: 1.2,
              burstBranchProbScale: 2 + 2 * recursionN,
              trunkBranchProbScale: 0.2,
              burstClusterProbScale: 1.6,
              trunkClusterProbScale: 0.2,
              burstMaxInternodePx,
              burstNodeSpacingPx,
              burstAxisAngle: burstAngle,
              burstOrigin: { x: anchor.x, y: anchor.y },
              burstMaxRadiusPx,
              burstNoiseScale: 0.5,
              burstTurnScale: 0.65,
              burstTwigStepScale: 0.35
            }
          };
          const end = drawLSystem(ctx, { x: kx, y: ky }, burstAngle, burstSpec, leafPoints, ink, geom, padT + 8, runScale * fitScale * 0.85, collision, captureOnly);
          if (end) {
            const recoverySteps = 20 + Math.floor(seededRandom(seedKey, `recovery:${i}`) * 20);
            const recoverySpec = {
              ...lsys,
              seedKey: `${lsys.seedKey}|recovery:${i}`,
              conceptId: anchor.conceptId,
              growthRel,
              effortAbs,
              effortGate,
              branchGate,
              clusterGate,
              idleMode,
              sproutMode,
              isSprout,
              sproutN,
              stateMachine: {
                startState: "TRUNK",
                recoverySteps,
                trunkStepScale: 1.25,
                trunkBranchProbScale: 0.05,
                trunkClusterProbScale: 0.05,
                trunkMaxInternodePx: 16,
                trunkNodeSpacingPx: 24,
                trunkNoiseScale: 0.35,
                trunkTurnScale: 0.3
              }
            };
            drawLSystem(ctx, { x: end.x, y: end.y }, end.dir, recoverySpec, leafPoints, ink, geom, padT + 8, runScale * fitScale * 0.6, collision, captureOnly);
          }
        });
      }
      // END PATCH

      // Leaves are drawn in a geometry-driven post-pass (renderForest) using geom.leafPoints.

      // Course labels (horizontal below sprout)
      if (shouldDraw) {
        ctx.save();
        ctx.fillStyle = ink;
        ctx.globalAlpha = 1;
        ctx.font = "600 12px " + getCSSVar("--sans");
        const labelX = clamp(x0, padL + 4, w - padR - 4);
        const labelY = Math.min(baseY + 16, baseY + 26);
        ctx.textAlign = "center";
        ctx.fillText(course, labelX, labelY);
        ctx.restore();
      }
    return geom;
  }

  // Debounced forest updates while typing
  const debouncedForest = (() => {
    const regen = debounce(() => {
      try {
        renderForestFrame({ allowRegen: true });
      } catch (err) {
        console.error("renderForest failed", err);
        try { toast("Forest render failed (see console)"); } catch {}
      }
    }, 180);
    return () => {
      markForestDirty();
      regen();
    };
  })();

  const debouncedGraph = debounce(() => {
    try { renderConceptGraph(); } catch {}
  }, 220);

  // ---------- Hydration ----------
  function setPrintPreview(enabled) {
    state.printPreview = !!enabled;
    saveState();
    document.body.classList.toggle("print-preview", state.printPreview);
    toast(state.printPreview ? "Print preview on" : "Print preview off");
  }

  function hydrateInputs() {
    intentEl.value = state.intent || "";
    coreWindowEl.value = state.coreWindow || "";
    weekendPostureEl.value = state.weekendPosture || "";
    rebalanceDayEl.value = state.rebalanceDay || "Sunday";
    if (themeSelectEl) themeSelectEl.value = state.theme || "soft";
    applyTheme(state.theme || "soft");

    absorptionEl.value = state.absorption || "";
    workoutEl.value = state.workout || "";
    todayNotesEl.value = state.todayNotes || "";

    courseListEl.value = state.courses.join("; ");

    writingScheduleEl.value = state.writingSchedule || "";
    writingThreadEl.value = state.writingThread || "";
    writingTargetsEl.value = state.writingTargets || "";
    writingNotesEl.value = state.writingNotes || "";

    proseScheduleEl.value = state.proseSchedule || "";
    proseProjectEl.value = state.proseProject || "";
    proseTargetsEl.value = state.proseTargets || "";
    proseNotesEl.value = state.proseNotes || "";
    if (graphSpacingEl) graphSpacingEl.value = String(graphSpacing);

    if (openaiKeyEl) openaiKeyEl.value = state.llmKey || "";
    downtimeRuleEl.value = state.downtimeRule || "";

    renderModeChips();
    renderKeystoneDropdown();
    renderCourseCards();
    renderTasks();
    renderWeekSummary();
    renderConceptGraph();
    setupCardToggles();

    if (state.mdCache) mdPreviewEl.textContent = state.mdCache;

    forestLegendEl.classList.toggle("show", !!state.forest.legendOn);
    toggleHiResPngEl.checked = !!state.forest.hiResPng;
    if (toggleFullGhostEl) toggleFullGhostEl.checked = !!state.forest.showFullGhost;
    document.body.classList.toggle("print-preview", !!state.printPreview);
    updateFocusUi();
    debouncedForest();
  }

  // ---------- Wire up ----------
    // ---------- Wire up ----------
    intentEl.addEventListener("input", () => { state.intent = intentEl.value; saveState(); });
  coreWindowEl.addEventListener("input", () => { state.coreWindow = coreWindowEl.value; saveState(); });
  weekendPostureEl.addEventListener("input", () => { state.weekendPosture = weekendPostureEl.value; saveState(); });
  rebalanceDayEl.addEventListener("change", () => { state.rebalanceDay = rebalanceDayEl.value; saveState(); });
  themeSelectEl?.addEventListener("change", () => { applyTheme(themeSelectEl.value); });

  keystoneTodayEl.addEventListener("change", () => {
    state.keystoneToday = keystoneTodayEl.value;
    saveState();
    renderWeekSummary();
    debouncedForest();
  });

  absorptionEl.addEventListener("input", () => {
    state.absorption = absorptionEl.value;
    saveState();
  });

  workoutEl.addEventListener("input", () => {
    state.workout = workoutEl.value;
    saveState();
  });

  todayNotesEl.addEventListener("input", () => {
    state.todayNotes = todayNotesEl.value;
    saveState();
    debouncedForest();
    debouncedGraph();
  });

  courseListEl.addEventListener("keydown", (e) => {
    if (e.key === "Enter") { e.preventDefault(); el("btnApplyCourses").click(); }
  });

  writingScheduleEl.addEventListener("input", () => { state.writingSchedule = writingScheduleEl.value; saveState(); debouncedGraph(); });
  writingThreadEl.addEventListener("input", () => { state.writingThread = writingThreadEl.value; saveState(); debouncedGraph(); });
  writingTargetsEl.addEventListener("input", () => { state.writingTargets = writingTargetsEl.value; saveState(); debouncedGraph(); });
  writingNotesEl.addEventListener("input", () => { state.writingNotes = writingNotesEl.value; saveState(); debouncedGraph(); });

  proseScheduleEl.addEventListener("input", () => { state.proseSchedule = proseScheduleEl.value; saveState(); debouncedGraph(); });
  proseProjectEl.addEventListener("input", () => { state.proseProject = proseProjectEl.value; saveState(); debouncedGraph(); });
  proseTargetsEl.addEventListener("input", () => { state.proseTargets = proseTargetsEl.value; saveState(); debouncedGraph(); });
  proseNotesEl.addEventListener("input", () => { state.proseNotes = proseNotesEl.value; saveState(); debouncedGraph(); });

  downtimeRuleEl.addEventListener("input", () => { state.downtimeRule = downtimeRuleEl.value; saveState(); });

  if (openaiKeyEl) {
    openaiKeyEl.addEventListener("input", () => {
      state.llmKey = openaiKeyEl.value;
      saveState();
    });
  }

  // Mode editor
  el("btnAddMode").addEventListener("click", () => {
    const label = String(newModeLabelEl.value || "").trim();
    if (!label) { toast("Mode label is empty"); return; }
    if (state.modeChecks[label]) { toast("Mode already exists"); return; }
    const scope = newModeScopeEl.value === "daily" ? "daily" : "weekly";
    state.modeChecks[label] = false;
    state.modeScope[label] = scope;
    newModeLabelEl.value = "";
    saveState();
    renderModeChips();
    renderWeekSummary();
    debouncedForest();
  });

  // ---------- Buttons ----------

    // ---------- Buttons ----------
    el("btnAddTodayTask").addEventListener("click", () => {
      state.todayTasks.push({ id: uid(), done: false, title: "", course: state.keystoneToday || state.courses[0], mode: "(mode)" });
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
      toast("Added Today task");
      // focus newest title
      setTimeout(() => {
        const rows = todayTasksEl.querySelectorAll(".task input.title");
        rows[rows.length - 1]?.focus();
      }, 0);
    });

    el("btnClearTodayDone").addEventListener("click", () => {
      state.todayTasks = state.todayTasks.filter(t => !t.done);
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
      toast("Cleared completed Today tasks");
    });

    el("btnAddWeekendTask").addEventListener("click", () => {
      state.weekendTasks.push({ id: uid(), done: false, title: "", course: state.courses[0], mode: "(mode)" });
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
      toast("Added Weekend deliverable");
      setTimeout(() => {
        const rows = weekendTasksEl.querySelectorAll(".task input.title");
        rows[rows.length - 1]?.focus();
      }, 0);
    });

    el("btnClearWeekendDone").addEventListener("click", () => {
      state.weekendTasks = state.weekendTasks.filter(t => !t.done);
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
      toast("Cleared completed Weekend tasks");
    });

    el("btnApplyCourses").addEventListener("click", () => {
      const raw = String(courseListEl.value || "");
      const list = raw.split(";").map(x => x.trim()).filter(Boolean);

      if (!list.length) {
        toast("Course list is empty");
        return;
      }

      // Preserve existing notes where possible
      const old = state.courseNotes || {};
      const nextNotes = {};
      list.forEach(c => { nextNotes[c] = old[c] || { status: "steady", focus: "", budget: "", notes: "" }; });

      // Update tasks that pointed to removed courses -> move to first course
      const fallback = list[0];
      for (const t of [...state.todayTasks, ...state.weekendTasks]) {
        if (!list.includes(t.course)) t.course = fallback;
      }

      state.courses = list;
      state.courseNotes = nextNotes;

      if (!list.includes(state.keystoneToday)) state.keystoneToday = fallback;

      saveState();
      renderKeystoneDropdown();
      renderCourseCards();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
      toast("Applied courses");
    });

    // Markdown export buttons
    el("btnGenerateMd").addEventListener("click", async () => {
      if (openaiKeyEl && openaiKeyEl.value.trim()) {
        state.llmKey = openaiKeyEl.value.trim();
        saveState();
      }
      let usedGpt = false;
      if (state.llmKey) {
        try {
          const analyses = { ...(state.llmNoteAnalyses || {}) };
          for (const course of state.courses || []) {
            const noteText = state.courseNotes?.[course]?.notes || "";
            if (!noteText.trim()) continue;
            const res = await analyzeNotesWithGpt(course, noteText);
            if (res) analyses[course] = res;
          }
          state.llmNoteAnalyses = analyses;
          const response = await generateGptConferenceResponse();
          if (response) state.llmConferenceResponse = response;
          saveState();
          usedGpt = true;
        } catch (err) {
          console.warn("GPT markdown helpers failed", err);
          toast("GPT failed (fallback used)");
        }
      }
      const md = generateMarkdown({ forestFilename: "forest.jpg", graphFilename: "concept_graph.jpg" });
      setMdPreview(md);
      toast(usedGpt ? "Generated markdown (GPT)" : "Generated markdown");
    });

    el("btnCopyMd").addEventListener("click", async () => {
      const md = state.mdCache || generateMarkdown({ forestFilename: "forest.jpg", graphFilename: "concept_graph.jpg" });
      setMdPreview(md);
      try {
        await navigator.clipboard.writeText(md);
        toast("Copied");
      } catch {
        toast("Copy failed (browser blocked)");
      }
    });

    el("btnDownloadMd").addEventListener("click", () => {
      const md = state.mdCache || generateMarkdown({ forestFilename: "forest.jpg", graphFilename: "concept_graph.jpg" });
      setMdPreview(md);
      downloadText("download.md", md, "text/markdown");
      toast("Downloaded .md");
    });

    el("btnClearMd").addEventListener("click", () => {
      state.mdCache = "";
      saveState();
      mdPreviewEl.textContent = "(Generate markdown to preview here.)";
      toast("Cleared markdown");
    });

    el("btnArchiveBundle").addEventListener("click", async () => {
      try {
        const md = state.mdCache || generateMarkdown({ forestFilename: "forest.jpg", graphFilename: "concept_graph.jpg" });
        setMdPreview(md);
        const d = new Date();
        const yyyy = d.getFullYear();
        const mm = String(d.getMonth() + 1).padStart(2, "0");
        const dd = String(d.getDate()).padStart(2, "0");
        const folder = `Dashboard_${yyyy}-${mm}-${dd}`;
        const forestName = `${folder}/forest.jpg`;
        const graphName = `${folder}/concept_graph.jpg`;
        const mdName = `${folder}/Dashboard_${yyyy}-${mm}-${dd}.md`;
        const forestUrl = forestCardDataUrl("image/jpeg", 0.92, state.forest.hiResPng ? 2 : 1);
        const graphUrl = conceptGraphPngDataUrl(1, "image/jpeg", 0.92);
        const mdBytes = textToUint8(md);
        const forestBytes = forestUrl ? dataUrlToUint8(forestUrl) : new Uint8Array();
        const graphBytes = graphUrl ? dataUrlToUint8(graphUrl) : new Uint8Array();
        const zip = zipFiles([
          { name: mdName, data: mdBytes },
          ...(forestUrl ? [{ name: forestName, data: forestBytes }] : []),
          ...(graphUrl ? [{ name: graphName, data: graphBytes }] : [])
        ]);
        const blob = new Blob([zip], { type: "application/zip" });
        downloadBlob(`Dashboard_${yyyy}-${mm}-${dd}.zip`, blob);
        toast("Downloaded archive bundle");
      } catch {
        toast("Archive bundle failed");
      }
    });

    // Reset day/week checkboxes
    el("btnResetDay").addEventListener("click", () => {
      state.absorption = "";
      state.workout = "";
      state.todayNotes = "";
      state.writingSchedule = "";
      state.writingThread = "";
      state.writingTargets = "";
      state.writingNotes = "";
      state.proseSchedule = "";
      state.proseProject = "";
      state.proseTargets = "";
      state.proseNotes = "";
      state.mdCache = "";
      saveState();
      hydrateInputs();
      mdPreviewEl.textContent = "(Generate markdown to preview here.)";
      toast("Cleared daily inputs");
    });

    el("btnResetWeek").addEventListener("click", () => {
      if (!lastForestGeom) renderForest();
      saveWeeklyArchive(state.forest.weekly);
      saveGhostSnapshot(getLegacyForest().weekId || currentWeekId());
      state.todayTasks = [];
      state.weekendTasks = [];
      state.todayNotes = "";
      state.writingNotes = "";
      state.writingThread = "";
      state.writingTargets = "";
      state.proseNotes = "";
      state.proseProject = "";
      state.proseTargets = "";
      Object.keys(state.courseNotes || {}).forEach((course) => {
        state.courseNotes[course].notes = "";
        state.courseNotes[course].status = "steady";
      });
      state.llmNoteAnalyses = {};
      state.llmConferenceResponse = "";
      const legacy = getLegacyForest();
      legacy.perCourseMax = {};
      legacy.weekId = currentWeekId();
      state.forest.weekly = { weekId: legacy.weekId, courses: {} };
      saveState();
      invalidateForestCaches();
      renderModeChips();
      renderTasks();
      renderCourseCards();
      renderWeekSummary();
      debouncedForest();
      toast("Reset week");
    });

    // Backup / reset
    el("btnBackup").addEventListener("click", () => {
      try {
        const dateISO = new Date().toISOString().slice(0,10);
        downloadText(`semester-dashboard_backup_${dateISO}.json`, JSON.stringify(state, null, 2), "application/json");
        toast("Exported JSON");
      } catch {
        toast("Export failed");
      }
    });

    btnImportEl?.addEventListener("click", () => {
      importFileEl?.click();
    });

    importFileEl?.addEventListener("change", async () => {
      const file = importFileEl.files?.[0];
      if (!file) return;
      try {
        const rawText = await file.text();
        const raw = JSON.parse(rawText);
        applyImportedState(raw);
        toast("Imported JSON");
      } catch {
        toast("Import failed (invalid JSON)");
      } finally {
        importFileEl.value = "";
      }
    });

    btnSaveVaultEl?.addEventListener("click", async () => {
      await saveArchiveToVault();
    });

    el("btnHardReset").addEventListener("click", () => {
      const ok = confirm("Hard reset will wipe all locally saved dashboard data. Continue?");
      if (!ok) return;
      try { localStorage.removeItem(STORAGE_KEY); } catch {}
      state = structuredDefault();
      saveState();
      hydrateInputs();
      toast("Wiped local data");
    });

    el("btnPrintPreview").addEventListener("click", () => {
      setPrintPreview(!state.printPreview);
    });

    el("btnExitPrintPreview").addEventListener("click", () => {
      setPrintPreview(false);
    });

    focusBackEl?.addEventListener("click", () => {
      exitFocusMode();
    });

    forestCanvas?.addEventListener("click", (e) => {
      const rect = forestCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const hit = lastCourseCells.find((cell) =>
        x >= cell.x && x <= cell.x + cell.w && y >= cell.y && y <= cell.y + cell.h
      );
      if (!hit?.course) return;
      if (focusMode === "grid") {
        setFocusCourse(hit.course, "hybrid");
      } else if (focusMode === "hybrid") {
        if (hit.course === focusedCourse) {
          setFocusMode("focus");
        } else {
          setFocusCourse(hit.course, "hybrid");
        }
      }
    });

    document.addEventListener("keydown", (e) => {
      const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
      const isTyping = tag === "input" || tag === "textarea" || e.target?.isContentEditable;
      if (e.key === "Escape") {
        exitFocusMode();
        return;
      }
      if (isTyping) return;
      if (String(e.key || "").toLowerCase() === "f") {
        if (focusMode === "focus") {
          setFocusMode("hybrid");
        } else if (focusMode === "hybrid") {
          setFocusMode("focus");
        }
        return;
      }
      if (String(e.key || "").toLowerCase() === "d") {
        scaleDebugOn = !scaleDebugOn;
        renderScaleDebug();
        return;
      }
      if (String(e.key || "").toLowerCase() === "b") {
        DEBUG_FOREST.showBBoxes = !DEBUG_FOREST.showBBoxes;
        debouncedForest();
        return;
      }
      if (String(e.key || "").toLowerCase() === "l") {
        leavesEnabled = !leavesEnabled;
        debouncedForest();
        return;
      }
      const key = String(e.key || "").trim();
      if (!/^[1-9]$/.test(key)) return;
      const idx = Number(key) - 1;
      const course = state.courses?.[idx];
      if (course) setFocusCourse(course);
    });

    // Forest controls
    el("btnToggleLegend").addEventListener("click", () => {
      state.forest.legendOn = !state.forest.legendOn;
      saveState();
      forestLegendEl.classList.toggle("show", !!state.forest.legendOn);
      toast(state.forest.legendOn ? "Legend on" : "Legend off");
    });

    toggleHiResPngEl.addEventListener("change", () => {
      state.forest.hiResPng = !!toggleHiResPngEl.checked;
      saveState();
      toast(state.forest.hiResPng ? "Hi-res JPG on" : "Hi-res JPG off");
    });

    if (toggleFullGhostEl) {
      toggleFullGhostEl.addEventListener("change", () => {
        state.forest.showFullGhost = !!toggleFullGhostEl.checked;
        saveState();
        debouncedForest();
        toast(state.forest.showFullGhost ? "Full ghost on" : "Full ghost off");
      });
    }

    el("btnExportPNG").addEventListener("click", () => {
      try {
        const dateISO = new Date().toISOString().slice(0,10);
        const url = forestCardDataUrl("image/jpeg", 0.92, state.forest.hiResPng ? 2 : 1);
        downloadDataUrl(`forest_${dateISO}.jpg`, url);
        toast("Exported JPG");
      } catch {
        toast("JPG export failed");
      }
    });

    el("btnExportSVG").addEventListener("click", () => {
      try {
        if (!lastForestGeom) renderForest();
        const dateISO = new Date().toISOString().slice(0,10);
        const svg = forestToSVG(lastForestGeom);
        downloadText(`forest_${dateISO}.svg`, svg, "image/svg+xml");
        toast("Exported SVG");
      } catch {
        toast("SVG export failed");
      }
    });


    btnSimForest?.addEventListener("click", () => {
      state.forest.simulateMax = !state.forest.simulateMax;
      saveState();
      invalidateForestCaches();
      debouncedForest();
      toast(state.forest.simulateMax ? "Simulation on" : "Simulation off");
    });
    el("btnClearGhost").addEventListener("click", () => {
      const current = currentWeekId();
      const prev = prevIsoWeekId(current);
      clearGhostSnapshot(prev);
      debouncedForest();
      toast("Cleared last-week ghost");
    });

    document.addEventListener("click", (e) => {
      if (!expandedCard) return;
      if (expandedCard.contains(e.target)) return;
      if (e.target.closest(".card-toggle")) return;
      setCardFocus(expandedCard, false);
    });

    // ---------- Responsive: rerender canvas on resize ----------
    window.addEventListener("resize", debounce(() => {
      debouncedForest();
    }, 120));

  async function fetchMaineEnvironment() {
    try {
      const url = "https://api.open-meteo.com/v1/forecast?latitude=43.6591&longitude=-70.2568&current_weather=true&hourly=relativehumidity_2m,cloudcover&timezone=America%2FNew_York";
      const res = await fetch(url);
      if (!res.ok) throw new Error("weather fetch failed");
      const data = await res.json();
      const current = data.current_weather || {};
      const hourly = data.hourly || {};
      const timeIndex = hourly.time ? hourly.time.indexOf(current.time) : -1;
      const humidity = timeIndex >= 0 ? hourly.relativehumidity_2m?.[timeIndex] : null;
      const cloudCover = timeIndex >= 0 ? hourly.cloudcover?.[timeIndex] : null;
      state.env = {
        temperature: current.temperature ?? 12,
        windSpeed: current.windspeed ?? 6,
        humidity: humidity ?? 65,
        cloudCover: cloudCover ?? 40,
        updated: current.time || new Date().toISOString()
      };
      saveState();
      debouncedForest();
    } catch {
      state.env = state.env || { temperature: 12, windSpeed: 6, humidity: 65, cloudCover: 40, updated: new Date().toISOString() };
      saveState();
    }
  }

  // ---------- Init ----------
  // Ensure weekId is set early to support ghost logic without flicker
  const bootWeekId = currentWeekId();
  if (getLegacyForest().weekId !== bootWeekId) getLegacyForest().weekId = bootWeekId;
  getWeeklyStore(bootWeekId);
    hydrateInputs();
  fetchMaineEnvironment();

    // If first load has no md cache, show empty but ready
    if (!state.mdCache) mdPreviewEl.textContent = "(Generate markdown to preview here.)";

  </script>
</body>
</html>
