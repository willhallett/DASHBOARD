<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Semester Dashboard — Modes + .md Export</title>
  <style>
    :root {
      --bg: #ffffff;
      --panel: #ffffff;
      --panel2: #ffffff;
      --text: #5a5a5a;
      --muted: #a7a8b6;
      --line: #dbdbdb;
      --accent: #f5f5ff;
      --chip: #cacbd1bf;
      --danger: #ff5c7a;
      --ok: #5cffc4;
      --warn: #ffd15c;
      --radius: 16px;
      --shadow: 0 10px 30px rgba(144, 144, 144, 0.35);
      --shadowSoft: 0 6px 18px rgba(144, 144, 144, 0.22);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --ink: #3a3d5e;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: var(--sans);
      background: radial-gradient(1200px 900px at 20% 0%, #ffffff 0%, var(--bg) 55%);
      color: var(--text);
    }
    :focus-visible { outline: 2px solid var(--ink); outline-offset: 2px; border-radius: 10px; }

    header {
      position: sticky;
      top: 0;
      z-index: 10;
      backdrop-filter: blur(10px);
      background: rgba(255, 255, 255, 0.7);
      border-bottom: 1px solid var(--line);
    }
    .wrap { max-width: 1180px; margin: 0 auto; padding: 18px 18px 48px; }
    .topbar {
      display: grid;
      grid-template-columns: 1.4fr 1fr;
      gap: 14px;
      align-items: start;
    }
    h1 { margin: 4px 0 2px; font-size: 18px; letter-spacing: .2px; }
    .subtitle { color: var(--muted); font-size: 13px; line-height: 1.4; }
    .controls {
      display: flex; gap: 10px; justify-content: flex-end; flex-wrap: wrap;
    }
    button, .btn {
      border: 1px solid var(--line);
      background: linear-gradient(180deg, #ffffff, #e6e6e6);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      cursor: pointer;
      box-shadow: var(--shadowSoft);
      font-weight: 600;
      font-size: 13px;
    }
    button:hover { border-color: var(--ink); }
    button:active { transform: translateY(1px); }
    .btn-secondary { background: linear-gradient(180deg, #ffffff, #d0d0d0); box-shadow: none; }
    .btn-danger { border-color: rgba(255,92,122,.35); }
    .btn-danger:hover { border-color: rgba(255,92,122,.65); }

    main { padding-top: 18px; }
    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 980px) {
      .topbar { grid-template-columns: 1fr; }
      .controls { justify-content: flex-start; }
      .grid { grid-template-columns: 1fr; }
    }

    .card {
      background: linear-gradient(180deg, rgb(255, 255, 255), rgb(255, 255, 255));
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 14px;
      box-shadow: var(--shadow);
    }
    .card h2 {
      margin: 0 0 10px;
      font-size: 14px;
      letter-spacing: .25px;
    }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .row > * { flex: 1; }
    .row .tight { flex: 0 0 auto; }
    label { font-size: 12px; color: var(--muted); display: block; margin: 8px 0 6px; }
    input[type="text"], input[type="number"], textarea, select {
      width: 100%;
      border: 1px solid var(--line);
      background: rgba(255, 255, 255, 0.65);
      color: var(--text);
      padding: 10px 10px;
      border-radius: 12px;
      outline: none;
      font-size: 13px;
    }
    textarea { min-height: 92px; resize: vertical; }
    .mini { font-size: 12px; color: var(--muted); margin-top: 8px; }

    .chips { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 6px; }
    .chip {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      background: var(--chip);
      border: 1px solid var(--line);
      padding: 8px 10px;
      border-radius: 999px;
      font-size: 12px;
      color: var(--text);
      user-select: none;
    }
    .chip input { transform: translateY(1px); }
    .pill {
      font-family: var(--mono);
      padding: 5px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.25);
      color: var(--muted);
      font-size: 11px;
      white-space: nowrap;
    }
    .pill.ink { color: var(--ink); border-color: rgba(58,61,94,.25); }

    .section-title {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      align-items: baseline;
      margin-bottom: 8px;
    }
    .section-title .hint { color: var(--muted); font-size: 12px; }

    .task {
      display: grid;
      grid-template-columns: 24px 1fr 110px 110px 34px;
      gap: 10px;
      align-items: center;
      padding: 9px 10px;
      border: 1px solid var(--line);
      background: rgba(255, 255, 255, 0.55);
      border-radius: 14px;
      margin-bottom: 8px;
    }
    .task input[type="checkbox"] { width: 18px; height: 18px; }
    .task input[type="text"] { padding: 9px 9px; }
    .task select { padding: 9px 9px; }
    .task .del {
      width: 34px; height: 34px; border-radius: 12px;
      background: rgba(255,92,122,.08);
      border: 1px solid rgba(255,92,122,.25);
      color: var(--text); cursor: pointer;
      box-shadow: none;
      font-weight: 900;
    }
    .task .del:hover { border-color: rgba(255,92,122,.55); }
    .task.done { opacity: .7; }
    .task.done .title { text-decoration: line-through; color: var(--muted); }

    .cols {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
    }
    @media (max-width: 980px) { .cols { grid-template-columns: 1fr; } }

    .mdbox {
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.45;
      white-space: pre-wrap;
      border: 1px dashed var(--ink);
      background: rgba(255, 255, 255, 0.25);
      padding: 12px;
      border-radius: 14px;
      min-height: 160px;
      max-height: 360px;
      overflow: auto;
    }

    .statusline { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
    .dot.ok { background: var(--ok); }
    .dot.warn { background: var(--warn); }
    .dot.bad { background: var(--danger); }

    .footer-note { color: var(--muted); font-size: 12px; margin-top: 10px; }
    a { color: var(--ink); }

    /* Toast */
    .toast {
      position: fixed;
      right: 16px;
      bottom: 16px;
      z-index: 50;
      background: rgba(255,255,255,.92);
      border: 1px solid var(--line);
      box-shadow: var(--shadowSoft);
      padding: 10px 12px;
      border-radius: 14px;
      font-size: 12px;
      color: var(--text);
      opacity: 0;
      transform: translateY(6px);
      pointer-events: none;
      transition: opacity .18s ease, transform .18s ease;
    }
    .toast.show { opacity: 1; transform: translateY(0px); }

    /* Inline form */
    .inlineForm {
      border: 1px solid var(--line);
      background: rgba(255,255,255,0.55);
      border-radius: 14px;
      padding: 10px;
      margin-top: 10px;
      display: none;
    }
    .inlineForm.show { display: block; }
    .inlineForm .cols { margin-top: 6px; }

    /* Forest */
    .span2 { grid-column: 1 / -1; } /* full-width card within the grid row */

    .forestWrap {
      border: 1px solid var(--line);
      background: rgba(255,255,255,0.55);
      border-radius: 14px;
      padding: 10px;
      margin-top: 10px;
      overflow: hidden;
    }
    canvas#forestCanvas {
      width: 100%;
      height: 520px; /* increased height to fit crowns + subterrain */
      display: block;
      border-radius: 12px;
      background: rgba(255,255,255,0.35);
    }
    .forestLegend {
      margin-top: 10px;
      border: 1px dashed rgba(58,61,94,.35);
      background: rgba(255,255,255,0.35);
      border-radius: 14px;
      padding: 10px;
      font-size: 12px;
      color: var(--muted);
      display: none;
    }
    .forestLegend.show { display: block; }
    .forestLegend b { color: var(--ink); }
    .forestLegend code { font-family: var(--mono); font-size: 11px; color: var(--ink); }
  </style>
</head>

<body>
<header>
  <div class="wrap topbar">
    <div>
      <h1>Semester Dashboard — Courses, Modes, Writing + Obsidian Export</h1>
      <div class="subtitle">
        Default posture: <span class="pill">9–5 = material-building</span> • evenings/weekends = deliverables.
        Everything auto-saves locally.
        <span class="pill ink">Shortcuts:</span>
        <span class="pill">n = new Today task</span>
        <span class="pill">w = new Weekend deliverable</span>
        <span class="pill">g then m = generate .md</span>
        <span class="pill">Ctrl/⌘+S = save</span>
      </div>
    </div>
    <div class="controls">
      <button class="btn-secondary" id="btnResetDay">Reset “Day” checkboxes</button>
      <button class="btn-secondary" id="btnResetWeek">Reset “Week” checkboxes</button>
      <button class="btn-secondary" id="btnBackup">Export JSON backup</button>
      <button class="btn-danger" id="btnHardReset">Hard reset (wipe local)</button>
    </div>
  </div>
</header>

<main class="wrap">
  <div class="grid">
    <!-- Left column: core structure -->
    <section class="card">
      <div class="section-title">
        <h2>Core Rhythm</h2>
        <div class="hint">Set the rules of engagement</div>
      </div>

      <label>Semester intent (1–2 sentences)</label>
      <input type="text" id="intent" placeholder="e.g., Build real understanding; avoid backlog; weekend slay sessions bounded." />

      <div class="cols" style="margin-top:10px;">
        <div>
          <label>Weekday core window</label>
          <input type="text" id="coreWindow" placeholder="e.g., 9:00–17:00" />
          <div class="mini">Used in the markdown export header.</div>
        </div>
        <div>
          <label>Weekend posture</label>
          <input type="text" id="weekendPosture" placeholder="e.g., deliverables + exam review + downtime" />
          <div class="mini">Keep bounded so it doesn’t become spillover.</div>
        </div>
        <div>
          <label>Weekly rebalance day</label>
          <select id="rebalanceDay">
            <option>Friday</option><option>Saturday</option><option>Sunday</option><option>Monday</option>
          </select>
          <div class="mini">20 minutes to re-allocate blocks.</div>
        </div>
      </div>

      <label style="margin-top:12px;">Modes checklist (daily + weekly anchors)</label>
      <div class="chips" id="modeChips"></div>

      <div class="footer-note">
        Tip: keep one protected “absorption block” each weekday (no new inputs; only consolidation).
      </div>
    </section>

    <!-- Right column: today planner -->
    <section class="card">
      <div class="section-title">
        <h2>Today — Focus & Blocks</h2>
        <div class="hint">Plan lightly; execute steadily</div>
      </div>

      <div class="cols">
        <div>
          <label>Keystone course today</label>
          <select id="keystoneToday"></select>
          <div class="mini">If this is stable, the day is stable.</div>
        </div>
        <div>
          <label>Absorption block (60–90 min)</label>
          <input type="text" id="absorption" placeholder="e.g., AOIC: re-derive key mechanisms + quiz-style Qs" />
        </div>
        <div>
          <label>Workout (quick note)</label>
          <input type="text" id="workout" placeholder="e.g., 35 min run + mobility" />
        </div>
      </div>

      <label style="margin-top:12px;">Quick capture (what matters / what’s fuzzy)</label>
      <textarea id="todayNotes" placeholder="2–6 bullet points: what landed, what’s confusing, what to ask ChatGPT / prof."></textarea>

      <div class="row" style="margin-top:10px;">
        <button id="btnAddTodayTask">+ Add Today Task</button>
        <button class="btn-secondary" id="btnClearTodayDone">Clear completed</button>
      </div>

      <div id="todayTasks" style="margin-top:10px;"></div>
    </section>
  </div>

  <!-- Week Summary FULL WIDTH -->
  <div class="grid" style="margin-top:14px;">
    <section class="card span2">
      <div class="section-title">
        <h2>Week Summary</h2>
        <div class="hint">Stability readout + forest (no extra data entry)</div>
      </div>

      <div id="weekSummary" class="mini"></div>

      <div class="forestWrap" aria-label="Weekly forest visualization">
        <div class="row" style="margin-bottom:10px;">
          <button class="btn-secondary" id="btnToggleLegend" title="Toggle legend">Legend</button>
          <button class="btn-secondary" id="btnExportPNG" title="Download forest as PNG">Export PNG</button>
          <button class="btn-secondary" id="btnExportSVG" title="Download forest as SVG">Export SVG</button>
          <button class="btn-secondary" id="btnClearGhost" title="Clear last-week ghost overlay">Clear ghost</button>
        </div>

        <canvas id="forestCanvas"></canvas>

        <div id="forestLegend" class="forestLegend"></div>
      </div>

      <div class="footer-note">
        This is computed from tasks + course statuses + your writing. It grows during the week (max-growth memory for writing/task completion), and overlays last week as a faint trace. Stress and daily-mode checkboxes remain dynamic.
      </div>
    </section>
  </div>

  <div class="grid" style="margin-top:14px;">
    <!-- Courses -->
    <section class="card">
      <div class="section-title">
        <h2>Courses — Modes + Notes</h2>
        <div class="hint">Keep each course bounded</div>
      </div>

      <div class="row">
        <div>
          <label>Courses (editable)</label>
          <input type="text" id="courseList" placeholder="AOIC; Neurobiology; Biological Modeling; Calc II; Probability/Prereqs; GCAS Writing" />
          <div class="mini">Separate with semicolons.</div>
        </div>
        <div class="tight">
          <label>&nbsp;</label>
          <button class="btn-secondary" id="btnApplyCourses">Apply</button>
        </div>
      </div>

      <div id="courseCards" style="margin-top:12px;"></div>
    </section>

    <!-- Writing sessions -->
    <section class="card">
      <div class="section-title">
        <h2>Writing Sessions</h2>
        <div class="hint">Light, consistent, non-sprawling</div>
      </div>

      <label>GCAS / thesis micro-session template</label>
      <textarea id="writingTemplate" placeholder="Prompt, constraint, and output shape. e.g., 45 min: 1 paragraph synthesis + 3 citations-to-check. No perfection."></textarea>

      <div class="cols" style="margin-top:10px;">
        <div>
          <label>Weekly writing cadence</label>
          <input type="text" id="writingCadence" placeholder="e.g., 2× 45min (Tue/Thu) + 1× 2hr (Sun optional)" />
        </div>
        <div>
          <label>Current writing thread</label>
          <input type="text" id="writingThread" placeholder="e.g., Neural Set; Saussure/Lacan; modeling epistemology" />
        </div>
        <div>
          <label>Next tiny output</label>
          <input type="text" id="writingOutput" placeholder="e.g., 300–600 words + 5 bullets for future paper" />
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <button id="btnShowWritingForm">+ Log a writing session</button>
        <button class="btn-secondary" id="btnClearWritingLog">Clear log</button>
      </div>

      <!-- Inline writing log form -->
      <div id="writingForm" class="inlineForm" aria-live="polite">
        <div class="cols">
          <div>
            <label>Minutes</label>
            <input type="number" id="writingMinutes" min="0" step="5" value="45" />
          </div>
          <div>
            <label>Output (short)</label>
            <input type="text" id="writingOutputShort" placeholder="e.g., 1 paragraph synthesis" />
          </div>
          <div>
            <label>Notes (optional)</label>
            <input type="text" id="writingNotesShort" placeholder="e.g., cite-check X; question Y" />
          </div>
        </div>
        <div class="row" style="margin-top:10px;">
          <button id="btnSaveWritingSession">Save session</button>
          <button class="btn-secondary" id="btnCancelWritingForm">Cancel</button>
        </div>
      </div>

      <div id="writingLog" style="margin-top:10px;"></div>
      <div class="footer-note">Logging is optional; it’s mainly for continuity + guilt reduction.</div>
    </section>
  </div>

  <div class="grid" style="margin-top:14px;">
    <!-- Weekend deliverables -->
    <section class="card">
      <div class="section-title">
        <h2>Weekend Deliverables</h2>
        <div class="hint">Slay sessions with edges</div>
      </div>

      <div class="row">
        <button id="btnAddWeekendTask">+ Add deliverable</button>
        <button class="btn-secondary" id="btnClearWeekendDone">Clear completed</button>
      </div>

      <div id="weekendTasks" style="margin-top:10px;"></div>

      <label style="margin-top:12px;">Downtime boundary (write it like a rule)</label>
      <input type="text" id="downtimeRule" placeholder="e.g., Sat night off; Sun morning slow; no work after 8pm." />
    </section>

    <!-- Markdown export -->
    <section class="card">
      <div class="section-title">
        <h2>.md Export (Obsidian)</h2>
        <div class="hint">Generate, copy, download</div>
      </div>

      <div class="row">
        <button id="btnGenerateMd">Generate Markdown</button>
        <button class="btn-secondary" id="btnCopyMd">Copy</button>
        <button class="btn-secondary" id="btnDownloadMd">Download .md</button>
      </div>

      <label style="margin-top:12px;">Markdown preview</label>
      <div id="mdPreview" class="mdbox"></div>

      <div class="statusline" style="margin-top:10px;">
        <span class="dot ok"></span><span class="mini">Saved locally</span>
        <span class="dot warn"></span><span class="mini">Reset week = clears “weekly” checkboxes only</span>
        <span class="dot bad"></span><span class="mini">Hard reset wipes everything</span>
      </div>
    </section>
  </div>
</main>

<div id="toast" class="toast" role="status" aria-live="polite"></div>

<script>
  // ---------- Version + migration ----------
  const STORAGE_KEY = "semester_dashboard_v1";
  const CURRENT_VERSION = 4; // bumped for organic mycelium + full-width forest + dynamic stress/modes

  const DEFAULT = {
    version: CURRENT_VERSION,

    intent: "",
    coreWindow: "9:00–17:00",
    weekendPosture: "Deliverables + exam review + downtime",
    rebalanceDay: "Sunday",

    // Daily vs weekly semantics
    modeScope: {
      "Attend sync lecture/recitation": "weekly",
      "Watch async lecture(s)": "weekly",
      "Reading upkeep": "daily",
      "Absorption block (no new inputs)": "daily",
      "Prereq / review": "weekly",
      "Light writing (GCAS / synthesis)": "weekly",
      "Admin / grants (small churn)": "weekly",
      "Exercise": "daily",
    },

    modeChecks: {
      "Attend sync lecture/recitation": false,
      "Watch async lecture(s)": false,
      "Reading upkeep": false,
      "Absorption block (no new inputs)": false,
      "Prereq / review": false,
      "Light writing (GCAS / synthesis)": false,
      "Admin / grants (small churn)": false,
      "Exercise": false,
    },

    courses: ["AOIC", "Neurobiology", "Biological Modeling", "Calc II", "Probability/Prereqs", "GCAS Writing"],
    courseNotes: {},

    keystoneToday: "AOIC",
    absorption: "",
    workout: "",
    todayNotes: "",
    todayTasks: [],
    weekendTasks: [],

    writingTemplate: "45 min: 1 paragraph synthesis + 3 citations-to-check. No perfection.",
    writingCadence: "2× 45min (Tue/Thu) + 1× 2hr (Sun optional)",
    writingThread: "",
    writingOutput: "",
    writingLog: [],

    downtimeRule: "",
    mdCache: "",

    // Forest
    forest: {
      legendOn: false,
      weekId: "",
      perCourseMax: {},   // max-memory for writing volume / syntax / cohesion / completed tasks
    }
  };

  function structuredDefault() {
    return (typeof structuredClone === "function")
      ? structuredClone(DEFAULT)
      : JSON.parse(JSON.stringify(DEFAULT));
  }

  function migrateState(s) {
    const v = s?.version || 1;
    if (v < 2) {
      s.modeScope = s.modeScope || structuredDefault().modeScope;
      s.version = 2;
    }
    if (v < 3) {
      s.forest = s.forest || structuredDefault().forest;
      s.version = 3;
    }
    if (v < 4) {
      // v4: remove maxStress storage if present; keep only the intended max-memory metrics
      if (s.forest?.perCourseMax) {
        for (const k of Object.keys(s.forest.perCourseMax)) {
          if ("maxStress" in s.forest.perCourseMax[k]) delete s.forest.perCourseMax[k].maxStress;
        }
      }
      s.version = 4;
    }
    return s;
  }

  function loadState() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return structuredDefault();
      const parsed = migrateState(JSON.parse(raw));
      const def = structuredDefault();
      return {
        ...def,
        ...parsed,
        version: CURRENT_VERSION,
        modeChecks: { ...def.modeChecks, ...(parsed.modeChecks||{}) },
        modeScope:  { ...def.modeScope,  ...(parsed.modeScope||{})  },
        forest:     { ...def.forest,     ...(parsed.forest||{})     },
      };
    } catch {
      return structuredDefault();
    }
  }

  let state = loadState();

  function saveState() {
    state.version = CURRENT_VERSION;
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  }

  function uid() {
    return Math.random().toString(16).slice(2) + Date.now().toString(16);
  }

  // ---------- Toast ----------
  let toastTimer = null;
  function toast(msg) {
    const t = document.getElementById("toast");
    t.textContent = msg;
    t.classList.add("show");
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => t.classList.remove("show"), 1200);
  }

  // ---------- Elements ----------
  const el = (id) => document.getElementById(id);

  const intentEl = el("intent");
  const coreWindowEl = el("coreWindow");
  const weekendPostureEl = el("weekendPosture");
  const rebalanceDayEl = el("rebalanceDay");
  const modeChipsEl = el("modeChips");

  const keystoneTodayEl = el("keystoneToday");
  const absorptionEl = el("absorption");
  const workoutEl = el("workout");
  const todayNotesEl = el("todayNotes");
  const todayTasksEl = el("todayTasks");

  const weekSummaryEl = el("weekSummary");

  const courseListEl = el("courseList");
  const courseCardsEl = el("courseCards");

  const writingTemplateEl = el("writingTemplate");
  const writingCadenceEl = el("writingCadence");
  const writingThreadEl = el("writingThread");
  const writingOutputEl = el("writingOutput");
  const writingLogEl = el("writingLog");

  const writingFormEl = el("writingForm");
  const writingMinutesEl = el("writingMinutes");
  const writingOutputShortEl = el("writingOutputShort");
  const writingNotesShortEl = el("writingNotesShort");

  const weekendTasksEl = el("weekendTasks");
  const downtimeRuleEl = el("downtimeRule");

  const mdPreviewEl = el("mdPreview");

  // Forest elements
  const forestCanvas = el("forestCanvas");
  const forestLegendEl = el("forestLegend");

  // ---------- Utilities ----------
  function escapeHtml(s) {
    return (s || "").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
  }

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function getCSSVar(name){
    return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
  }

  function debounce(fn, ms){
    let t = null;
    return (...args) => {
      clearTimeout(t);
      t = setTimeout(() => fn(...args), ms);
    };
  }

  // ISO week id: YYYY-Www
  function isoWeekId(date = new Date()) {
    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    const dayNum = d.getUTCDay() || 7; // Mon=1..Sun=7
    d.setUTCDate(d.getUTCDate() + 4 - dayNum);
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    const y = d.getUTCFullYear();
    const w = String(weekNo).padStart(2, "0");
    return `${y}-W${w}`;
  }

  function prevIsoWeekId(currentId){
    const [yPart, wPart] = currentId.split("-W");
    const y = Number(yPart);
    const w = Number(wPart);
    const jan4 = new Date(Date.UTC(y, 0, 4));
    const dayNum = jan4.getUTCDay() || 7;
    const mondayWeek1 = new Date(jan4);
    mondayWeek1.setUTCDate(jan4.getUTCDate() - (dayNum - 1));
    const mondayTarget = new Date(mondayWeek1);
    mondayTarget.setUTCDate(mondayWeek1.getUTCDate() + (w - 1) * 7);
    mondayTarget.setUTCDate(mondayTarget.getUTCDate() - 7);
    return isoWeekId(new Date(mondayTarget.getUTCFullYear(), mondayTarget.getUTCMonth(), mondayTarget.getUTCDate()));
  }

  // ---------- Render helpers ----------
  function renderModeChips() {
    modeChipsEl.innerHTML = "";
    const labels = Object.keys(state.modeChecks);

    labels.forEach((label) => {
      const chip = document.createElement("label");
      chip.className = "chip";

      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.checked = !!state.modeChecks[label];
      cb.addEventListener("change", () => {
        state.modeChecks[label] = cb.checked;
        saveState();
        renderWeekSummary();
        debouncedForest(); // dynamic response to daily checkbox changes
      });

      const span = document.createElement("span");
      span.textContent = label;

      const scope = document.createElement("span");
      scope.className = "pill";
      scope.textContent = (state.modeScope?.[label] || "weekly").toUpperCase();

      chip.appendChild(cb);
      chip.appendChild(span);
      chip.appendChild(scope);
      modeChipsEl.appendChild(chip);
    });
  }

  function renderKeystoneDropdown() {
    keystoneTodayEl.innerHTML = "";
    state.courses.forEach((c) => {
      const opt = document.createElement("option");
      opt.value = c;
      opt.textContent = c;
      keystoneTodayEl.appendChild(opt);
    });
    keystoneTodayEl.value = state.keystoneToday || state.courses[0] || "";
  }

  function renderCourseCards() {
    courseCardsEl.innerHTML = "";
    state.courses.forEach((course) => {
      if (!state.courseNotes[course]) {
        state.courseNotes[course] = { status: "steady", focus: "", budget: "", notes: "" };
      }
      const data = state.courseNotes[course];

      const card = document.createElement("div");
      card.className = "card";
      card.style.marginBottom = "10px";

      const title = document.createElement("div");
      title.className = "section-title";
      title.innerHTML = `<h2>${escapeHtml(course)}</h2><div class="hint">bounded notes + focus modes</div>`;
      card.appendChild(title);

      const row = document.createElement("div");
      row.className = "cols";

      const col1 = document.createElement("div");
      col1.innerHTML = `<label>Status</label>`;
      const status = document.createElement("select");
      ["steady","watch","hot","danger"].forEach(s => {
        const opt = document.createElement("option");
        opt.value = s;
        opt.textContent = s;
        status.appendChild(opt);
      });
      status.value = data.status || "steady";
      status.addEventListener("change", () => {
        state.courseNotes[course].status = status.value;
        saveState();
        renderWeekSummary();
        debouncedForest(); // dynamic response to stress changes
      });
      col1.appendChild(status);

      const col2 = document.createElement("div");
      col2.innerHTML = `<label>Focus (this week)</label>`;
      const focus = document.createElement("input");
      focus.type = "text";
      focus.placeholder = "e.g., AOIC quiz prep; Neuro: lecture map; Modeling: tools + first HW";
      focus.value = data.focus || "";
      focus.addEventListener("input", () => {
        state.courseNotes[course].focus = focus.value;
        saveState();
      });
      col2.appendChild(focus);

      const col3 = document.createElement("div");
      col3.innerHTML = `<label>Block budget</label>`;
      const budget = document.createElement("input");
      budget.type = "text";
      budget.placeholder = "e.g., 1 deep block + 2 light blocks";
      budget.value = data.budget || "";
      budget.addEventListener("input", () => {
        state.courseNotes[course].budget = budget.value;
        saveState();
      });
      col3.appendChild(budget);

      row.appendChild(col1); row.appendChild(col2); row.appendChild(col3);
      card.appendChild(row);

      const notesLabel = document.createElement("label");
      notesLabel.style.marginTop = "10px";
      notesLabel.textContent = "Notes (what landed / what’s fuzzy / next question)";
      card.appendChild(notesLabel);

      const notes = document.createElement("textarea");
      notes.value = data.notes || "";
      notes.placeholder = "Keep it short. Capture confusion early.";
      notes.addEventListener("input", () => {
        state.courseNotes[course].notes = notes.value;
        saveState();
        debouncedForest(); // update forest as you write
      });
      card.appendChild(notes);

      courseCardsEl.appendChild(card);
    });

    saveState();
    renderWeekSummary();
  }

  function taskRow(task, listName) {
    const row = document.createElement("div");
    row.className = "task" + (task.done ? " done" : "");

    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.checked = !!task.done;
    cb.addEventListener("change", () => {
      task.done = cb.checked;
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest(); // dynamic response to task completion changes
    });

    const title = document.createElement("input");
    title.type = "text";
    title.className = "title";
    title.value = task.title || "";
    title.placeholder = "Task (bounded, concrete)";
    title.addEventListener("input", () => {
      task.title = title.value;
      saveState();
      debouncedForest();
    });

    title.addEventListener("blur", () => {
      if (!String(task.title || "").trim()) toast("Task title is empty (export will mark as untitled).");
    });

    const course = document.createElement("select");
    state.courses.forEach((c) => {
      const opt = document.createElement("option");
      opt.value = c;
      opt.textContent = c;
      course.appendChild(opt);
    });
    course.value = task.course || state.courses[0];
    course.addEventListener("change", () => {
      task.course = course.value;
      saveState();
      renderWeekSummary();
      debouncedForest();
    });

    const mode = document.createElement("select");
    const modes = Object.keys(state.modeChecks);
    ["(mode)", ...modes].forEach((m) => {
      const opt = document.createElement("option");
      opt.value = m;
      opt.textContent = m;
      mode.appendChild(opt);
    });
    mode.value = task.mode || "(mode)";
    mode.addEventListener("change", () => {
      task.mode = mode.value;
      saveState();
      debouncedForest();
    });

    const del = document.createElement("button");
    del.className = "del";
    del.textContent = "×";
    del.title = "Delete";
    del.addEventListener("click", () => {
      state[listName] = state[listName].filter((t) => t.id !== task.id);
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
    });

    row.appendChild(cb);
    row.appendChild(title);
    row.appendChild(course);
    row.appendChild(mode);
    row.appendChild(del);
    return row;
  }

  function renderTasks() {
    todayTasksEl.innerHTML = "";
    state.todayTasks.forEach((t) => todayTasksEl.appendChild(taskRow(t, "todayTasks")));

    weekendTasksEl.innerHTML = "";
    state.weekendTasks.forEach((t) => weekendTasksEl.appendChild(taskRow(t, "weekendTasks")));
  }

  function renderWritingLog() {
    writingLogEl.innerHTML = "";
    if (!state.writingLog.length) {
      const empty = document.createElement("div");
      empty.className = "mini";
      empty.textContent = "No sessions logged yet.";
      writingLogEl.appendChild(empty);
      return;
    }
    state.writingLog.slice().reverse().forEach((w) => {
      const box = document.createElement("div");
      box.className = "task";
      box.style.gridTemplateColumns = "1fr 120px 34px";
      const left = document.createElement("div");
      left.innerHTML = `<div style="font-weight:700;margin-bottom:4px;">${escapeHtml(w.output || "Writing session")}</div>
                        <div class="mini">${escapeHtml(w.notes || "")}</div>`;
      const mid = document.createElement("div");
      mid.innerHTML = `<div class="pill">${escapeHtml(w.date || "")}</div><div class="mini">${w.minutes || 0} min</div>`;
      const del = document.createElement("button");
      del.className = "del";
      del.textContent = "×";
      del.addEventListener("click", () => {
        state.writingLog = state.writingLog.filter(x => x.id !== w.id);
        saveState();
        renderWritingLog();
        renderWeekSummary();
        debouncedForest();
      });
      box.appendChild(left); box.appendChild(mid); box.appendChild(del);
      writingLogEl.appendChild(box);
    });
  }

  // ---------- Week summary ----------
  function renderWeekSummary() {
    const openToday = state.todayTasks.filter(t => !t.done).length;
    const openWeekend = state.weekendTasks.filter(t => !t.done).length;
    const doneToday = state.todayTasks.filter(t => t.done).length;
    const doneWeekend = state.weekendTasks.filter(t => t.done).length;

    const flagged = state.courses
      .map(c => ({ course: c, status: (state.courseNotes[c] || {}).status || "steady" }))
      .filter(x => x.status === "hot" || x.status === "danger");

    const keystone = state.keystoneToday || "";
    const keystoneOpen = state.todayTasks.filter(t => !t.done && t.course === keystone).length;

    const dailyTotal = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="daily").length || 1;
    const weeklyTotal = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="weekly").length || 1;

    const dailyChecked = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="daily" && state.modeChecks[k]).length;
    const weeklyChecked = Object.keys(state.modeChecks).filter(k => (state.modeScope?.[k]||"weekly")==="weekly" && state.modeChecks[k]).length;

    const lines = [];
    lines.push(`Open tasks: <b>${openToday + openWeekend}</b> (Today ${openToday}, Weekend ${openWeekend})`);
    lines.push(`Completed tasks: ${doneToday + doneWeekend} (Today ${doneToday}, Weekend ${doneWeekend})`);
    lines.push(`Keystone: <b>${escapeHtml(keystone)}</b> — open today tasks in keystone: <b>${keystoneOpen}</b>`);
    lines.push(`Modes checked: daily ${dailyChecked}/${dailyTotal} • weekly ${weeklyChecked}/${weeklyTotal}`);

    if (flagged.length) {
      const list = flagged.map(x => `${escapeHtml(x.course)}: <code>${escapeHtml(x.status)}</code>`).join(" • ");
      lines.push(`Flagged courses: <b>${flagged.length}</b> — ${list}`);
    } else {
      lines.push(`Flagged courses: 0`);
    }

    weekSummaryEl.innerHTML = `<div style="display:grid;gap:6px;">${lines.map(x => `<div>${x}</div>`).join("")}</div>`;
    debouncedForest();
  }

  // ---------- Markdown generation ----------
  function mdCheckbox(label, checked) {
    return `- [${checked ? "x" : " "}] ${label}`;
  }

  function obsidianLink(name) {
    const safe = String(name || "").replaceAll("]","\\]");
    return `[[${safe}]]`;
  }

  function generateMarkdown() {
    const d = new Date();
    const dateISO = d.toISOString().slice(0,10);
    const dateStr = d.toLocaleDateString(undefined, { weekday:"long", year:"numeric", month:"long", day:"numeric" });

    const lines = [];
    lines.push(`---`);
    lines.push(`type: semester-dashboard`);
    lines.push(`date: ${dateISO}`);
    lines.push(`keystone: ${state.keystoneToday || ""}`);
    lines.push(`---`);
    lines.push("");

    lines.push(`# Semester Dashboard — ${dateStr}`);
    lines.push("");
    lines.push(`**Tags:** #daily #UMO #study #dashboard`);
    lines.push("");
    lines.push(`**Core window:** ${state.coreWindow || ""}`);
    lines.push(`**Weekend posture:** ${state.weekendPosture || ""}`);
    lines.push(`**Weekly rebalance:** ${state.rebalanceDay || ""}`);
    if (state.intent?.trim()) {
      lines.push("");
      lines.push(`> ${state.intent.trim()}`);
    }

    lines.push("");
    lines.push("## Modes (today)");
    Object.keys(state.modeChecks).forEach((k) => {
      const scope = (state.modeScope?.[k] || "weekly");
      lines.push(`${mdCheckbox(k, !!state.modeChecks[k])} _( ${scope} )_`);
    });

    lines.push("");
    lines.push("## Today");
    lines.push(`**Keystone:** ${obsidianLink(state.keystoneToday || "")}`);
    if (state.absorption?.trim()) lines.push(`**Absorption block:** ${state.absorption.trim()}`);
    if (state.workout?.trim()) lines.push(`**Workout:** ${state.workout.trim()}`);
    if (state.todayNotes?.trim()) {
      lines.push("");
      lines.push("### Notes");
      lines.push(state.todayNotes.trim());
    }

    lines.push("");
    lines.push("### Today tasks");
    if (!state.todayTasks.length) lines.push("- (none)");
    state.todayTasks.forEach((t) => {
      const meta = [];
      if (t.course) meta.push(obsidianLink(t.course));
      if (t.mode && t.mode !== "(mode)") meta.push(t.mode);
      const tag = meta.length ? ` _( ${meta.join(" • ")} )_` : "";
      const title = (t.title || "").trim() || "(untitled — fill this in)";
      lines.push(`- [${t.done ? "x":" "}] ${title}${tag}`);
    });

    lines.push("");
    lines.push("## Courses (bounded status)");
    state.courses.forEach((course) => {
      const c = state.courseNotes[course] || {};
      lines.push(`### ${obsidianLink(course)}`);
      if (c.status) lines.push(`- **Status:** \`${c.status}\``);
      if (c.focus?.trim()) lines.push(`- **Focus:** ${c.focus.trim()}`);
      if (c.budget?.trim()) lines.push(`- **Block budget:** ${c.budget.trim()}`);
      if (c.notes?.trim()) {
        lines.push("");
        lines.push("**Notes**");
        lines.push(c.notes.trim());
      }
      lines.push("");
    });

    lines.push("## Writing");
    if (state.writingThread?.trim()) lines.push(`- **Thread:** ${state.writingThread.trim()}`);
    if (state.writingCadence?.trim()) lines.push(`- **Cadence:** ${state.writingCadence.trim()}`);
    if (state.writingOutput?.trim()) lines.push(`- **Next tiny output:** ${state.writingOutput.trim()}`);
    if (state.writingTemplate?.trim()) {
      lines.push("");
      lines.push("### Session template");
      lines.push(state.writingTemplate.trim());
    }

    lines.push("");
    lines.push("### Writing log");
    if (!state.writingLog.length) {
      lines.push("- (none)");
    } else {
      state.writingLog.slice().reverse().forEach((w) => {
        lines.push(`- **${w.date || ""}** — ${w.minutes || 0} min — ${(w.output || "").trim() || "(no output label)"}`);
        if (w.notes?.trim()) lines.push(`  - ${w.notes.trim()}`);
      });
    }

    lines.push("");
    lines.push("## Weekend deliverables");
    if (state.downtimeRule?.trim()) lines.push(`**Downtime rule:** ${state.downtimeRule.trim()}`);
    lines.push("");
    if (!state.weekendTasks.length) lines.push("- (none)");
    state.weekendTasks.forEach((t) => {
      const meta = [];
      if (t.course) meta.push(obsidianLink(t.course));
      if (t.mode && t.mode !== "(mode)") meta.push(t.mode);
      const tag = meta.length ? ` _( ${meta.join(" • ")} )_` : "";
      const title = (t.title || "").trim() || "(untitled — fill this in)";
      lines.push(`- [${t.done ? "x":" "}] ${title}${tag}`);
    });

    lines.push("");
    lines.push("---");
    lines.push("**Exported from:** Semester Dashboard (local HTML)");
    return lines.join("\n");
  }

  function setMdPreview(md) {
    state.mdCache = md;
    saveState();
    mdPreviewEl.textContent = md;
  }

  // =====================================================================
  // FOREST: syntactic/semantic analysis + growing art + ghost overlay + export
  // =====================================================================

  // stoplist
  const STOP = new Set([
    "the","a","an","and","or","but","if","then","else","so","because","since","while","where","when",
    "to","of","in","on","for","from","with","without","within","between","into","over","under","across",
    "is","are","was","were","be","been","being","am","do","does","did","doing","have","has","had","having",
    "it","its","this","that","these","those","as","at","by","we","you","i","they","them","our","your","my",
    "their","there","here","also","very","more","most","less","not","no","yes","can","could","should","would",
    "may","might","will","just","about","up","down","out","off","only","than","such","some","any","each","all"
  ]);

  const CLAUSE_MARKERS = [
    "that","which","who","whom","whose",
    "because","since","while","whereas","although","though","unless","until",
    "insofar as","with regard to","with regard to which","in terms of","according to","such that",
    "whereby","thereby","in which","within which","through which"
  ];

  const PUNCT_HEAVY = new Set([":",";","—","(",")","[","]"]);

  function normalizeText(s){
    return String(s||"")
      .replaceAll("\u2019","'").replaceAll("\u2014","—").replaceAll("\u2013","-")
      .replace(/\s+/g, " ")
      .trim();
  }

  function splitSentences(text){
    const t = normalizeText(text);
    if (!t) return [];
    return t.split(/(?<=[\.\!\?])\s+/g).map(x => x.trim()).filter(Boolean);
  }

  function tokenize(text){
    const t = normalizeText(text).toLowerCase();
    if (!t) return [];
    return t
      .replace(/[^a-z0-9\-\s']/g, " ")
      .split(/\s+/)
      .map(x => x.trim())
      .filter(Boolean);
  }

  function contentWords(text){
    const toks = tokenize(text);
    return toks.filter(w => w.length >= 3 && !STOP.has(w) && !/^\d+$/.test(w));
  }

  function topNWords(text, n=10){
    const words = contentWords(text);
    const freq = new Map();
    for (const w of words) freq.set(w, (freq.get(w)||0)+1);
    const arr = Array.from(freq.entries()).sort((a,b)=>b[1]-a[1]);
    return arr.slice(0,n).map(([w,c])=>({w,c}));
  }

  function countMarkers(text){
    const lower = normalizeText(text).toLowerCase();
    let count = 0;
    for (const m of CLAUSE_MARKERS) {
      const re = new RegExp("\\b" + m.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + "\\b", "g");
      const matches = lower.match(re);
      if (matches) count += matches.length;
    }
    return count;
  }

  function punctProfile(text){
    const t = String(text||"");
    let heavy = 0, comma = 0, dash = 0;
    for (const ch of t) {
      if (PUNCT_HEAVY.has(ch)) heavy++;
      if (ch === ",") comma++;
      if (ch === "-" || ch === "—") dash++;
    }
    return { heavy, comma, dash };
  }

  function syntacticComplexity(text){
    const sents = splitSentences(text);
    const toks = tokenize(text);
    const words = toks.length || 0;
    const sentLens = sents.map(s => tokenize(s).length).filter(n=>n>0);
    const avgSent = sentLens.length ? (sentLens.reduce((a,b)=>a+b,0)/sentLens.length) : 0;

    let variance = 0;
    if (sentLens.length >= 2) {
      const mean = avgSent;
      variance = sentLens.reduce((a,x)=>a+(x-mean)*(x-mean),0) / sentLens.length;
    }

    const markers = countMarkers(text);
    const { heavy, comma, dash } = punctProfile(text);

    const avgSentScore = clamp(avgSent / 14, 0, 3);
    const markerScore = clamp((markers / Math.max(1, sents.length)) / 1.2, 0, 3);
    const punctScore = clamp((heavy + 0.35*comma + 0.5*dash) / Math.max(1, words) * 60, 0, 3);
    const varScore = clamp(Math.sqrt(variance) / 10, 0, 3);

    const score = 0.95*avgSentScore + 1.15*markerScore + 0.85*punctScore + 0.65*varScore;

    return {
      score: Number(score.toFixed(2)),
      avgSent: Number(avgSent.toFixed(1)),
      markers,
      sents: sents.length,
      punct: { heavy, comma, dash },
    };
  }

  function semanticCohesion(text){
    const words = contentWords(text);
    const total = words.length || 0;
    const uniq = new Set(words).size || 0;
    if (!total) return { score: 0, total: 0, uniq: 0, top: [] };
    const uniqRatio = uniq / total;
    const score = clamp((1 - uniqRatio) * 5, 0, 3);
    return {
      score: Number(score.toFixed(2)),
      total,
      uniq,
      top: topNWords(text, 10),
    };
  }

  // Max-memory: keep these from shrinking within the week:
  // - words (writing volume)
  // - syntax score
  // - cohesion score
  // - completed tasks count
  // Stress is dynamic (status changes should immediately show).
  function updateForestMax(weekId, perCourseComputed){
    state.forest.weekId = weekId;
    state.forest.perCourseMax = state.forest.perCourseMax || {};
    for (const [course, m] of Object.entries(perCourseComputed)) {
      const prev = state.forest.perCourseMax[course] || { maxWords:0, maxSyntax:0, maxCohesion:0, maxLeaves:0 };
      state.forest.perCourseMax[course] = {
        maxWords:    Math.max(prev.maxWords||0, m.words||0),
        maxSyntax:   Math.max(prev.maxSyntax||0, m.syntax||0),
        maxCohesion: Math.max(prev.maxCohesion||0, m.cohesion||0),
        maxLeaves:   Math.max(prev.maxLeaves||0, m.leaves||0),
      };
    }
    saveState();
  }

  function stressFromStatus(status){
    if (status === "danger") return 1.0;
    if (status === "hot") return 0.72;
    if (status === "watch") return 0.42;
    return 0.18;
  }

  function gatherCourseText(course){
    const c = state.courseNotes[course] || {};
    const notes = String(c.notes||"");
    const focus = String(c.focus||"");
    const budget = String(c.budget||"");
    const taskTitles = [
      ...state.todayTasks.filter(t=>t.course===course).map(t=>t.title||""),
      ...state.weekendTasks.filter(t=>t.course===course).map(t=>t.title||""),
    ].join(" ");
    return normalizeText([notes, focus, budget, taskTitles].filter(Boolean).join(" "));
  }

  function computeModeRatios(){
    const keys = Object.keys(state.modeChecks);
    const dailyKeys = keys.filter(k => (state.modeScope?.[k]||"weekly")==="daily");
    const weeklyKeys = keys.filter(k => (state.modeScope?.[k]||"weekly")==="weekly");
    const dailyChecked = dailyKeys.filter(k => !!state.modeChecks[k]).length;
    const weeklyChecked = weeklyKeys.filter(k => !!state.modeChecks[k]).length;
    return {
      dailyRatio: dailyKeys.length ? (dailyChecked / dailyKeys.length) : 0,
      weeklyRatio: weeklyKeys.length ? (weeklyChecked / weeklyKeys.length) : 0,
      dailyChecked, weeklyChecked,
      dailyTotal: dailyKeys.length || 0,
      weeklyTotal: weeklyKeys.length || 0
    };
  }

  function computeForestMetrics(){
    const weekId = isoWeekId(new Date());
    if (state.forest.weekId && state.forest.weekId !== weekId) {
      state.forest.perCourseMax = {};
    }
    if (!state.forest.weekId) state.forest.weekId = weekId;

    const keystone = state.keystoneToday || (state.courses[0]||"");
    const keystoneDaily = normalizeText(state.todayNotes || "");

    const perCourse = {};
    for (const course of state.courses) {
      const baseText = gatherCourseText(course);
      const text = (course === keystone && keystoneDaily)
        ? normalizeText(baseText + " " + keystoneDaily)
        : baseText;

      const syntax = syntacticComplexity(text);
      const sem = semanticCohesion(text);

      const leaves = [
        ...state.todayTasks.filter(t=>t.course===course && t.done),
        ...state.weekendTasks.filter(t=>t.course===course && t.done),
      ].length;

      const status = (state.courseNotes[course] || {}).status || "steady";
      const stress = stressFromStatus(status); // dynamic

      perCourse[course] = {
        text,
        words: tokenize(text).length,
        syntax: syntax.score,
        syntaxDetail: syntax,
        cohesion: sem.score,
        cohesionDetail: sem,
        leaves,
        stress,
        topWords: sem.top.map(x=>x.w),
      };
    }

    updateForestMax(weekId, Object.fromEntries(Object.entries(perCourse).map(([k,v])=>[
      k, { words:v.words, syntax:v.syntax, cohesion:v.cohesion, leaves:v.leaves }
    ])));

    return { weekId, perCourse, mode: computeModeRatios() };
  }

  function influenceMatrix(perCourse){
    const courses = Object.keys(perCourse);
    const mat = [];
    for (let i=0;i<courses.length;i++){
      mat[i] = [];
      for (let j=0;j<courses.length;j++){
        if (i===j) { mat[i][j]=0; continue; }
        const A = perCourse[courses[i]];
        const B = perCourse[courses[j]];
        const Bwords = new Set(contentWords(B.text));
        let hits = 0;
        for (const w of A.topWords.slice(0,8)) {
          if (Bwords.has(w)) hits++;
        }
        const score = hits / Math.max(1, Math.min(8, A.topWords.length));
        mat[i][j] = score;
      }
    }
    return { courses, mat };
  }

  // Seeded RNG
  function xmur3(str) {
    let h = 1779033703 ^ str.length;
    for (let i = 0; i < str.length; i++) {
      h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
      h = (h << 13) | (h >>> 19);
    }
    return function() {
      h = Math.imul(h ^ (h >>> 16), 2246822507);
      h = Math.imul(h ^ (h >>> 13), 3266489909);
      return (h ^= h >>> 16) >>> 0;
    };
  }
  function mulberry32(a) {
    return function() {
      let t = (a += 0x6D2B79F5);
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }
  function seededRand(seedStr){
    const seed = xmur3(seedStr)();
    return mulberry32(seed);
  }

  // Geometry capture for SVG export
  let lastForestGeom = null;

  function initCanvasHiDPI(canvas){
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    const w = Math.max(300, Math.floor(rect.width));
    const h = Math.max(240, Math.floor(rect.height));
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    const ctx = canvas.getContext("2d");
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    return { ctx, w, h, dpr };
  }

  function forestToSVG(geom){
    const { width, height, paths } = geom;
    const esc = (s)=>String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;");
    let out = [];
    out.push(`<?xml version="1.0" encoding="UTF-8"?>`);
    out.push(`<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">`);
    out.push(`<rect x="0" y="0" width="${width}" height="${height}" fill="white" fill-opacity="0.0"/>`);
    for (const p of paths) {
      const stroke = esc(p.stroke || "#000");
      const sw = p.sw ?? 1;
      const alpha = p.alpha ?? 1;
      const fill = p.fill ? esc(p.fill) : "none";
      const fa = p.fillAlpha ?? 1;
      if (p.type === "circle") {
        out.push(`<circle cx="${p.cx}" cy="${p.cy}" r="${p.r}" fill="${fill}" fill-opacity="${fa}" stroke="${stroke}" stroke-opacity="${alpha}" stroke-width="${sw}" />`);
      } else {
        const d = esc(p.d || "");
        out.push(`<path d="${d}" fill="${fill}" fill-opacity="${fa}" stroke="${stroke}" stroke-opacity="${alpha}" stroke-width="${sw}" stroke-linecap="round" stroke-linejoin="round" />`);
      }
    }
    out.push(`</svg>`);
    return out.join("\n");
  }

  function downloadText(filename, text, mime){
    const blob = new Blob([text], { type: mime || "text/plain" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function downloadDataUrl(filename, dataUrl){
    const a = document.createElement("a");
    a.href = dataUrl;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  function ghostKey(weekId){
    return `${STORAGE_KEY}__forest_ghost__${weekId}`;
  }

  function saveGhostSnapshot(weekId){
    try {
      const src = forestCanvas;
      const rect = src.getBoundingClientRect();
      const w = Math.max(420, Math.floor(rect.width));
      const h = Math.max(220, Math.floor(rect.height));
      const smallW = 720;
      const smallH = Math.floor((h / w) * smallW);

      const tmp = document.createElement("canvas");
      tmp.width = smallW;
      tmp.height = smallH;
      const tctx = tmp.getContext("2d");
      tctx.fillStyle = "rgba(255,255,255,0)";
      tctx.fillRect(0,0,smallW,smallH);
      tctx.drawImage(src, 0, 0, w, h, 0, 0, smallW, smallH);

      const url = tmp.toDataURL("image/webp", 0.7);
      localStorage.setItem(ghostKey(weekId), url);
    } catch {}
  }

  function loadGhostSnapshot(weekId){
    try {
      return localStorage.getItem(ghostKey(weekId));
    } catch { return null; }
  }

  function clearGhostSnapshot(weekId){
    try { localStorage.removeItem(ghostKey(weekId)); } catch {}
  }

  function renderForest(){
    const { weekId, perCourse, mode } = computeForestMetrics();
    const { courses, mat } = influenceMatrix(perCourse);

    const ink = getCSSVar("--ink") || "#3a3d5e";
    const { ctx, w, h } = initCanvasHiDPI(forestCanvas);
    ctx.clearRect(0,0,w,h);

    // Ghost overlay from previous week (faint trace)
    const prevId = prevIsoWeekId(weekId);
    const ghostUrl = loadGhostSnapshot(prevId);
    if (ghostUrl) {
      const img = new Image();
      img.onload = () => {
        ctx.save();
        ctx.globalAlpha = 0.08;
        ctx.drawImage(img, 0, 0, w, h);
        ctx.restore();
        drawForestCore(ctx, w, h, ink, perCourse, courses, mat, weekId, mode);
      };
      img.src = ghostUrl;
    } else {
      drawForestCore(ctx, w, h, ink, perCourse, courses, mat, weekId, mode);
    }

    const maxInfo = forestMaxInfo(weekId, courses);
    forestLegendEl.innerHTML = forestLegendHTML(weekId, maxInfo);
    forestLegendEl.classList.toggle("show", !!state.forest.legendOn);
  }

  function forestMaxInfo(weekId, courses){
    const max = state.forest.perCourseMax || {};
    let best = { course: "", syntax: -1 };
    for (const c of courses) {
      const m = max[c] || {};
      if ((m.maxSyntax||0) > best.syntax) best = { course: c, syntax: (m.maxSyntax||0) };
    }
    return { weekId, best, per: max };
  }

  function forestLegendHTML(weekId, info){
    const best = info.best.course
      ? `<b>Highest complexity:</b> ${escapeHtml(info.best.course)} (${Number(info.best.syntax).toFixed(2)})`
      : `<b>Highest complexity:</b> (none yet)`;
    return `
      <div style="display:grid;gap:6px;">
        <div><b>Forest mappings</b></div>
        <div>• <b>Height</b> = writing volume (max words this week)</div>
        <div>• <b>Branching</b> = syntactic / derivational complexity (clauses + punctuation + sentence stats)</div>
        <div>• <b>Leaf clusters</b> = completed tasks (max this week)</div>
        <div>• <b>Trunk thickness</b> = current “stress” from course status (steady→danger)</div>
        <div>• <b>Mycelium</b> = organic filament field biased by shared signifier overlap</div>
        <div>${best}</div>
        <div class="mini">Week: <code>${escapeHtml(weekId)}</code>. Trees do not shrink from deleted text; stress + mode checkboxes remain dynamic.</div>
      </div>
    `;
  }

  // --------- Organic mycelium: filament field ----------
  function drawMyceliumField(ctx, geom, w, h, baseY, courses, perCourse, mat, ink, weekId, mode) {
    const r = seededRand("myc-field::" + weekId);

    // Density responds to daily checkbox completion (dynamic)
    const dailyBoost = 0.7 + 0.6 * clamp(mode?.dailyRatio ?? 0, 0, 1);
    const densityBase = Math.round(160 * dailyBoost);

    // Subterrain depth (visible due to higher canvas + raised ground)
    const depthRange = 120;
    const minLen = 18;
    const maxLen = 105;

    // a subtle soil haze
    ctx.save();
    ctx.fillStyle = "rgba(58,61,94,0.035)";
    ctx.fillRect(0, baseY + 6, w, Math.max(0, h - (baseY + 6)));
    ctx.restore();

    // sample multiple filaments; each chooses a semantic "hot zone" influence
    for (let k = 0; k < densityBase; k++) {
      const x0 = r() * w;
      const y0 = baseY + 10 + r() * depthRange;

      const i = Math.floor(r() * courses.length);
      const j = Math.floor(r() * courses.length);
      const influence = clamp((mat[i]?.[j] || 0), 0, 1);

      const thickness = 0.35 + 2.4 * influence;
      const length = minLen + (maxLen - minLen) * (0.35 + 0.95*influence) * r();
      const alphaBase = 0.018 + 0.07 * influence;

      const branches = 2 + Math.floor(6 * influence);

      growFilament(x0, y0, length, -Math.PI/2 + (r()-0.5)*0.9, branches, thickness, alphaBase);

      function growFilament(x, y, len, ang, depth, thick, alpha) {
        if (depth <= 0 || len < 9) return;

        const nx = x + Math.cos(ang) * len;
        const ny = y + Math.sin(ang) * len;

        // organic curvature: lateral noise
        const cx = x + Math.cos(ang) * len * 0.45 + (r()-0.5)*16;
        const cy = y + Math.sin(ang) * len * 0.45 + (r()-0.5)*14;

        // keep within soil band
        if (ny < baseY + 4) return;
        if (ny > h + 30) return;

        ctx.save();
        ctx.strokeStyle = ink;
        ctx.globalAlpha = alpha;
        ctx.lineWidth = Math.max(0.35, thick * (depth/7));
        ctx.beginPath();
        ctx.moveTo(x,y);
        ctx.quadraticCurveTo(cx, cy, nx, ny);
        ctx.stroke();
        ctx.restore();

        geom.paths.push({
          d: `M ${x} ${y} Q ${cx} ${cy} ${nx} ${ny}`,
          stroke: ink,
          sw: Math.max(0.35, thick * (depth/7)),
          alpha: alpha,
          fill: "none"
        });

        // branching probabilities
        const jitter = (r()-0.5) * 0.9;
        if (r() < (0.62 + 0.18*influence)) {
          growFilament(nx, ny, len*(0.62 + 0.18*r()), ang + jitter*0.55, depth-1, thick*0.92, alpha*0.92);
        }
        if (r() < (0.38 + 0.24*influence)) {
          growFilament(nx, ny, len*(0.50 + 0.18*r()), ang - jitter*0.55, depth-1, thick*0.90, alpha*0.90);
        }
      }
    }
  }

  // --------- Forest core ----------
  function drawForestCore(ctx, w, h, ink, perCourse, courses, mat, weekId, mode){
    // geometry capture for SVG export
    const geom = { width: w, height: h, paths: [] };
    lastForestGeom = geom;

    // baseline + padding so tops never clip; raise ground slightly for subterrain
    const padL = 18, padR = 18, padT = 18, padB = 56;
    const groundRaise = 22;                   // raised ground to show mycelium
    const baseY = (h - padB) - groundRaise;

    // draw ground line
    ctx.save();
    ctx.strokeStyle = getCSSVar("--line") || "#dbdbdb";
    ctx.globalAlpha = 0.35;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, baseY);
    ctx.lineTo(w, baseY);
    ctx.stroke();
    ctx.restore();

    // compute scaling so tallest tree fits (includes canopy headroom)
    const max = state.forest.perCourseMax || {};
    const maxWords = Math.max(1, ...courses.map(c => (max[c]?.maxWords || 0)));
    const trunkMaxRaw = 90 + Math.log(1 + maxWords) * 72;

    const canopyFactor = 1.38;
    const canopyPadding = 30;
    const totalMaxRaw = trunkMaxRaw * canopyFactor + canopyPadding;

    const maxTargetHeight = (baseY - padT) * 0.74;
    const scale = Math.min(0.62, maxTargetHeight / Math.max(150, totalMaxRaw));

    const span = Math.max(1, courses.length - 1);
    const usableW = w - padL - padR;
    const xFor = (i) => padL + (i / span) * usableW;

    // organic mycelium under trees
    drawMyceliumField(ctx, geom, w, h, baseY, courses, perCourse, mat, ink, weekId, mode);

    // trees
    for (let i=0;i<courses.length;i++){
      const course = courses[i];
      const mMax = max[course] || { maxWords:0, maxSyntax:0, maxCohesion:0, maxLeaves:0 };

      const x0 = xFor(i);
      const r = seededRand(`${weekId}::${course}`);

      // Height from writing volume (max-memory)
      const words = mMax.maxWords || 0;
      const height = scale * (90 + Math.log(1 + words) * 72);

      // Syntax -> branchiness (max-memory)
      const syntax = mMax.maxSyntax || 0;
      const branchiness = clamp(syntax / 3.2, 0.1, 1.0);

      // Semantic cohesion -> leaf clustering (max-memory)
      const cohesion = mMax.maxCohesion || 0;
      const cohesionN = clamp(cohesion / 3.0, 0.0, 1.0);

      // Completed tasks -> leafCount driver (max-memory)
      const leaves = mMax.maxLeaves || 0;

      // Stress is dynamic (current, not max)
      const stress = clamp((perCourse[course]?.stress ?? 0.18), 0.1, 1.0);
      const trunkW = 1.0 + 3.8*stress;

      // Dynamic "sunlight" from daily modes: slight canopy lift/energy
      const dayLight = 0.88 + 0.22 * clamp(mode?.dailyRatio ?? 0, 0, 1);

      const mature = branchiness > 0.78;
      const crownSpread = mature ? 1.55 : 1.0;
      const curvature = mature ? 1.15 : 0.7;

      // Draw trunk
      ctx.save();
      ctx.strokeStyle = ink;
      ctx.globalAlpha = 0.33 + 0.22*stress;
      ctx.lineWidth = trunkW;
      ctx.setLineDash([]);

      const trunkTop = { x: x0 + (r()-0.5)*2, y: baseY - height*dayLight };
      trunkTop.y = Math.max(trunkTop.y, padT + 8);

      ctx.beginPath();
      ctx.moveTo(x0, baseY);
      ctx.lineTo(trunkTop.x, trunkTop.y);
      ctx.stroke();
      ctx.restore();

      geom.paths.push({
        d: `M ${x0} ${baseY} L ${trunkTop.x} ${trunkTop.y}`,
        stroke: ink,
        sw: trunkW,
        alpha: (0.33 + 0.22*stress),
        fill: "none"
      });

      // Branch recursion
      const maxDepth = Math.round(3 + 6*branchiness);
      const baseAngle = -Math.PI/2;

      const leafPoints = [];
      function branch(x,y, len, ang, depth){
        if (depth <= 0 || len < 6) { leafPoints.push({x,y}); return; }
        const nx = x + Math.cos(ang) * len;
        const ny = y + Math.sin(ang) * len;

        const sw = Math.max(0.6, (trunkW * 0.72) * (depth/(maxDepth+1)));
        const alpha = 0.12 + 0.18 * (depth/(maxDepth+1));

        ctx.save();
        ctx.strokeStyle = ink;
        ctx.globalAlpha = alpha;
        ctx.lineWidth = sw;
        ctx.beginPath();
        ctx.moveTo(x,y);
        const cx = x + Math.cos(ang) * len * 0.55 + (r()-0.5) * 6 * curvature;
        const cy = y + Math.sin(ang) * len * 0.55 + (r()-0.5) * 6 * curvature;
        ctx.quadraticCurveTo(cx, cy, nx, ny);
        ctx.stroke();
        ctx.restore();

        geom.paths.push({
          d: `M ${x} ${y} Q ${cx} ${cy} ${nx} ${ny}`,
          stroke: ink,
          sw,
          alpha,
          fill: "none"
        });

        const split = (r() < (0.55 + 0.35*branchiness)) ? 2 : 1;
        const jitter = (r()-0.5) * 0.18;
        const spread = (0.35 + 0.85*branchiness) * crownSpread;

        if (split === 1){
          const a2 = ang + jitter + (r()-0.5)*0.08;
          branch(nx, ny, len*(0.70 + 0.10*r()), a2, depth-1);
        } else {
          const aL = ang - (0.22 + 0.28*r())*spread + jitter;
          const aR = ang + (0.22 + 0.28*r())*spread + jitter;
          branch(nx, ny, len*(0.66 + 0.10*r()), aL, depth-1);
          branch(nx, ny, len*(0.66 + 0.10*r()), aR, depth-1);
          if (mature && r() < 0.30) {
            const aM = ang + (r()-0.5)*0.35*spread;
            branch(nx, ny, len*(0.55 + 0.08*r()), aM, depth-2);
          }
        }
      }

      const startLen = clamp(18 + height * (0.18 + 0.06*r()), 18, 74);
      branch(trunkTop.x, trunkTop.y, startLen, baseAngle + (r()-0.5)*0.16, maxDepth);

      // Leaves
      const leafCount = Math.min(140, Math.round(leaves * (6 + 10*cohesionN) * (0.92 + 0.18*mode.dailyRatio)));
      if (leafCount > 0 && leafPoints.length) {
        ctx.save();
        ctx.strokeStyle = ink;
        ctx.fillStyle = "rgba(58,61,94,0.10)";
        ctx.globalAlpha = 0.9;

        const clusters = Math.max(1, Math.round(4 - 3*cohesionN));
        const centers = [];
        for (let c=0;c<clusters;c++){
          centers.push(leafPoints[Math.floor(r()*leafPoints.length)]);
        }

        for (let k=0;k<leafCount;k++){
          const center = centers[Math.floor(r()*centers.length)];
          const spreadPx = 10 + 40*(1 - cohesionN);
          const px = center.x + (r()-0.5)*spreadPx;
          const py = center.y + (r()-0.5)*spreadPx;

          const rad = 1.2 + 1.8*r();
          ctx.beginPath();
          ctx.arc(px, py, rad, 0, Math.PI*2);
          ctx.fill();
          if (r() < 0.35) { ctx.globalAlpha = 0.20; ctx.stroke(); ctx.globalAlpha = 0.9; }

          geom.paths.push({
            type: "circle",
            cx: px, cy: py, r: rad,
            stroke: ink, sw: 0.8,
            alpha: 0.15,
            fill: "rgba(58,61,94,0.10)",
            fillAlpha: 1
          });
        }
        ctx.restore();
      }

      // Course labels
      ctx.save();
      ctx.fillStyle = ink;
      ctx.globalAlpha = 0.35;
      ctx.font = "11px " + getCSSVar("--sans");
      ctx.textAlign = "center";
      ctx.fillText(course, x0, h - 16);
      ctx.restore();
    }

    // save snapshot for this week so it becomes next week's ghost
    saveGhostSnapshot(weekId);
  }

  // Debounced forest updates while typing
  const debouncedForest = debounce(() => {
    try { renderForest(); } catch {}
  }, 180);

  // ---------- Hydration ----------
  function hydrateInputs() {
    intentEl.value = state.intent || "";
    coreWindowEl.value = state.coreWindow || "";
    weekendPostureEl.value = state.weekendPosture || "";
    rebalanceDayEl.value = state.rebalanceDay || "Sunday";

    absorptionEl.value = state.absorption || "";
    workoutEl.value = state.workout || "";
    todayNotesEl.value = state.todayNotes || "";

    courseListEl.value = state.courses.join("; ");

    writingTemplateEl.value = state.writingTemplate || "";
    writingCadenceEl.value = state.writingCadence || "";
    writingThreadEl.value = state.writingThread || "";
    writingOutputEl.value = state.writingOutput || "";

    downtimeRuleEl.value = state.downtimeRule || "";

    renderModeChips();
    renderKeystoneDropdown();
    renderCourseCards();
    renderTasks();
    renderWritingLog();
    renderWeekSummary();

    if (state.mdCache) mdPreviewEl.textContent = state.mdCache;

    forestLegendEl.classList.toggle("show", !!state.forest.legendOn);
    debouncedForest();
  }

  // ---------- Wire up ----------
    // ---------- Wire up ----------
    intentEl.addEventListener("input", () => { state.intent = intentEl.value; saveState(); });
  coreWindowEl.addEventListener("input", () => { state.coreWindow = coreWindowEl.value; saveState(); });
  weekendPostureEl.addEventListener("input", () => { state.weekendPosture = weekendPostureEl.value; saveState(); });
  rebalanceDayEl.addEventListener("change", () => { state.rebalanceDay = rebalanceDayEl.value; saveState(); });

  keystoneTodayEl.addEventListener("change", () => {
    state.keystoneToday = keystoneTodayEl.value;
    saveState();
    renderWeekSummary();
    debouncedForest();
  });

  absorptionEl.addEventListener("input", () => {
    state.absorption = absorptionEl.value;
    saveState();
  });

  workoutEl.addEventListener("input", () => {
    state.workout = workoutEl.value;
    saveState();
  });

  todayNotesEl.addEventListener("input", () => {
    state.todayNotes = todayNotesEl.value;
    saveState();
    debouncedForest();
  });

  courseListEl.addEventListener("keydown", (e) => {
    if (e.key === "Enter") { e.preventDefault(); el("btnApplyCourses").click(); }
  });

  writingTemplateEl.addEventListener("input", () => { state.writingTemplate = writingTemplateEl.value; saveState(); });
  writingCadenceEl.addEventListener("input", () => { state.writingCadence = writingCadenceEl.value; saveState(); });
  writingThreadEl.addEventListener("input", () => { state.writingThread = writingThreadEl.value; saveState(); });
  writingOutputEl.addEventListener("input", () => { state.writingOutput = writingOutputEl.value; saveState(); });

  downtimeRuleEl.addEventListener("input", () => { state.downtimeRule = downtimeRuleEl.value; saveState(); });

  // ---------- Buttons ----------

    // ---------- Buttons ----------
    el("btnAddTodayTask").addEventListener("click", () => {
      state.todayTasks.push({ id: uid(), done: false, title: "", course: state.keystoneToday || state.courses[0], mode: "(mode)" });
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
      toast("Added Today task");
      // focus newest title
      setTimeout(() => {
        const rows = todayTasksEl.querySelectorAll(".task input.title");
        rows[rows.length - 1]?.focus();
      }, 0);
    });

    el("btnClearTodayDone").addEventListener("click", () => {
      state.todayTasks = state.todayTasks.filter(t => !t.done);
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
      toast("Cleared completed Today tasks");
    });

    el("btnAddWeekendTask").addEventListener("click", () => {
      state.weekendTasks.push({ id: uid(), done: false, title: "", course: state.courses[0], mode: "(mode)" });
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
      toast("Added Weekend deliverable");
      setTimeout(() => {
        const rows = weekendTasksEl.querySelectorAll(".task input.title");
        rows[rows.length - 1]?.focus();
      }, 0);
    });

    el("btnClearWeekendDone").addEventListener("click", () => {
      state.weekendTasks = state.weekendTasks.filter(t => !t.done);
      saveState();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
      toast("Cleared completed Weekend tasks");
    });

    el("btnApplyCourses").addEventListener("click", () => {
      const raw = String(courseListEl.value || "");
      const list = raw.split(";").map(x => x.trim()).filter(Boolean);

      if (!list.length) {
        toast("Course list is empty");
        return;
      }

      // Preserve existing notes where possible
      const old = state.courseNotes || {};
      const nextNotes = {};
      list.forEach(c => { nextNotes[c] = old[c] || { status: "steady", focus: "", budget: "", notes: "" }; });

      // Update tasks that pointed to removed courses -> move to first course
      const fallback = list[0];
      for (const t of [...state.todayTasks, ...state.weekendTasks]) {
        if (!list.includes(t.course)) t.course = fallback;
      }

      state.courses = list;
      state.courseNotes = nextNotes;

      if (!list.includes(state.keystoneToday)) state.keystoneToday = fallback;

      saveState();
      renderKeystoneDropdown();
      renderCourseCards();
      renderTasks();
      renderWeekSummary();
      debouncedForest();
      toast("Applied courses");
    });

    // Writing form
    el("btnShowWritingForm").addEventListener("click", () => {
      writingFormEl.classList.toggle("show");
      if (writingFormEl.classList.contains("show")) writingMinutesEl.focus();
    });

    el("btnCancelWritingForm").addEventListener("click", () => {
      writingFormEl.classList.remove("show");
      writingMinutesEl.value = 45;
      writingOutputShortEl.value = "";
      writingNotesShortEl.value = "";
    });

    el("btnSaveWritingSession").addEventListener("click", () => {
      const minutes = Number(writingMinutesEl.value || 0);
      const output = String(writingOutputShortEl.value || "").trim();
      const notes = String(writingNotesShortEl.value || "").trim();
      const date = new Date().toLocaleString(undefined, { weekday:"short", month:"short", day:"numeric", hour:"2-digit", minute:"2-digit" });

      state.writingLog.push({
        id: uid(),
        minutes: Math.max(0, minutes),
        output: output || "Writing session",
        notes,
        date
      });

      saveState();
      writingFormEl.classList.remove("show");
      writingMinutesEl.value = 45;
      writingOutputShortEl.value = "";
      writingNotesShortEl.value = "";
      renderWritingLog();
      renderWeekSummary();
      debouncedForest();
      toast("Saved writing session");
    });

    el("btnClearWritingLog").addEventListener("click", () => {
      state.writingLog = [];
      saveState();
      renderWritingLog();
      renderWeekSummary();
      debouncedForest();
      toast("Cleared writing log");
    });

    // Markdown export buttons
    el("btnGenerateMd").addEventListener("click", () => {
      const md = generateMarkdown();
      setMdPreview(md);
      toast("Generated markdown");
    });

    el("btnCopyMd").addEventListener("click", async () => {
      const md = state.mdCache || generateMarkdown();
      setMdPreview(md);
      try {
        await navigator.clipboard.writeText(md);
        toast("Copied");
      } catch {
        toast("Copy failed (browser blocked)");
      }
    });

    el("btnDownloadMd").addEventListener("click", () => {
      const md = state.mdCache || generateMarkdown();
      setMdPreview(md);
      const dateISO = new Date().toISOString().slice(0,10);
      downloadText(`semester-dashboard_${dateISO}.md`, md, "text/markdown");
      toast("Downloaded .md");
    });

    // Reset day/week checkboxes
    el("btnResetDay").addEventListener("click", () => {
      for (const k of Object.keys(state.modeChecks)) {
        if ((state.modeScope?.[k] || "weekly") === "daily") state.modeChecks[k] = false;
      }
      saveState();
      renderModeChips();
      renderWeekSummary();
      debouncedForest();
      toast("Reset daily modes");
    });

    el("btnResetWeek").addEventListener("click", () => {
      for (const k of Object.keys(state.modeChecks)) {
        if ((state.modeScope?.[k] || "weekly") === "weekly") state.modeChecks[k] = false;
      }
      saveState();
      renderModeChips();
      renderWeekSummary();
      debouncedForest();
      toast("Reset weekly modes");
    });

    // Backup / reset
    el("btnBackup").addEventListener("click", () => {
      try {
        const dateISO = new Date().toISOString().slice(0,10);
        downloadText(`semester-dashboard_backup_${dateISO}.json`, JSON.stringify(state, null, 2), "application/json");
        toast("Exported JSON");
      } catch {
        toast("Export failed");
      }
    });

    el("btnHardReset").addEventListener("click", () => {
      const ok = confirm("Hard reset will wipe all locally saved dashboard data. Continue?");
      if (!ok) return;
      try { localStorage.removeItem(STORAGE_KEY); } catch {}
      state = structuredDefault();
      saveState();
      hydrateInputs();
      toast("Wiped local data");
    });

    // Forest controls
    el("btnToggleLegend").addEventListener("click", () => {
      state.forest.legendOn = !state.forest.legendOn;
      saveState();
      forestLegendEl.classList.toggle("show", !!state.forest.legendOn);
      toast(state.forest.legendOn ? "Legend on" : "Legend off");
    });

    el("btnExportPNG").addEventListener("click", () => {
      try {
        const dateISO = new Date().toISOString().slice(0,10);
        const url = forestCanvas.toDataURL("image/png");
        downloadDataUrl(`forest_${dateISO}.png`, url);
        toast("Exported PNG");
      } catch {
        toast("PNG export failed");
      }
    });

    el("btnExportSVG").addEventListener("click", () => {
      try {
        if (!lastForestGeom) renderForest();
        const dateISO = new Date().toISOString().slice(0,10);
        const svg = forestToSVG(lastForestGeom);
        downloadText(`forest_${dateISO}.svg`, svg, "image/svg+xml");
        toast("Exported SVG");
      } catch {
        toast("SVG export failed");
      }
    });

    el("btnClearGhost").addEventListener("click", () => {
      const current = isoWeekId(new Date());
      const prev = prevIsoWeekId(current);
      clearGhostSnapshot(prev);
      debouncedForest();
      toast("Cleared last-week ghost");
    });

    // ---------- Keyboard shortcuts ----------
    function isTypingTarget(evt){
      const t = evt.target;
      if (!t) return false;
      const tag = (t.tagName || "").toLowerCase();
      return tag === "input" || tag === "textarea" || tag === "select";
    }

    window.addEventListener("keydown", (e) => {
      // Save (Ctrl/⌘+S)
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "s") {
        e.preventDefault();
        saveState();
        toast("Saved");
        return;
      }

      // "g then m" for markdown generation
      // simple two-key chord within 900ms
      if (!window.__gmState) window.__gmState = { t: 0, g: false };
      const gm = window.__gmState;

      const key = e.key.toLowerCase();

      if (key === "g" && !e.ctrlKey && !e.metaKey && !e.altKey) {
        if (!isTypingTarget(e)) {
          gm.g = true;
          gm.t = Date.now();
          return;
        }
      }
      if (key === "m" && gm.g && (Date.now() - gm.t) < 900) {
        if (!isTypingTarget(e)) {
          gm.g = false;
          const md = generateMarkdown();
          setMdPreview(md);
          toast("Generated markdown");
        }
        return;
      }
      if ((Date.now() - gm.t) >= 900) gm.g = false;

      // Add tasks (n / w) when not typing
      if (!isTypingTarget(e) && !e.ctrlKey && !e.metaKey && !e.altKey) {
        if (key === "n") { el("btnAddTodayTask").click(); }
        if (key === "w") { el("btnAddWeekendTask").click(); }
      }
    });

    // ---------- Responsive: rerender canvas on resize ----------
    window.addEventListener("resize", debounce(() => {
      debouncedForest();
    }, 120));

    // ---------- Init ----------
    // Ensure weekId is set early to support ghost logic without flicker
    if (!state.forest.weekId) state.forest.weekId = isoWeekId(new Date());
    hydrateInputs();

    // If first load has no md cache, show empty but ready
    if (!state.mdCache) mdPreviewEl.textContent = "(Generate markdown to preview here.)";

  </script>
</body>
</html>
